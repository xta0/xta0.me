---
list_title: C++中的shared_ptr
title: C++中的shared_ptr
layout: post
categories: ["C++"]
---

C++中的`shared_ptr`用来方便管理head-allocated对象，它虽然简单易用，但会带来一些副作用，比如perf和code size的问题。`shared_ptr`里面维护着一个atomic的refcount

```cpp
struct shared_ptr_control_block {
    some_atomic_counter_type reference_count;
    // maybe other stuff....
};

template<typename T>
struct shared_ptr {
    T *data;
    shared_ptr_control_block *cntrl;
};
```
当一个`shared_ptr`被创建时，这个`shared_ptr_control_block`是会在heap上单独创建。`shared_ptr`的构造函数，copy构造和析构函数都需要维护这个refcount。为了在多线程的环境下能正确工作，refcount的bump是atomic的。和正常的increament, decrement相比，atomic的操作是非常expensive的，[uops.info](https://uops.info/table.html)的数据显示atomic increment的速度是non-atomic increment的5倍。如果多个线程同时bump refcount，性能的损失会非常大，因为原子操作无法在多线程中同时执行。

### `shared_ptr`作为参数传递

将`shared_ptr`作为参数传递要谨慎，有些时候callee是不需要take ownership的，所以这个时候要用`const T&`或者`T&`。

```cpp
void f(std::shared_ptr<Widget>); // Shares ownership
void g(const std::shared_ptr<Widget>&); // May or may not take ownership
void h(const Widget&); // Doesn't take ownership
```
我们看几个例子

```cpp
void f(const std::shared_ptr<Widget>& x) {
  x->foo();
}

void g() {
  auto p = std::make_shared<Widget>(/*...*/);
  f(p);
}
```
上面这个case，`f`并不需要接受一个`shared_ptr`

### More on Smart Pointer Parameters

