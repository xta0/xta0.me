---
layout: post
list_title: C++ Primer| Tools for large programs| 用于大型程序工具
title: 用于大型程序工具
categories: [C++]
---

## 异常处理

C++中使用`throw`抛异常，异常后面的代码将不会执行，如果没有`try-catch`来捕获异常，系统会调用`terminate`函数。

### `try-catch`

如果出现异常，系统会在函数中找与`try`匹配的`catch`，如果没找到则会继续检查外层的`catch`。这会触发stack unwinding，即当前函数如果没有catch住，则当前函数栈会被释放，栈里的类对象会触发析构函数，为了确保对象能被正常释放，析构函数不应该抛出不能被他自身处理的异常。换句话说，如果析构函数中需要执行某个可能抛异常的函数，则必须使用`try-catch`，确保异常在析构函数内部被处理。

被throw的异常对象位于内存中的一个特殊位置，编译器会确保该对象在`catch`中被访问到并正常销毁。如果抛出的对象是一个指向局部变量的指针，则被指向的对象可能已经被销毁。另外，throw对象的类型在编译期就已经确定，如果它是一个指向基类的`Base*` 指针，在触发异常时，指向的对象是一个子类的对象，则只有基类部分的内存会被保留，这点需要特别注意。

有时一个单独的`catch`不能完整的处理异常，此时可以继续将异常抛给外层的`catch`

```cpp
catch(some_error& err){
    throw; //rethrow the error to the 
}
```
如果要捕获所有异常，可以用`catch(...)`，如果有多个`catch`语句，则它必须出现在最后的位置

### `try-catch` 和构造函数

如果构造函数会抛异常，我们需要将其置于`try-catch`内

```cpp
template<typename T>
Blob<T>::Blob(std::initializer_list<T> il) try:
    data(std::make_shared<std::vector<T>>(il)) {}
catch (const std::bad_alloc &e) {
    handle_out_of_memory(e);
}
```
此时`try-catch`既能捕获构造函数的异常，也能捕获成员初始化列表抛出的异常。

### `noexcept`

对编译器来说，如果预先知道某个函数不会抛出异常，则编译器会简化调用该函数的代码，节省code size。C++11可以用`noexcept`指定某个函数不会抛异常

```cpp
void recoup(int) noexcept;
```
如果是成员函数，`noexcept`需要跟在`const`以及引用符号后面，而在`final`和`override`或虚函数`=0`之前。如果一个声明了`noexcept`的函数内部仍然抛出异常，则系统会直接调用`terminate()`。

## `namespace`

定义在`namespace {}`中的变量其生命周期和`static`变量相同，在程序结束后才会被销毁。注意，定义在`namespace {}`中的变量只对所在文件可见，它们彼此独立，即使名字相同，它们也是不同的变量。如果头文件中有变量定义在`namespace {}`中，那么包含他们的cpp文件得到的是不同实体。

> C语言中用`static`声明静态变量或函数，在C++中等价于`namespace{}`

## `new`和`delete`

当我们执行一条`new`表达式时

```cpp
std::string* sp = new string("value");
delete sp;
```
实际上执行了三步操作，首先调用`operator new`的标准库函数分配空间，其次是调用构造函数为成员赋值，最后返回该对象的指针。`delete`则首先调用对象的析构函数，然后调用`oeprator delete`释放内存。`operator new`和`operator delete`可以被重载来自定义内存分配规则。

```cpp
void* operator new(size_t size) {
    if(void* mem = malloc(size)) {
        return mem;
    } else {
        throw bad_alloc();
    }
}

void operator delete(void* mem) noexcept {
    free(mem);
}
```

一般情况下，我们可以自定义具有任何参数的`operator new`，但是下面这个函数是不能被重载的，它只能被标准库使用

```cpp
void* operator new(size_t, void*);
```

### Placement `new`

由于`operator new`只负责分配空间而不负责调用构造函数，如果我们要同时自定义`new`和构造对象，则需要使用placement new。其形式如下

```cpp
new (place_address) type
new (place_address) type (initializers)
new (place_address) type [size]
new (place_address) type [size] {braced initializer list}
```
其中`place_address`是一个指针，此时placement new允许我们在该指针指向的地址上直接构造对象，而不用分配内存

```cpp
MyClass * p1 = new MyClass();
new (p2) MyClass();
// does not allocate memory
// calls: operator new (sizeof(MyClass),p2)
// but constructs an object at p2
```
placement new接受的指针可以是任何指针，也就是说甚至可以在stack上分配空间。在底层实现上，placement new实际上就是调用了上面提到的 `void* operator new(size_t, void*)`函数，它不分配任何内存，只是返回指针。

### 显式调用析构函数

编译器支持手动调用析构函数，它可以销毁对象，但不能释放内存

```cpp
string *sp = new string("value");
sp -> ~string(); //memory is not deallocated
```

## RTTI

运行时类型识别(RTTI)的功能由两个运算符实现

- `typeid`用于返回表达式类型
- `dynamic_cast`用于将基类指针或者引用安全的转换到派生类





## Resources

- [C++ Primer](http://www.charleshouserjr.com/Cplus2.pdf)