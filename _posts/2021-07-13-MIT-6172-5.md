---
list_title: Note | MIT 6.172 - 5
title: C to Assembly
layout: post
mathjax: true
---

### How Does C Code Become Assembly

The compiler does a lot of stuff to translate C code to assembly

- Choose assembly instructions to implement C oeprations
- Implement C conditionals and loops using jumps and branches
- Choose registers and memory locations to store data
- Move data among the registers and memory to satifisy dependecies
- Coordinate function calls
- Try to make the assembly fast.

However, the direct mapping from C to assembly is not so obvious

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-1.png">

### Clang/LLVM Compilation Pipeline

To understand this translation process, let us see how the compiler reasons about it.

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-2.png">

You can see what `clang` compiler does by looking at the LLVM IR

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-3.png">

## outline

- LLVM IR Primer
- C To LLVM IR
    - Straigh-line C code to LLVM IR
    - C functions to LLVM IR
    - C conditions to LLVM IR
    - LLVM IR aatributes
- LLVM IR to Assembly
    - Linux x86-64 calling convention

### Components of LLVM IR

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-4.png">

LLVM IR is similar to assembly
- LLVM IR uses a simple instruction format, i.e., `<dst operand> = <op code><src operands>`
- LLVM IR code adopts a similar structure to assembly code
- Control flow is implemented using conditional and unconditional branches

LLVM IR is simpler than assembly
- Smaller instruction set
- Infinite LLVM IR registers, similar to variables in C
- No implicit FLAGS register or condition codes
- No explicit stack pointer or frame pointer
- C-like type system
- C-like functions

### LLVM IR Registers

LLVM IR stores values variables, called registers
- Syntax: `%<name>`
- LLVM register are like C variables: LLVM supports an infinite number of registers, each distinguished by name
- Register names are local to each LLVM IR function

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-5.png">

One catch: We shall see that LLVM hijacks its syntax for registers to refer to "basic blocks".

### LLVM IR Instructions

LLVM-IR code is organized into instructions
- Syntax for instructions that produce a value: `%<name> = <opcode> <operand list>`
- Syntax for other insturctions: `<opcode> <operand list>`
- Operands are registers, constants, or "basica blocks"

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-6.png">

### Common LLVM IR Instructions

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-7.png">

### LLVM IR Data Types

- Integers: `i<number>`
    - A 64-bit integer: `i64`
    - 


## Resources

- [LLVM中与IR]