---
list_title: Note | MIT 6.172 - 5
title: C to Assembly
layout: post
mathjax: true
---

### How Does C Code Become Assembly

The compiler does a lot of stuff to translate C code to assembly

- Choose assembly instructions to implement C oeprations
- Implement C conditionals and loops using jumps and branches
- Choose registers and memory locations to store data
- Move data among the registers and memory to satifisy dependecies
- Coordinate function calls
- Try to make the assembly fast.

However, the direct mapping from C to assembly is not so obvious

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-1.png">

### Clang/LLVM Compilation Pipeline

To understand this translation process, let us see how the compiler reasons about it.

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-2.png">

You can see what `clang` compiler does by looking at the LLVM IR

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-3.png">

## outline

- LLVM IR Primer
- C To LLVM IR
    - Straigh-line C code to LLVM IR
    - C functions to LLVM IR
    - C conditions to LLVM IR
    - LLVM IR aatributes
- LLVM IR to Assembly
    - Linux x86-64 calling convention

### Components of LLVM IR

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-4.png">

LLVM IR is similar to assembly
- LLVM IR uses a simple instruction format, i.e., `<dst operand> = <op code><src operands>`
- LLVM IR code adopts a similar structure to assembly code
- Control flow is implemented using conditional and unconditional branches

LLVM IR is simpler than assembly
- Smaller instruction set
- Infinite LLVM IR registers, similar to variables in C
- No implicit FLAGS register or condition codes
- No explicit stack pointer or frame pointer
- C-like type system
- C-like functions

### LLVM IR Registers

LLVM IR stores values variables, called registers
- Syntax: `%<name>`
- LLVM register are like C variables: LLVM supports an infinite number of registers, each distinguished by name
- Register names are local to each LLVM IR function

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-5.png">

One catch: We shall see that LLVM hijacks its syntax for registers to refer to "basic blocks".

### LLVM IR Instructions

LLVM-IR code is organized into instructions
- Syntax for instructions that produce a value: `%<name> = <opcode> <operand list>`
- Syntax for other insturctions: `<opcode> <operand list>`
- Operands are registers, constants, or "basica blocks"

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-6.png">

### Common LLVM IR Instructions

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-7.png">

### LLVM IR Data Types

- Integers: `i<number>`
    - A 64-bit integer: `i64`
    - A 1-bit integer: `i1`
- Floating-point values: `double`, `float`
- Arrays: `[<number> x <type>]`
    - An array of 5 integer: `[5 x i32]`
- Structs: `{<type>, ...}`
- Vectors: `< <number> x <type> >`
- Pointers: `<type>*`
    - A pointer to an 8-bit integer: `i8*`
- Labels(i.e., basic blocks): `label`

### Straight-line C code to LLVM IR

Straight-line C code (i.e., containing no conditionals or loops) becomes a sequence of LLVM IR instructions
- Arguments are evaluated before the C operation
- Intermediate results are stored in registers

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-8.png">

**Aggregate Types**

A variable with an aggregate type (i.e., an array or a struct) is typically stored in memory

Accessing the aggregate type involves computing an address and then reading or writing memory.

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-9.png">

The `getelementptr` instruction computes a memory address from a pointer and a list of indices. Example: Compute the address `%2 + 0 + %4`. 

```shell
%5 = getelementptr inbounds [7 x i32], [7 x i32]* %2, i64 0, i64 %4
```

### LLVM IR Functions

Functions in LLVM IR resemble functions in C.

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-10.png">

LLVM IR function parameters amp directly to their C counterparts.

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-11.png">

### Baisc Blocks

The body of a function definition is partitioned into basic blocks: sequence of instructions (i.e., straight-line code) where control only enters through the first instruction and only exists from the last.

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-12.png">

### Control-Flow Graphs

Control-flow instructions (e.g., `br` instructions) induce **control-flow edges** between the basic blocks of a function, creating a **control-flow graph(CFG)**. 

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-13.png">

### C Conditionals

A conditional in C is translated into a **conditional branch instruction**, `br`, in LLVM IR

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-14.png">

The conditional branch in LLVM IR takes as arugments a `1-bit` integer and two `basic-blcok labels`.

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-15.png">

A conditional branch terminates its basic block and creates 2 outgoing control-flow edeges in CFG.

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-16.png">

### Unconditional Branches

If a `br` instructions has just one operand, it is an **unconditional branch**

An unconditional branch terminates its basic block and produces `1` outgoing control-flow edge.

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-17.png">

In general, a C conditional typically creates a **diamond pattern** in the CFG

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-18.png">

### Loops

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-19.png">

The loop control for a C loop consists of a loop induction variable, an initialization, a condition, and an increment.

The induction varaible changes registers at the codee for the loop increment.

LLVM IR maintains the **static single assignment(SSA)** invariant: a register is defined by at most one instruction in a function. But what happens to the induction variable which changes as iteration goes or as the loop unfolds ? The answer is `phi` instruction.

The `phi` instruction speficies, for each predecessor `p` of a basic block `B`, the value of the destination register if control enters `B` via `P`.

<div class="md-flex-h md-flex-no-wrap">
<div><img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-20.png"></div>
<div class="md-margin-left-12"><img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-5-21.png"></div>
</div>

In this particular code, the `phi` instruction says, if the the code comes from `block6` which is the entry point the loop, then the reigster `%9` is going to be `0`. Otherwise, it is going to adpot the value `%14` which holds the incremental operation (`i+=1`).

- A block with **multiple incoming edges** may have `phi` instructions
- The `phi` instruction is not a real instruction. It won't appear in the assembly, it's just a trick for LLVM to represent loops.

### LLVM IR Attributes


## Resources

- [MIT 6.172](https://www.youtube.com/watch?v=wt7a5BOztuM&list=PLUl4u3cNGP63VIBQVWguXxZZi0566y7Wf&index=5)
- [LLVM IR](https://xta0.me/2015/10/08/Linkers-and-Loaders-LLVM-IR-1.html)
