---
layout: post
list_title: C++ | Templates & Generic Programming | 模板与泛型（二）
title: 模板与泛型（二）
categories: [C++]
---

## 模板实参的推断和引用

函数模板的形参可以为左值引用或者是右值引用，如果左值引用，又可分为普通的`T&`和`const T&`，其参数推断规则如下

### 左值引用参数推断

当一个函数参数是一个普通的左值引用时`T&`，其传递的实参只能是一个变量或者是一个返回引用类型的表达式。实参可以是`const`类型也可以不是，如果是`const`的，则`T`被推断为`const`类型

```cpp
template<typename T>
void f1(T& op); //实参必须是一个左值
f1(i); //i是一个int；T是int
f1(ci); //ci是一个const int,则T是const int
f1(5); //错误，5是一个右值
```
如果模板参数是`const T&`，则它可以接受任何类型的实参（`const`或非`const`的对象，临时变量和字面常量）。当实参是`const`类型时，`T`不会被推断为`const`类型，因为`const`已经是模板参数类型的一部分了


```cpp
template<typename T>
void f2(const T& op); //可以接受右值
//f2的模板参数是const T&, 实参的const是无效的
//在下面每个调用中，f2的参数都被推断为const int&
f1(i); //i是一个int；T是int
f1(ci); //ci是一个const int,则T是int
f1(5); //const T&可以绑定右值，T是int
```
### 右值引用参数推断和引用折叠

同理当一个模板参数声明为右值引用时，它将接受一个右值作为实参

```cpp
template<typename T>
void f3(T&&);
f3(42); //实参是一个int型右值，T是int
```

C++编译器对`T&&`做了一些特殊的设定，具体来说有两点，第一点是如果实参是一个左值，按照上面定义，它是不能直接绑定到右值引用(`T&&`)上的，但实际上却可以。假定`i`是一个`int`对象，当我们调用`f3(i)`时，编译器会推断`T`的类型为`int&`,而非`int`，此时`f3`接受的参数变成了一个左值引用的右值引用。通常，我们是不能定义一个引用的引用的，但是编译器为我们提供了第二条特殊设定，即如果我们间接创建了一个引用的引用，那么这些引用形成了**折叠**。在所有情况下（除了一个例外），引用会折叠成一个普通的左值引用。在新标准中，折叠也可产生一个右值引用，这种情况只能发生在右值引用的引用。即，对于一个给定类型`X`:

- `X& &`, `X& &&`和`X&& &`都折叠成`X&`
- `X&& &&`折叠成`X&&`

这两个规则导致下面几个的结论，对于`template<typename T> void f3(T&&)`这样的模板

- 如果传递的参数是左值，`T`推导的类型为`T&`，而`T& &&`会被折叠为`T&`，因此参数的实际类型为`T&`
- 如果传递的参数时左值引用，情况和上面一致
- 如果传递的参数是右值，`T`推导的类型为`T`，因此参数的实际类型为 `T&&`
- 如果传递的参数是右值引用，`T`推导的类型为 `T&&`，而`T&& &&`折叠成了`T&&`，因此参数的实际类型为`T&&`

`T&&` 的作用主要是保持值类别进行转发，它有个名字就叫“转发引用”（forwarding reference）。因为既可以是左值引用，也可以是右值引用，它也曾经被叫做“万能引用”（universal reference）。

### 理解`std::move`

我们可以通过`std::move`将一个左值绑定要一个右值引用上。由于`move`本质上可以接受任何类型的实参，因此推断它的实参为`T&&`

```cpp
template<class T>
constexpr remove_reference_t<T>::type&& move(T&& t) noexcept {
    return static_cast<typename remove_reference_t<T>::type&&>(t)
}
```
通过引用折叠，move即可以接受左值，也可以接受右值。我们分析两个例子

```cpp
string s1("hi!");
string s2 = std::move(string("bye!"));
```
对于`s1`

- 类型推断`T`为`string`
- `remove_reference`用`string`进行实例化，`remove_reference<string>::type`为`string`
- `move`返回值类型为`string&&`，`move`的参数类型为`string&&`

因此，`move`被实例化为

```cpp
string&& move(string&& t) {
    return static_cast<string&&>(t);
}
```
由于`t`自身就是`string&&`，因此`static_cast`什么都不做，直接返回`t`。

对于`s2`，`std::move`接收的是一个左值引用`string&`

- 类型推断`T`为`string&`
- `remove_reference`用`string&`进行实例化，`remove_reference<string&>::type`为`string`
- `move`返回值类型仍为`string&&`
- `move`的参数`t`实例化为`string& &&`，根据上面的规则，会折叠为`string&`

因此，`move`被实例化为

```cpp
string&& move(string& t) {
    return static_cast<string&&>(t);
}
```
由于此时`t`是`string&`，因此`static_cast`会将其cast成`string&&`。实际上，C++允许使用`static_cast`来转换一个左值到右值，例如下面代码是合法的

```cpp
int a = 10;
int&& b = static_cast<int&&>(a);
```

## 转发

某些函数需要将一个或者多个实参类型不变的转发给其它函数，不论是否是const，左值还是右值。C++提供了一个`std::forward`的函数来转发模板类型的参数，`std::forward`可以保持给定实参的左值/右值属性

```cpp
template<typename F, typename T1, typename T2>
void flip(F f, T1&& t1, T2&& t2) {
    f(std::forward<T2>(t2), std::forward<T1>(t1));
}
```
使用`std::forward`有两点需要注意

1. 传递的参数通常为`T&&`，即可以绑定到任意参数
2. 与`std::move`不同，`std::forward<T>`必须通过显式模板实参来调用



