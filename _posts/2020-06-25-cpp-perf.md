---
list_title: C++ Performance | Pass function arguments by value if they're small
title: Pass function arguments by value if they're small
layout: post
categories: ["C++"]
---

C++ Core Guideline中关于函数参数传递，有两条规则

1. [F.15](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#f15-prefer-simple-and-conventional-ways-of-passing-information): Refer simple and conventional ways of passing informaton
2. [F.16](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#f16-for-in-parameters-pass-cheaply-copied-types-by-value-and-others-by-reference-to-const): Pass cheaply-copied types by value and others by reference to const

接下来我们将以iOS平台为例，讨论一下这背后的原因。

### How argument passing works at the CPU level

C里面的函数调用通常由一系列instruction构成，这些instruction需要遵循各个平台的calling convention

1. 函数参数需要根据calling convention放到合适的地方。这样被调用的函数知道去哪里找
2. 函数的返回地址需要被放到某个位置，这样callee会将控制权返回给caller
3. control会指向function的第一条指令

在modern的CPU上，具体表现为

1. 一些pointer-sized函数参数会被放到某些特殊的寄存器中，其它比较大的参数放到stack上，他们在stack上的地址会被保存到寄存器中。当然，这里也会有例外，如果参数大小正好是2个pointer-size或者参数是floating-point的类型，它们同样也可以直接放到寄存器中。另外，可变参数的行为也不一样(`printf(const char*, ...)`)，这里不做展开
2. 汇编中会有类似于`call`这样的instruction用来Jump到目标函数，并且stash返回return address
3. 汇编中会有类似于`return`这样的命令跳转到上一步stash的函数地址，以便继续执行后面的指令

对于[iOS的ARM64 CPU](https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms#//apple_ref/doc/uid/TP40013702-SW1)来说

1. 编译器会尝试将函数的前8个参数放到通用64bit寄存器 `x0-x7`，或者`v0-v7`中(SIMD/floating-point registers)。Integer或者指针类型的参数会被放到`x0-x7`中，`float/double/long double`参数会被放到`v0-v7`中。对于比较大的(大于等于16 bytes)`struct`参数，它们会被copy到stack上，指向这份copy的pointer会被放到寄存器`x0-x7`中 (Note: this is easy to miss: it’s item B.3 in section 5.4.2 of “Procedure Call Standard for the ARM 64-bit Architecture”)。对于小的`struct`(小于16 bytes)，它们会被放到一个或者两个寄存器中。这里有一个例外，如果一个`struct`包涵小于4个float pointer，它也会被放到寄存器中。
2. `bl` (branch and link) 指令是一个函数调用，它会将control交给它后面参数，并将返回地址存到一个特殊的[link register](https://en.wikipedia.org/wiki/Link_register)中("LR")
3. `blr`指令用于函数返回，它将control交给LR寄存器中保存的值。

我们来看几个例子

```cpp
void intByValue(int x);
void intByPointer(const int *x);
void intByReference(const int &x);
void doSomething();  // avoid privileging the "right way" further
 
void callIntByValue() {
  int x = 123;
  intByValue(x);
  doSomething();
}
 
void callIntByPointer() {
  int x = 123;
  intByPointer(&x);
  doSomething();
}
 
void callIntByReference() {
  int x = 123;
  intByReference(x);
  doSomething();
}
```

接下来我们来对比下面代码所产生的汇编代码

<div class="md-flex-h md-margin-bottom-24">
<div>
<pre class="highlight language-python md-no-padding-v md-height-full">
<code class="language-cpp">
__Z14callIntByValuev:
	.cfi_startproc
; %bb.0:
	stp	x29, x30, [sp, #-16]!
	mov	x29, sp
	.cfi_def_cfa w29, 16
	.cfi_offset w30, -8
	.cfi_offset w29, -16
	mov	w0, #123
	bl	__Z10intByValuei
	ldp	x29, x30, [sp], #16
	b	__Z11doSomethingv
	.cfi_endproc      
	.globl	__Z16callIntByPointerv
	.p2align	2
</code>
</pre>
</div>
<div class="md-margin-left-12">
<pre class="highlight md-no-padding-v md-height-full">
<code class="language-python">
	.cfi_startproc
; %bb.0:
	sub	sp, sp, #32
	stp	x29, x30, [sp, #16]
	add	x29, sp, #16
	.cfi_def_cfa w29, 16
	.cfi_offset w30, -8
	.cfi_offset w29, -16
	mov	w8, #123
	stur	w8, [x29, #-4]
	sub	x0, x29, #4
	bl	__Z12intByPointerPKi
	bl	__Z11doSomethingv
	ldp	x29, x30, [sp, #16]
	add	sp, sp, #32
	ret
	.cfi_endproc
	.globl	__Z18callIntByReferencev
	.p2align	2
</code>
</pre>
</div>
</div>
