---
list_title: C++ Performance | Smart Pointer Parameters
title: Smart Pointer Parameters
layout: post
categories: ["C++"]
---

### Problem #1

下面的函数声明有哪些性能问题

```cpp
void f( shared_ptr<widget> w);
```

在回答这个问题前，我们先搞清楚`shared_ptr`是如何实现的

```cpp
struct shared_ptr_control_block {
    some_atomic_counter_type reference_count;
    // maybe other stuff....
};

template<typename T>
struct shared_ptr {
    T *data;
    shared_ptr_control_block *cntrl;
};
```
当一个`shared_ptr`被创建时，这个`shared_ptr_control_block`是会在heap上单独创建。`shared_ptr`的构造函数，copy构造和析构函数都需要维护这个refcount。为了在多线程的环境下能正确工作，refcount的bump是atomic的。和正常的increament, decrement相比，atomic的操作是非常expensive的，[uops.info](https://uops.info/table.html)的数据显示atomic increment的速度是non-atomic increment的5倍。如果多个线程同时bump refcount，性能的损失会非常大，因为原子操作无法在多线程中同时执行。

回到上面的问题, `w`作为参数会被触发`shared_ptr`的copy构造函数，进而会increment其refcount。当函数结束的时候，`w`会析构，进而decrement refcount。在多线程环境下，如果`f`调用频繁，refcount的bump会非常影响性能。

因此，`shared_ptr`作为参数传递要谨慎，我们需要尽可能少的copy它。有些时候callee只是使用`shared_ptr`而不需要take ownership的，因此这个时候可以用`const T&`, `T&`或者直接用raw pointer。比如下面例子中,`f`只是使用Widget，它并不需要接受一个`shared_ptr`，传一个引用即可。

```cpp
void f(const std::shared_ptr<Widget>& w) {
  w->foo();
}

void g() {
  auto p = std::make_shared<Widget>(/*...*/);
  f(p);
}
```
### Problem #2

承接上一个问题，假如我们有一个`widget`对象`w`，我们要将它传给`f`，我们应该如何传递`w`，考虑下面几种情况，并解释什么时候该用哪一种，以及什么时候该加上`const`

```cpp
void f( widget* w);              (a)
void f( widget& w);              (b)
void f( unique_ptr<widget> w);   (c)
void f( unique_ptr<widget>& w);  (d)
void f( shared_ptr<widget> w);   (e)
void f( shared_ptr<widget>& w);  (f)
```

对于(a)和(b)



## Resources

- [GotW #91 Solution: Smart Pointer Parameters](https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/)