---
list_title: Note | MIT 6.172 -  Assembly Lanugage and Computer Architecture
title: Assembly Lanugage and Computer Architecture
layout: post
mathjax: true
---

## The Four Stages of Compilation

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-4-1.png">

### Source Code to Assembly Code

Assembly language provies a convenient symbolic representation of machine code.

```c
int64_t fib(int64_t n){
    if(n < 2){
        return n;
    }
    return (fib(n-1) + fib(n-2));
}
```
We can do `clang -03 fib.c -S` to generate the assembly code, which gives the code like this

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-4-2.png">

From here, we assemble the assembly code to produce the binary. 

```shell
$clang fib.s -o -fib.o
```
Binary executable produced with debug symbols (compiled with `-g`) can be dumped using 

```shell

$objcdump -S fib
```

This will produce the disassembly of the machine code, which is more readable.

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-4-3.png">

### Why Assembly?

Why botter looking at the assembly of your program?

- The assembly reveals what the compiler did and did not do
- Bugs can arise at a low level. For example, a bug in the code might only have an effect when compiling with `-03`. Further more, sometimes, the compiler is the source of the bug!
- You can modify the assembly by hand, when all else fails.
- Reverse engineering: You can decipher what a program does when you only have access to its binary.

## X86-64 ISA Primer

The instruction set architecture (ISA) specifies the syntax and semenatics of assemebly, which includes Registers, Instructions, Data types and Memory addressing modes.

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-4-4.png">

There are a bunch of x86-64 registers

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-4-5.png">

- The Flags register keeps tracking of whether there is a overflow. Or whether the last operation returns 0, etc.
- The instruction pointer register 
- The SSE and AVX registers are recently added.These are vector register for SIMD instructions.

The x86-64 general-purpose registers are **aliased**: each has multiple names, which refer to overlapping bytes in the register.

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-4-6.png">

Here are all the general purpose regiesters

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-4-7.png">

Some of them are still useful for a particular purpose, such as `rsp` is used as stack pointer, and `rbp` is used to point to the base of the frame.

The x86-64 Instruction Format is

```shell
<opcode> <operand_list>
```

- `<opcode>` is a short mnemonic identifying the type of instruction
- `<operand_list>` is 0,1,2 or (rarely) 3 operands, seperated by commas.
- Typically, all oeprands are sources, and one operand might also be the destiniation.

```shell
#example
addl %edi, %ecx
```
What does `<op> A, B` mean? There are two syntax standards namely AT&T Syntax and Intel Syntax. In the AT&T syntax, the second operand is the destination, whereas in the Intel syntax, the first operand is the destination.

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-4-8.png">

The common x86-64 Opcodes

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/07/perf-4-9.png">

Note that, the substraction operation `subq %rax, %rbx` computes 

Opcodes might be augmented with a suffix that describes the data type of the operation or a condition code.

- An opcode for data movement, arithmetic or logic uses a single-char suffix to inidicate the data type
- If the suffix is missing, it can usually be inferred from the sizes of the operand registers.







