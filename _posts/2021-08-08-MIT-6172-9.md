---
list_title: Note | MIT 6.172 (9) - What Compilers can and cannot Do
title: What Compilers can and cannot Do
layout: post
mathjax: true
---

### Clang/LLVM Compilation Pipeline

This lecture completes more of the story from Lecture 5 about the compilation process

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/08/perf-09-01.png">

### Why study the compiler optimizations?

- Compiler can have a big impact on software performance
- Compilers can save you performance-engineering work.
- Compilers help ensure that simple, readable, and maintainable code is fast
- You can understand the differences between the source code and the IR or assembly
- Compilers can make mistakes
- Understanding compilers can help you use them more effectively.

### Simple Model of the Compiler

An optimizing compiler performs a sequence of transformation passes on the code

```shell
LLVM IR -> Transform -> Transform -> Transform -> ... -> Transform -> Optimized LLVM IR
```

- Each transofrmation pass analyzes and edits the code to try to optimize the code's performance
- A transformation pass might run multiple times
- Passes run in a predetermined order that seems to work well most of the time

### Compiler Reports

Clang/LLVM can produce **reports** for many of its transformation passes, not just vectorization:

- `-Rpass=<string>`: Produces reports of which optimizations matching `<string>` were successful.
- `-Rpass-missed<string>`: Produces reports of which optimizations matching `<string>` were not successful.
- `-Rpass-analysis=<string>`: Produces reports of the analyses performed by optimizations matching `<string>`

The argument `<string>` is a regular expression. To see the whole report, use ".*" as the string.

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2021/08/perf-09-02.png">

The good news: The compiler can tell you a lot about what's doing

- Many transformation passes in LLVM can report places where they successfully transform code.
- Many can also report the conclusions of their analysis.

The bad news: Reports can be hard to understand.

- The reports can be long and use LLVM jargon.
- Not all transformation passes generate reports.
- Reports don't always tell the whole story.

We want context for understanding these reports


### Compiler Optimizations 

- Data Structures
    - Register allocation
    - Memory to registers
    - Scalar replacement of aggregates
    - Alignment
- Loops
    - Vectorization
    - Unswitching
    - Idiom replacement
    - Loop fission
    - Loop skewing
    - Loop tiling
    - Loop interchange
- Logic
    - Elimination of redundant
    - Memory to registers
    - Strength reduction
    - Dead-code elimination
    - Idiom replacement
    - Branch reordering
    - Global value numbering
- Functions
    - Unswitching
    - Argument elimination

### Arithmetic Opt’s: C vs. LLVM IR

Most compiler optimizations happen on the compiler’s intermediate representation (IR), although not all of them. 

Let's say `n` is a `uint32_t` integer. We can compare the C code with LLVM IR and assembly

<div class="highlight md-flex-h md-margin-bottom-24">
<div>
<pre class="highlight language-cpp md-no-padding-v md-height-full">
<code class="language-cpp">
uint32_t x = n + 8;
uint32_t y = n * 8;
uint32_t z = n / 8;
</code>
</pre>
</div>

<div class="md-margin-left-12">
<pre class="highlight language-cpp md-no-padding-v md-height-full">
<code class="language-cpp">
add i32 %6, 8
%9 = mul i32 %8, 15
%11 = udiv i32 %10, 71
</code>
</pre>
</div>

<div class="md-margin-left-12">
<pre class="highlight language-cpp md-no-padding-v md-height-full">
<code class="language-cpp">
%2 = shl nsw i32 %0, 3
%3 = mul nsw i32 %0, 15
%4 = udiv i32 %0, 71
</code>
</pre>
</div>

<div class="md-margin-left-12">
<pre class="highlight language-cpp md-no-padding-v md-height-full">
<code class="language-cpp">
leal (,%rdi, 8), %eax

leal (%rdi, %rdi, 4), %eax
leal (%rdi, %rdi, 2), %eax

movl %edi, %eax
movl $3871519817, %ecx
imulq %rax, %rcx 
shrq $38, %rcx
</code>
</pre>
</div>
</div>


## Resoources

- [Perforamnce Engineering of Software Systems](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-172-performance-engineering-of-software-systems-fall-2018/index.htm)