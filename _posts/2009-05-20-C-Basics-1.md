---
layout: post
title: C程序的编译
list_title: C Part 1 | C程序的编译
categories: [C]
---

本节我们来讨论下一个简单的C程序的编译，我们将把重点放在目标文件的链接和加载上。

一般来说，源文件编译完成后会生成`.o`文件，多个`.o`文件和一些lib，一起link得到可执行文件，下面是GCC的一些常用编译选项，我们稍后会用到：

- `-c`: 用来生成`.o`文件
- `-o` : 用来创建目标文件
- `-g`: 编译器在输出文件中包含debug信息，产生dSYM符号表
- `-Wall`:编译器编译时打出warning信息,强烈推荐使用这个选项。
- `-I+dir`: 除了在main.c当前目录和系统默认目录中寻找.h外，还在dir目录寻找，注意，dir是一个绝对路径。
- `-01,-02,-03`: 编译器优化程度

现在假设我们有三个文件:`function.h`,`function.m`和`main.c`，代码如下

```c
//function.h
#define FIRST_OPTION
#ifdef FIRST_OPTION
#define MULTIPLIER (3.0)
#else
#define MULTIPLIER (2.0)
#endif

float add_and_multiply(float x, float y);

//function.c
#include "function.h"

int nCompletionStatus = 0;
float add(float x, float y) {
    float z = x+y;
    return z;
}
float add_and_multiply(float x, float y){
    float z = add(x,y);
    z *= MULTIPLIER;
    return z;
}

//main.c
#include "function.h"

extern int nCompletionStatus = 0;
int main() {
    float x = 1.0;
    float y = 1.5;
    float z;

    z = add_and_multiply(x,y);
    nCompletionStatus = 1;
    return 0;
}
```
为了生成目标文件`.o`，我们可以使用gcc来进行编译，我们先来要编译`main.c`，得到`main.o`: `gcc -c main.c -o main.o`。该文件包含了很多重要的信息

1. 可以将`.o`理解为所有symbol的集合，可以用`nm`命令查看其包含的symbol

    ```
                     U _add_and_multiply
    0000000000000000 T _main
    00000000000000b8 S _nCompletionStatus
    ```
    这些symbol的类型可以在文末的附录中查询。值得注意的是，`_add_and_multiply`的symbol类型为`U`，意味着这个符号的定义并不在`main.o`中，因此在单独编译`main.c`时，编译器并不知道这个符号具体在哪里

2. 除了包含基本的符号信息外，`.o`还包含了section的信息，关于section将在后面跟linking的阶段做详细讨论。需要注意的是，`.o`并不包含符号在内存中的真实地址，地址绑定将在linking的阶段完成。但是每个section的长度和其address range却是`.o`中很重要的一条信息，linking需要依靠这个信息做符号的定位

尽管我们可以使用gcc为每个文件生成单独的目标文件，但是如何把这些目标文件组织到一起还有许多问题要解决，比如

1. 当`main.o`调用`add_and_multiply`函数时，程序该去哪里寻找这个函数呢？
2. `extern`声明的全局变量`_nCompletionStatus`在被使用时，该去哪里寻找呢?

因此链接器要做的事情就是将这些目标文件打包成一个可执行文件，这个打包的过程分几个步骤，我们先从Relocation说起。

### Relocation

Relocation的任务很简单，就是将所有目标文件的各个section按照规则进行合并，进而产生一个全新的memory map。这个过程虽然好理解，但有些细节需要注意，比如符号地址的重新分配。

由于虚拟内存的存在，对于每个`.o`文件中的符号，它们不需要考虑自己在真实的内存中的绝对地址（memory map中的地址），它们的地址都是相对的，比如`main.o`中，`_main`符号的地址为`0x0000000000000000`，`function.o`中`_add`地址也为`0x0000000000000000`。显然，在实际的内存中`_add`的地址是无论如何不可能为`0x0000000000000000`的。这时候就需要Relocation发挥作用，将所有symbol的地址重新分配到合理的位置。但需要注意的是，所有的这些重新分配都是基于section的，因此linker是需要知道目标文件中每个section的大小和范围的。

<img class="md-img-center" src="{{site.baseurl}}/assets/images/2009/05/c-compiler-1.png">


### A GCC Demo

```
//文件路径

./test/main.c , main.h  ,  module_1.h  ,  module_1.c  
./test/ext/module_2.h  ,  module_2.c

//main.h
#include <stdio.h>;
int main(void);

//main.m
#include "main.h" 
#include "module_1.h"
#include "module_2.h"

int main(void){}
```
- 单行名命令
    - `gcc -o output main.c module_1.c ./ext/module_2.c -I./ext`
- 分步执行，先各自编译成.o，再link
    1. <code> gcc -c module_1.c </code>生成module_1.o
    2. <code> cd ./ext	% gcc -c module_2.c </code>生成module_2.o
    3. <code> gcc -c main.c -I./ext </code>生成main.o
    4. <code> gcc -o p main.o module_1.o ./ext/module_2.o </code>生成output


## 附录

### `NM`命令

> 注意，`nm`命令不会列出DLL的entry point，除非有和它关联的符号表。

```
- A :absolute symbol, global
- a :absolute symbol, local
- B :uninitialized data (bss), global
- b :uninitialized data (bss), local
- D :initialized data, global
- d :initialized data, local
- F :file name
- l :line number entry (see -a option)
- N :no defined type, global; this is an unspecified type, compared to the undefined type U
- n :no defined type, local; this is an unspecified type, compared to the undefined type U
- S :section symbol, global
- s :section symbol, local
- T :text symbol, global
- t :text symbol, local (static)
- U :undefined symbol
- ? :unknown symbol
```