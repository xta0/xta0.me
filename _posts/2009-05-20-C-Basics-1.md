---
layout: post
title: C程序的编译
list_title: C Part 1 | C程序的编译
categories: [C]
---

本节我们来讨论下一个简单的C程序的编译，我们将把重点放在目标文件的链接和加载上。

一般来说，源文件编译完成后会生成`.o`文件，多个`.o`文件和一些lib，一起link得到可执行文件，下面是GCC的一些常用编译选项，我们稍后会用到：

- `-c`: 用来生成`.o`文件
- `-o` : 用来创建目标文件
- `-g`: 编译器在输出文件中包含debug信息，产生dSYM符号表
- `-Wall`:编译器编译时打出warning信息,强烈推荐使用这个选项。
- `-I+dir`: 除了在main.c当前目录和系统默认目录中寻找.h外，还在dir目录寻找，注意，dir是一个绝对路径。
- `-01,-02,-03`: 编译器优化程度

现在假设我们有三个文件:`function.h`,`function.m`和`main.c`，代码如下

```c
//function.h
#define FIRST_OPTION
#ifdef FIRST_OPTION
#define MULTIPLIER (3.0)
#else
#define MULTIPLIER (2.0)
#endif

float add_and_multiply(float x, float y);

//function.c
#include "function.h"

int nCompletionStatus = 0;
float add(float x, float y) {
    float z = x+y;
    return z;
}
float add_and_multiply(float x, float y){
    float z = add(x,y);
    z *= MULTIPLIER;
    return z;
}

//main.c
#include "function.h"

extern int nCompletionStatus = 0;
int main() {
    float x = 1.0;
    float y = 1.5;
    float z;

    z = add_and_multiply(x,y);
    nCompletionStatus = 1;
    return 0;
}
```
为了生成目标文件`.o`，我们可以使用gcc来进行编译，我们先来要编译`main.c`，得到`main.o`: `gcc -c main.c -o main.o`。该文件包含了很多重要的信息

1. 可以将`.o`理解为所有symbol的集合，可以用`nm`命令查看其包含的symbol

    ```
                     U _add_and_multiply
    0000000000000000 T _main
    00000000000000b8 S _nCompletionStatus
    ```
    这些symbol的类型可以在文末的附录中查询。值得注意的是，`_add_and_multiply`的symbol类型为`U`，意味着这个符号的定义并不在`main.o`中，因此在单独编译`main.c`时，编译器并不知道这个符号具体在哪里

2. 除了包含基本的符号信息外，`.o`还包含了section的信息，关于section将在后面跟linking的阶段做详细讨论。需要注意的是，`.o`并不包含符号在内存中的真实地址，地址绑定将在linking的阶段完成。但是每个section的长度和其address range却是`.o`中很重要的一条信息，linking需要依靠这个信息做符号的定位

### Linking


### 常用GCC编译参数

- `gcc`：直接执行`gcc  main.c` 会得到 一个 `a.out`的可执行二进制文件。运行时需要带路径：`./a.out`


### A GCC Demo

```
//文件路径

./test/main.c , main.h  ,  module_1.h  ,  module_1.c  
./test/ext/module_2.h  ,  module_2.c

//main.h
#include <stdio.h>;
int main(void);

//main.m
#include "main.h" 
#include "module_1.h"
#include "module_2.h"

int main(void){}
```
- 单行名命令
    - `gcc -o output main.c module_1.c ./ext/module_2.c -I./ext`
- 分步执行，先各自编译成.o，再link
    1. <code> gcc -c module_1.c </code>生成module_1.o
    2. <code> cd ./ext	% gcc -c module_2.c </code>生成module_2.o
    3. <code> gcc -c main.c -I./ext </code>生成main.o
    4. <code> gcc -o p main.o module_1.o ./ext/module_2.o </code>生成output

### `NM`查看Symbol

- `nm`用来查看目标文件中的符号，命令格式:`nm[-AaefgnoPprsuvx][-t format]`目标文件包括：
	- `.obj`结尾的文件，可能是Object Module Format格式或者是Common Object File Format格式
	- `.lib`结尾文件，包含一个或多个`.obj`文件
	- Windows可执行文件`.exe`
	- 注意，`nm`命令不会列出DLL的entry point，除非有和它关联的符号表。

- 默认情况，`nm`列出按照字母顺序列出符号类型:

```
- A :absolute symbol, global
- a :absolute symbol, local
- B :uninitialized data (bss), global
- b :uninitialized data (bss), local
- D :initialized data, global
- d :initialized data, local
- F :file name
- l :line number entry (see -a option)
- N :no defined type, global; this is an unspecified type, compared to the undefined type U
- n :no defined type, local; this is an unspecified type, compared to the undefined type U
- S :section symbol, global
- s :section symbol, local
- T :text symbol, global
- t :text symbol, local (static)
- U :undefined symbol
- ? :unknown symbol
```