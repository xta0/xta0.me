---
layout: post
list_title: Python Tips& Tricks Part 2
title: Python拾遗
categories: [Python]
---

### Functions Arguments

如果一个函数的positional arg定义了default value，那么它后面的参数都需要定义default value

```python
def my_func(a, b=6, c=10):
    # code..
```
如果我们只想指定`a`和`c`，则需要用到keyword arguments

```python
my_func(a=1, c=2)
```
需要注意，如果某个参数使用了keyword argument，它后的参数必须也指定名字

```python
def my_func(a, b, c)
my_func(c=1, 2, 3) # wrong
my_func(1, b=2, 3) # wrong
my_func(1, b=2, c=3) # corret
my_func(1, c=2, b=3) # corret
```

使用默认参数有一些需要注意的地方，他们在函数创建时就是求值，比如

```python
def log(s, dt=datetime.utcnow()):
    #code

log('hello')
```
此时，如果我们不传入`date`，那么`date`的时间将永远是函数创建的时间，而不是函数调用的时间。解决这个问题，可以将默认参数生命为`None`

```python
def log(s, dt=None):
    dt = dt or datetime.utcnow()
    # code
```

另一个需要注意的地方是尽量不要用mutable的数据结构，比如

```python
args = [1,2,3]
def my_func(list = args)
    print(args)

args.append(4)
my_func()
```
此时函数的默认值`list`会被mutate，导致结果不符合预期。和上面例子类似的另一个例子是空数组做默认值

```python
def add(name, name_list=[]):
    name_list.add(name)
    return name_list

l1 = add('jon')
l2 = add('kate')
```
上述代码中，`l1`和`l2`指向的实际上是同一个数组，因此`l1`和`l2`中的内容是一样的，当第二次调用`add`的时候，`name_list`已经不是空的了。解决办法和上面一样


```python
def add(name, name_list=None):
    if not name_list:
        name_list = []
    name_list.add(name)
    return name_list
```


### Pack与Unpack

所谓Packed Values是指一些值以某种方式被pack到一起，最常见的有tuple, list, string, set, 和map这些集合类。对于这些集合类，Python提供了一种展开的方式，即将集合类中的元素以tuple的形式展开

```python
a,b,c = [1,2,3] #a->1, b->2, c->3
a,b,c = 10,20,'hello' #a->10, b->20, c->hello
a,b,c = 10, {1,2}, ['a','b'] #a->10, b->{1,2}, c->['a','b']
a,b,c = 'xyz' #a->x, b->y, c->z
```
上述代码中，等号左边定义了一个tuple，右边是一个集合对象，unpacking的方式是按照位置一一对应。看起来所谓unpacking，实际上就是对集合类对象进行`for`循环为变量依次赋值。

但是对于哈希表，`for`循环只得到`key`，因此unpacking的结果也是key，且由于哈希表是无序的，unpacking出来的结果也是不确定的，对于set同理。

```python
# unpacking a map object
d = {'key1':1, 'key2':2, 'key3':3}
a,b,c = d #a->'key2' b->'key3', c='key1'

# unpacking a set object
s = {'x','y','z'}
a,b,c = s #a->'z' b->'x', c='y'
```

在Python中，unpacking对于实现swap功能很方便，只需要unpack一次即可

```python
#swap a,b
a,b = b,a
```
上面代码的执行顺序是先进行RHS求值，然后将得到的值再进行LHS赋值给`a,b`。

### 使用`*`和`**`进行unpack

在Python 3.5后，可使用`*`做局部的unpack，比如一个集合，我只想unpack第一个元素，然后将剩下部分unpack给另一个变量

```python
l = [1,2,3,4,5,6]

#using slicing
a = l[0]
b = l[1:]

#using simple unpacking
a,b = l[0]:l[1:]

#using * operator
a, *b = l
```
slicing只适用于数组，而`*`可适用于任何iterable的集合变量，对于有序集合，`*` unpack的结果为为数组

```python
a, *b = (1,2,3) #a = 1, b = [2,3]
a, *b = "abc" #a = 'a', b = ['b','c']  
a, *b, c = 1,2,3,4 #a = 1, b = [2,3], c = 4
```

对于无序集合，比如dict和set，unpack的结果是无序的

```python
d1 = {'p':1, 'y':2}
d2 = {'t':3, 'h':4}
d3 = {'o':5, 'n':6}

d = [*d1, *d2, *d3] # unpack key
```
对于dict来说，`*` 只能unpack key，如果想要unpack pair，需要用`**`，但是只能用在等号右边

```python
d = {**d1, **d2, **d3}
x = {'a':5, 'b':6, **d1}
```

### `*args` and `*kwargs`

`*args`可以unpack 任意多个positional arguments，如果作为函数参数，则它后面不能再有其它的positional args

```python
def func1(a,b,c):
    #code

l = [10, 20 ,30]
func(l) # wrong, func1 expects three positional args
func(*l) # works

def func2(a, b, *args, d):
    # code

func2(10, 20, 'a', 'b', 100) #wrong
```
前面提到，我们也可以用keyword argument来给函数传参

```python
func1(a=1, c=2, b=3)
```
如果想要强制用keyword argument传参，那么keyword argument需要定义在`*args`的后面，并且调用时必须传入

```python
def func1(a,b,*args, d):
    # code
func1(1, 2, 'x', 'y',d = 100) # correct
func1(1, 2, d = 100) # correct
func1(1, 2) # wrong d must be assigned
```
如果在keyword argument之前不需要任何positional arguments，则可以用`*`代替

```python
def func(*, d): 
    # code 
func(1, 2, d=100) # wrong
func(d = 100) #correct
```
`*`说明`d`前面没有任何的positional argument，注意这个和`*args`不同，后者表示有任意多个positional arg

和`*args`类似，`**kwargs`可以指定任意数量的keyword arguments，但是`**kwargs`后面不能再定义参数

```python
def func(*, d, **kwrags):
    # code
func(d=1, a=2, b=3)
func(d=1)
```
上面例子中，`*`表示函数不接受任何positional arguments，`d`是一个keyword-only argument

---
list_title: Python | Gotchas | 常见的mistakes
title: Python Gotchas
layout: post
categories: ["Python"]
---

### 解释器的差别

看下面代码，你觉得那个是正确的呢？还是都不正确或者都正确呢？

<div class="highlight md-flex-h md-margin-bottom-24">
<div>
<pre class="highlight language-javascript md-no-padding-v md-height-full">
<code class="language-python">
#Javascript
function func1(){
	return func2();
}

func1();

function func2(){
	return "running func2";
}
</code>
</pre>
</div>
<div class="md-margin-left-12">
<pre class="highlight language-python md-no-padding-v md-height-full">
<code class="language-python">
#python
def func1():
    return func2() 

func1()

def func2():
    return "running func2"
</code>
</pre>
</div>
</div>

上面的两段代码，Javascript代码可以正常执行，Python代码则报错。错误的原因是:

```
NameError: name 'func2' is not defined
```

从这个例子可以看出，Python的解释器的设计和Javascript似乎有些区别。在分析具体原因之前，先来回顾一下[编程语言的原理](2014/04/24/Programming-Language-1-1.html)，对于任何一条表达式，编译器都需要确定三个问题

1. Syntax
2. Type-Checking Rules
3. Evaluation Rules

对于Function来说，在编译器确定完其类型后便将这个符号（函数名或者是按照某种规则mangle后的名字）放入了static environment中，留着运行时调用。而函数的Evaluation的规则是在运行时求值，对函数内部的符号是从static environment中寻找，找不到则报错。上面例子中，在执行`func1()`时，Python和JS均会在static environment中寻找`func2`，显然一个找到了，另一个没找到，因此，分歧可能出在`func2`这个符号注册的时机上。

接下来，我们可以大致分析一下JS和Python的解释器是怎么工作的。对于JS来说，在执行前代码前，对所代码从头至尾进行扫描，如果出现static environment中没有的符号，则向其内部注册该符号，并赋初值undefined（这个特性据说叫做Hoisting）。注意在static environment中并不会对符号求值，求值的过程在dynamic environment中。而python的解释器似乎不会提前在static environment中注册所有符号，而是在运行时不断更新static enviroment中的符号, 并在dynamic environment中对其求值，当然如果发现没该有符号，则会在求值的过程中报错。

哪种设计合理呢？感觉Python解释器的设计更合理一些，JS在执行前要扫描并注册所有符号，其效率显然不如逐句解释来的快，并且一般有良好变成素养的程序员也不会写出上面的代码。

### Lists vs Tuples

我们可以先对比一下List和Tuple的bytecode

```shell
# compile tuple
dis(compile('(1, 2, 3, "a")', 'string', 'eval'))

0 LOAD_CONST      0 ((1, 2, 3, 'a'))
2 RETURN_VALUE

# compile list
dis(compile('[1, 2, 3, "a"]', 'string', 'eval'))

0 LOAD_CONST               0 (1)
2 LOAD_CONST               1 (2)
4 LOAD_CONST               2 (3)
6 LOAD_CONST               3 ('a')
8 BUILD_LIST               4
10 RETURN_VALUE
```

上面例子中，无论是tuple还是list，他们包含的是immutbale的data，我们可以发现，bytecode中tuple是一个constant，可以直接load，
而list需要通过更多的指令去动态创建。这是因为tuple本身是Immutable的数据结构。但是，如果tuple中包含mutable的数据结构，则tuple的创建将变的和list一样

```python
dis(compile('([1, 2], 3, "a")', 'string', 'eval'))

0 LOAD_CONST               0 (1)
2 LOAD_CONST               1 (2)
4 BUILD_LIST               2
6 LOAD_CONST               2 (3)
8 LOAD_CONST               3 ('a')
10 BUILD_TUPLE             3
12 RETURN_VALUE
```
此外，由于list的动态性，它需要preallocate space，因此它比tuple在内存上有更大的overhead

```python
import sys
s1 = sys.getsizeof((1,)) #48
s2 = sys.getsizeof([1,]) #64
```

### Shallow Copy vs Deep Copy

Python中有很多方法来copy一个list

```python
s = [1,2,3]

#1. for loop
cp = [e for e in s]

#2. copy()
cp = s.copy()

#3. slicing
cp = s[:]
cp = s[0:len(s)]

#4. list()
cp = list(s)
```
需要注意的是这里copy全是shallow copy，即`cp`是一个新的list，但是里面的元素还是指向原来list中的元素，即

```python
id(s) != id(cp)
```
对于immutable的sequence，如tuple，copy则不会创建新的对象

```python
t1 = (1, 2, 3)
t2 = tuple(t1)
id(t1) == id(t2)
```
Shallow copy的一个问题是，如果mutate原来的list中存在mutable的object，则同样会一向copy后list中的元素

```python
s1 = [[10, 20], 3, 4]
s2 = s1.copy()
s1[0][0] = 100 # s1 = [[100, 20], 3, 4]
# s2[0][0] will also be mutated
```
此时我们需要使用deep copy，但是实现deep copy是一件不容易的事情，比如一个list中有sublist，sublist中又有sublist，因此deep copy需要考虑递归的情况。对于标准库存中的sequence，Python提供`.deepcopy()`的API来实现deep copy

```python
import copy
x = [1, 2, 3]
y = copy.deepcopy(x)
```

### Mutable objects

如果concat两个包含mutable object的list，则结果

```python
x = [[1, 2]]
y = x + x
# y -> [[1, 2],[1, 2]] 
x[0] = [-1, -1]
# y -> [[-1, -1], [-1, -1]] 
```
实际上 `id(y[0]) == id (y0[1]) == id(x)`


### Generator

Generator是Python中协程的实现

```python
def gen_cube(n):
    for x in range(n):
        yield x**3
#返回generator object        
gen_cube(4) #<generator object gen_cube at 0x10567b150>
#pull value from gen_cube
list(gen_cube(4)) #[0, 1, 8, 27]

def gen_fib(n):
    a = 1
    b = 1
    for i in n:
        yield a
        a,b = b,a+b
for number in gen_fib(10):
    print(number)

def simple_gen():
    for i in range(3):
        yield i
g = simple_gen()
next(g) #0
next(g) #1
next(g) #2

s = "hello"
next(iter(s))
```

### Async/Wait

Python 3.7引入了`asyncio`这个module，`async`修饰的函数为一个coroutine对象，

### Regular Expression

- 正则表达式字符串以`r"regex"`表示

```py
# List of patterns to search for
patterns = [ 'term1', 'term2' ]
# Text to parse
text = 'This is a string with term1, but it does not have the other term.'
result1 = re.search(patterns[0],text)
result2 = re.search(patterns[1],text)
print(result1)#<_sre.SRE_Match object; span=(22, 27), match='term1'> None
print(result2) #none
result1.start() #22
result1.end() #27

##split
split_term = "@"
phrase = "jayson.xu@foxmail.com"
list1 = re.split(split_term, phrase)
print(list1) #['jayson.xu', 'foxmail.com
```

- 匹配字符的几种方式
    1.  以`*`结尾，表示被匹配的字符出现0次或者多次
    2.  以`+`结尾，表示被匹配的字符至少出现1次
    3.  以`?`结尾，表示被匹配的字符出现0次或者1次
    4.  以`{m}`结尾，表示被匹配的字符出现m次
    5.  以`{m,n}`结尾，表示被匹配的字符出现[m,n]次
    6.  以`[mn..]`结尾，表示被匹配的字符是m或者n或者...

```python
import re

test_phrase = 'sdsd..sssddd...sdddsddd...dsds...dsssss...sdddd'
test_patterns = [ 'sd*',     # s followed by zero or more d's
                'sd+',          # s followed by one or more d's
                'sd?',          # s followed by zero or one d's
                'sd{3}',        # s followed by three d's
                'sd{2,3}',      # s followed by two to three d's
                '[sd]',          #either s or d
                's[sd]+'        #s followed by one or more s or d
                ]
# ['sd', 'sd', 's', 's', 'sddd', 'sddd', 'sddd', 'sd', 's', 's', 's', 's', 's', 's', 'sdddd']                            
print(re.findall(test_patterns[0],test_phrase))
# ['sd', 'sd', 'sddd', 'sddd', 'sddd', 'sd', 'sdddd']
print(re.findall(test_patterns[1],test_phrase))
#['sd', 'sd', 's', 's', 'sd', 'sd', 'sd', 'sd', 's', 's', 's', 's', 's', 's', 'sd']
print(re.findall(test_patterns[2],test_phrase))
#['sddd', 'sddd', 'sddd', 'sddd']
print(re.findall(test_patterns[3],test_phrase))
#['sddd', 'sddd', 'sddd', 'sddd']
print(re.findall(test_patterns[4],test_phrase))
```    

- <mark>过滤</mark>某些字符
    - `[^...]`会匹配文本中不在`[]`中的字符

```python
test_phrase = 'This is a string! But it has punctuation. How can we remove it?'
re.findall('[^!.? ]+',test_phrase)
```

- 匹配<mark>英文字符</mark>

```python
test_phrase = 'This is an example sentence. Lets see if we can find some letters.'

test_patterns=[ '[a-z]+',      # sequences of lower case letters
                '[A-Z]+',      # sequences of upper case letters
                '[a-zA-Z]+',   # sequences of lower or upper case letters
                '[A-Z][a-z]+'] # one upper case letter followed by lower case letters
```
- <mark>匹配特殊字符</mark>


Code |Meaning
---|---
`\d` | a digit
`\D` | a non-digit
`\s` | whitespace (tab, space, newline, etc.)
`\S` | non-whitespace
`\w` | alphanumeric
`\W` | non-alphanumeric

```python
test_phrase = 'This is a string with some numbers 1233 and a symbol #hashtag'

test_patterns=[ r'\d+', # sequence of digits
                r'\D+', # sequence of non-digits
                r'\s+', # sequence of whitespace
                r'\S+', # sequence of non-whitespace
                r'\w+', # alphanumeric characters
                r'\W+', # non-alphanumeric
                ]
#['1233']
print(re.findall(test_patterns[0],test_phrase))
#['This is a string with some numbers ', ' and a symbol #hashtag']
print(re.findall(test_patterns[1],test_phrase))
#[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']
print(re.findall(test_patterns[2],test_phrase))
#['This', 'is', 'a', 'string', 'with', 'some', 'numbers', '1233', 'and', 'a', 'symbol', '#hashtag']
print(re.findall(test_patterns[3],test_phrase))
#['This', 'is', 'a', 'string', 'with', 'some', 'numbers', '1233', 'and', 'a', 'symbol', 'hashtag']
print(re.findall(test_patterns[4],test_phrase))
#[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' #']
print(re.findall(test_patterns[5],test_phrase))
```
### StringIO

StringIO提供了一个在内存中读写字符串的方式，通过string构建StringIO对象来进行IO操作，可以像操作文件一样操作string

```python
from io import StringIO
# Arbitrary String
message = 'This is just a normal string.'
# Use StringIO method to set as file object
f = StringIO(message)
str = f.read() #'This is just a normal string.'
f.write(' Second line written to file like object')
# Reset cursor just like you would a file
f.seek(0)
# Read again
str = f.read() #Second line written to file like object
```

## STL Module

类似C++的STL

### Counter

返回集合中元素的出现次数

```python
from collections import Counter

#统计元素出现次数
l = [1,1,1,3,3,3,4,2,2]
Counter(1) #Counter({1: 3, 3: 3, 2: 2, 4: 1})
s = 'asssvavaasvsbsa'
Counter(s) #Counter({'s': 6, 'a': 5, 'v': 3, 'b': 1})
ss = 'How How test is is gonna gonna work work work out'
words = ss.split(' ')
c = Counter(words) #Counter({'work': 3, 'How': 2, 'is': 2, 'gonna': 2, 'test': 1, 'out': 1})
c.most_common(2) 
```
其它成员函数

```python
sum(c.values())                 # total of all counts
c.clear()                       # reset all counts
list(c)                         # list unique elements
set(c)                          # convert to a set
dict(c)                         # convert to a regular dictionary
c.items()                       # convert to a list of (elem, cnt) pairs
Counter(dict(list_of_pairs))    # convert from a list of (elem, cnt) pairs
c.most_common()[:-n-1:-1]       # n least common elements
c += Counter()                  # remove zero and negative counts
```

### Default Dict

更安全的dictionary，对于访问不存在的key，不会报错

```python
from collections import defaultdict
d = defaultdict(object)
d['one'] #访问一个不存在的key，返回一个<object object at 0x105424110>

#自定义默认value
d = defaultdict(lambda: 0) #对于不存在的key，返回value = 0
d['one'] #0
```

### Ordered Dict

有序字典

```python
from collections import OrderedDict
d = OrderedDict()
d['a'] = 1
d['b'] = 2
d['c'] = 3
d['d'] = 4
for k,v in d.items():
    print(k,v) #顺序输出

##比较
d1 = {"a":1,"b":2}
d2 = {"b":2,"a":1}
d1 == d2 #True

d1 = OrderedDict()
d1['a'] = 1
d1['b'] = 2
d2 = OrderedDict()
d2['b'] = 2
d2['a'] = 1
d1 == d2 #False
```

### Named Tuple

可以用名字去索引的tuple

```python
from collections import namedtuple
Dog = namedtuple('Dog','age breed name')
sam = Dog(age=2, breed='Lab', name='Sammy')
sam.age
sam.breed
sam.name
```
### Datetime 

```python
import datetime
t = datetime.time(5,25,1) #时，分，秒
print(t) #05:25:01
print(datetime.time.min) #00:00:00
print(datetime.time.max) #23:59:59.999999
print(datetime.time.resolution) #0:00:00.000001

today = datetime.date.today()
today.timetuple()

d1 = datetime.date(2015,3,11)
print(d1)
d2 = d1.replace(year=1990)
```

## Python Debugger

- 使用`pdb`打断点

```python
import pdb

x = 1
y = [12,2,3]
z = 10
r1 = x+z
pdb.set_trace() #断点调试, q退出
r2 = y+z
```

- 使用`timeit`计算代码执行时间

```py
import timeit
#将待测试代码执行1000次
timeit.timeit('"-".join(str(n) for n in range(100))', number=1000)#0.034958536038175225
```