I"}<blockquote>
  <p>持续更新，补充C++新增feature,目录结构遵循《C++ Primer》</p>
</blockquote>

<ul>
  <li>普通的运算符只能用于基本数据类型</li>
  <li>对抽象的数据类型也能使用C++提供的数据类型
    <ul>
      <li>代码更简洁</li>
      <li>代码更容易理解</li>
    </ul>
  </li>
  <li>运算符重载的实质是<strong>函数重载</strong>，形式为：</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>返回值类型 operator 运算符（形参表）{}
</code></pre></div></div>

<ul>
  <li>在程序编译时：
    <ul>
      <li>把运算符的表达式 -&gt; 对运算符函数的调用</li>
      <li>把运算符的操作数 -&gt; 运算符函数的参数</li>
      <li>运算符多次被重载时，根据实参类型决定调用哪个运算符函数</li>
    </ul>
  </li>
  <li>运算符可以被重载成<strong>普通函数</strong>
    <ul>
      <li>参数个数为运算符的目数（如<code class="highlighter-rouge">+</code>为二元运算符，因此参数个数为2）</li>
    </ul>

    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">Complex</span>
  <span class="p">{</span>
      <span class="nl">public:</span>
          <span class="n">Complex</span><span class="p">(</span><span class="kt">double</span> <span class="n">r</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">i</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">real</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
              <span class="n">image</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
          <span class="p">}</span>		
      <span class="kt">double</span> <span class="n">real</span><span class="p">;</span>
      <span class="kt">double</span> <span class="n">image</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="c1">//普通的全局函数</span>
  <span class="n">Complex</span> <span class="k">operator</span><span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">){</span>
      <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">real</span><span class="o">+</span><span class="n">b</span><span class="p">.</span><span class="n">real</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">image</span><span class="o">+</span><span class="n">b</span><span class="p">.</span><span class="n">image</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>也可以被重载成类的<strong>成员函数</strong>
    <ul>
      <li>参数个数为运算符目数减一</li>
    </ul>

    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">Complex</span>
  <span class="p">{</span>
      <span class="nl">public:</span>
          <span class="n">Complex</span><span class="p">(</span><span class="kt">double</span> <span class="n">r</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">i</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">real</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
              <span class="n">image</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
          <span class="p">}</span>		
          <span class="n">Complex</span> <span class="k">operator</span><span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="p">);</span>
          <span class="n">Complex</span> <span class="k">operator</span><span class="o">-</span> <span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="p">);</span>
      <span class="nl">private:</span>
          <span class="kt">double</span> <span class="n">real</span><span class="p">;</span>
          <span class="kt">double</span> <span class="n">image</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="n">Complex</span> <span class="n">Complex</span><span class="o">::</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">op</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">real</span><span class="o">+</span><span class="n">op</span><span class="p">.</span><span class="n">real</span><span class="p">,</span><span class="n">image</span><span class="o">+</span><span class="n">op</span><span class="p">.</span><span class="n">image</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="n">Complex</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">(</span><span class="mf">4.3</span><span class="p">,</span><span class="mf">2.6</span><span class="p">),</span> <span class="n">z</span><span class="p">(</span><span class="mf">3.3</span><span class="p">,</span><span class="mf">1.1</span><span class="p">);</span>
      <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="o">+</span><span class="n">z</span><span class="p">;</span> <span class="c1">//=&gt; x = y.operator+(z)</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>重载<code class="highlighter-rouge">&lt;&lt;</code></li>
</ul>

<p>C++中的<code class="highlighter-rouge">cout&lt;&lt;</code>使用的也是运算符重载，<code class="highlighter-rouge">cout</code>是<code class="highlighter-rouge">ostream</code>类的对象，<code class="highlighter-rouge">ostream</code>重载了<code class="highlighter-rouge">&lt;&lt;</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">ostream</span><span class="o">::</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
	<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//cout&lt;&lt;3&lt;&lt;"this";`等价于:</span>
<span class="c1">//cout.operator&lt;&lt;(3).operator&lt;&lt;("this");</span>
</code></pre></div></div>
<p>也可以重载<code class="highlighter-rouge">&lt;&lt;</code>进行自定义输出</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span><span class="p">{</span>
<span class="nl">private:</span>
	<span class="n">string</span> <span class="n">name</span><span class="p">;</span>

<span class="k">friend</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">){</span>
	<span class="n">out</span><span class="o">&lt;&lt;</span><span class="n">p</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="n">Person</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="赋值运算符重载">赋值运算符重载</h3>

<ul>
  <li>赋值运算符两边类型可以不匹配</li>
  <li>赋值运算符<code class="highlighter-rouge">=</code>只能重载为<strong>成员函数</strong></li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">string</span><span class="p">{</span>
	<span class="nl">private:</span>
		<span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
		
	<span class="nl">public:</span>
		<span class="n">string</span><span class="p">()</span><span class="o">:</span><span class="n">p</span><span class="p">(</span><span class="nb">NULL</span><span class="p">){}</span>
		<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">c_str</span><span class="p">(){</span> <span class="k">return</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span>
		
		<span class="kt">char</span><span class="o">*</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">){</span>
				<span class="k">delete</span><span class="p">[]</span> <span class="n">p</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">){</span>
				<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
				<span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
				<span class="n">strcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span><span class="p">{</span>
				<span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
		<span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="n">string</span> <span class="n">x1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span> <span class="c1">//通过重载运算符实现</span>
<span class="p">}</span>

</code></pre></div></div>

<ul>
  <li>深浅拷贝
    <ul>
      <li>发生在两个对象互相赋值的过程中</li>
      <li>浅拷贝的问题:如果成员变量有指针对象，那么浅拷贝会导致被复制的对象和原对象的指针成员变量值相同，即他们指向同一块内存区域，当对象析构时，会有double free的风险</li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">){</span>

	<span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">c_str</span><span class="p">()</span> <span class="o">==</span> <span class="n">p</span><span class="p">){</span> <span class="c1">//自己赋值给自己</span>
		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">){</span>
		<span class="k">delete</span><span class="p">[]</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">c_str</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)];</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">s</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
	<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="n">string</span> <span class="n">x1</span><span class="o">=</span><span class="s">"abc"</span><span class="p">;</span>
	<span class="n">string</span> <span class="n">x2</span><span class="p">;</span>
	<span class="n">x2</span> <span class="o">=</span> <span class="n">x1</span><span class="p">;</span> <span class="c1">//通过重载运算符实现</span>
<span class="p">}</span>	
</code></pre></div></div>

<ul>
  <li>返回值不能设计成void，会有<code class="highlighter-rouge">a=b=c</code>的情况
    <ul>
      <li>等价于<code class="highlighter-rouge">a.operator=(b.operator=(c))</code></li>
    </ul>
  </li>
  <li>返回值要设计成引用类型
    <ul>
      <li>运算结果最终还是作用于自身，因此返回值用引用</li>
    </ul>
  </li>
</ul>

<h3 id="运算符重载为友元函数">运算符重载为友元函数</h3>

<ul>
  <li>成员函数不能满足使用要求</li>
  <li>普通函数，又不能访问类的私有成员</li>
</ul>

<h3 id="自加自减运算符重载">自加/自减运算符重载</h3>

<ul>
  <li>自加<code class="highlighter-rouge">++</code>, 自减<code class="highlighter-rouge">--</code>运算符有前置/后置之分</li>
  <li><strong>前置</strong>运算符为一元运算符重载, 返回左值
    <ul>
      <li>重载为成员函数</li>
    </ul>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//重载为成员函数</span>
  <span class="n">T</span> <span class="k">operator</span><span class="o">++</span><span class="p">();</span>
  <span class="n">T</span> <span class="k">operator</span><span class="o">--</span><span class="p">();</span>
</code></pre></div>    </div>
    <ul>
      <li>重载为全局函数
  ​	
  <code class="highlighter-rouge">cpp
  //重载为全局函数:
  T operator++(T);
  T operator--(T);
 </code>`</li>
      <li><code class="highlighter-rouge">++obj, obj.operator++(), operator++(obj)</code>都调用上述函数</li>
    </ul>
  </li>
  <li><strong>后置</strong>运算符作为二元运算符重载
    <ul>
      <li>多写一个参数，具体无意义，返回右值</li>
      <li>重载为成员函数</li>
    </ul>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">T</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">//多写一个参数告诉编译器是后置运算，初始化为0</span>
  <span class="n">T</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</code></pre></div>    </div>
    <ul>
      <li>重载为全局函数</li>
    </ul>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">T</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
  <span class="n">T</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">//第二个参数没有特殊意义, 默认初始化为0</span>
</code></pre></div>    </div>
    <ul>
      <li><code class="highlighter-rouge">obj++, obj.operator++(0), operator++(obj, 0)</code> 都调用上述函数</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">CDemo</code>例子</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CDemo</span> <span class="p">{</span>
<span class="k">private</span> <span class="o">:</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="nl">public:</span>
	<span class="n">CDemo</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">:</span><span class="n">n</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
	<span class="n">CDemo</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">();</span> <span class="c1">//用于前置++形式</span>
	<span class="n">CDemo</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">//用于后置++形式</span>
	<span class="k">operator</span> <span class="kt">int</span> <span class="p">(</span> <span class="p">)</span> <span class="p">{</span> 
		<span class="k">return</span> <span class="n">n</span><span class="p">;</span> 
	<span class="p">}</span>
	<span class="k">friend</span> <span class="n">CDemo</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="n">CDemo</span> <span class="o">&amp;</span><span class="p">);</span> <span class="c1">//友元全局函数，用于前置--形式</span>
	<span class="k">friend</span> <span class="n">CDemo</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="n">CDemo</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">//友元全局函数，用于后置--形式</span>
<span class="p">};</span>
<span class="n">CDemo</span> <span class="o">&amp;</span> <span class="n">CDemo</span><span class="o">::</span><span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span> <span class="c1">//前置 ++</span>
	<span class="n">n</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">*</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">CDemo</span> <span class="n">CDemo</span><span class="o">::</span><span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//后置 ++</span>
	<span class="n">CDemo</span> <span class="n">tmp</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="c1">//记录修改前的对象</span>
	<span class="n">n</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span> <span class="c1">//返回修改前的对象</span>
<span class="p">}</span>
<span class="n">CDemo</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="n">CDemo</span> <span class="o">&amp;</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//前置--</span>
	<span class="n">d</span><span class="p">.</span><span class="n">n</span><span class="o">--</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">CDemo</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="n">CDemo</span> <span class="o">&amp;</span> <span class="n">d</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//后置--</span>
	<span class="n">CDemo</span> <span class="n">tmp</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
	<span class="n">d</span><span class="p">.</span><span class="n">n</span> <span class="o">-</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span> 

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="n">CDemo</span> <span class="n">d</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">d</span><span class="o">++</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">","</span><span class="p">;</span> <span class="c1">//等价于 d.operator++(0);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="s">","</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">++</span><span class="n">d</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">","</span><span class="p">;</span> <span class="c1">//等价于 d.operator++();</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">d</span><span class="o">--</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">","</span><span class="p">;</span> <span class="c1">//等价于 operator--(d,0);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="s">","</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">--</span><span class="n">d</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">","</span><span class="p">;</span> <span class="c1">//等价于 operator--(d);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></div></div>

<h3 id="类型强制转换运算符重载">类型强制转换运算符重载</h3>

<ul>
  <li>有时需要对某个对象进行强制类型转换，转换规则也可以重载，例如:</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">operator</span> <span class="nf">int</span><span class="p">(){</span><span class="k">return</span> <span class="n">n</span><span class="p">;}</span>
</code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">int</code>作为一个类型强制转换运算符被重载，<code class="highlighter-rouge">Demo s; (int)s</code>，等价于<code class="highlighter-rouge">s.int()</code></p>
</blockquote>

<ul>
  <li>类型强制装换运算符重载时
    <ul>
      <li>不能写返回值类型</li>
      <li>实际上其返回值类型为强制转换后的类型</li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Number</span>
<span class="p">{</span>
  <span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
    <span class="n">Number</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">num</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">int</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Number</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">num</span> <span class="o">*</span> <span class="n">n</span><span class="p">.</span><span class="n">num</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">operator</span> <span class="kt">int</span><span class="p">(){</span>
        <span class="k">return</span> <span class="n">num</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">};</span> 

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Number</span> <span class="n">n1</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">n2</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">Number</span> <span class="n">n3</span><span class="p">;</span>
    <span class="n">n3</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">*</span> <span class="n">n2</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="kt">int</span><span class="p">(</span><span class="n">n3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//类型转换</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="函数对象functor">函数对象(functor)</h3>

<ul>
  <li>定义：若一个类重载运算符<code class="highlighter-rouge">()</code>，则该类对象就称为函数对象</li>
  <li>头文件：<code class="highlighter-rouge">&lt;functional&gt;</code></li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">double</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">a1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a3</span><span class="p">){</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">a1</span><span class="o">+</span><span class="n">a2</span><span class="o">+</span><span class="n">a3</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="n">A</span> <span class="n">average</span><span class="p">;</span> <span class="c1">//函数对象</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">average</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span> <span class="c1">//averate.operator()(3,2,4)</span>
</code></pre></div></div>
<ul>
  <li>STL中的函数对象模板
    <ul>
      <li><code class="highlighter-rouge">equal_to</code></li>
      <li><code class="highlighter-rouge">greater</code></li>
      <li><code class="highlighter-rouge">less</code></li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">greater</code>函数对象模板:</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">greater</span><span class="o">:</span><span class="k">public</span> <span class="n">binary_function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">{</span>
	<span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span><span class="k">const</span><span class="p">{</span>
		<span class="k">return</span> <span class="n">x</span><span class="o">&gt;</span><span class="n">y</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="运算符重载的注意事项">运算符重载的注意事项</h3>

<ul>
  <li>C++不允许定义新的运算符</li>
  <li>以下运算符不能被重载
    <ul>
      <li><code class="highlighter-rouge">.</code> , <code class="highlighter-rouge">.*</code>, <code class="highlighter-rouge">::</code>,<code class="highlighter-rouge">?:</code>,<code class="highlighter-rouge">sizeof</code></li>
    </ul>
  </li>
  <li>重载运算符<code class="highlighter-rouge">()</code>, <code class="highlighter-rouge">[ ]</code>, <code class="highlighter-rouge">-&gt;</code>或者赋值运算符<code class="highlighter-rouge">=</code>时, 重载函数必须声明为类的成员函数</li>
</ul>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="http://www.charleshouserjr.com/Cplus2.pdf">C++ Primer</a></li>
</ul>
:ET