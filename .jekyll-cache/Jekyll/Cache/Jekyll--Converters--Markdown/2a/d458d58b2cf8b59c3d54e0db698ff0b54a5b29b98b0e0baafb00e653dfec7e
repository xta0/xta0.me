I"պ<h3 id="motavition">Motavition</h3>

<p>一直以来JavaScript是我认为设计的比较奇怪的一门语言，一个原因是JavaScript中一切皆为Object，导致很多概念之间是模糊的，比如函数，对象，Prototype，Interface等等。而且它和同时期主流的编程语言设计有着非常大的不同，一个最重要的差别是，JavaScript采用基于Prototype的继承方式，而不是类继承，但是它的语法又借鉴了其它面向对象语言（比如引入了关键字<code class="highlighter-rouge">new</code>,<code class="highlighter-rouge">this</code>等，后面我们会看到这实际上是一个很糟糕的设计），这使得很多C++或者Java的程序员误以为JavaScript的面向对象和C++或Java是相同的。实际上，JavaScript完全可以采用一套自己独有的语言设计风格，这种基于Prototype + 弱类型设计，可以使其足够的灵活，也足以衍生出许多比C++或Java更富表现力的设计。</p>

<h2 id="scope">Scope</h2>

<p>JavaScript中的作用域设计的似乎有一些反常识，比如下面代码:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">//create a scope</span>
<span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">//2</span>
<span class="c1">//function scope</span>
<span class="kd">function</span> <span class="nx">func</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">//2</span>
</code></pre></div></div>
<p>上述代码中，第一个<code class="highlighter-rouge">{}</code>中的<code class="highlighter-rouge">a</code>改变了全局变量<code class="highlighter-rouge">a</code>的值，说明JS中单独的<code class="highlighter-rouge">{}</code>并不产生作用域的效果，但是函数body的<code class="highlighter-rouge">{}</code>却可以。</p>

<blockquote>
  <p>在随后的ES6中似乎修正了这个问题，<code class="highlighter-rouge">let</code>关键字可以保证变量严格受scope约束</p>
</blockquote>

<p>为了进一步了解作用域的问题，下面我们分析一下<code class="highlighter-rouge">var a = 2</code>的执行过程：</p>

<ol>
  <li>
    <p>当编译器遇到这行代码时，首先查看<code class="highlighter-rouge">a</code>所在的作用域中是否有该符号，如果有则忽略该语句，继续向下执行，否则会向作用域注册一个<code class="highlighter-rouge">a</code>符号并赋值<code class="highlighter-rouge">undefined</code>。上面的例子中，由于<code class="highlighter-rouge">{}</code>不产生作用域，<code class="highlighter-rouge">var a = 2</code>中的<code class="highlighter-rouge">a</code>与<code class="highlighter-rouge">{}</code>外层的<code class="highlighter-rouge">a</code>共享作用域，因此这条语句会被编译器忽略。</p>
  </li>
  <li>
    <p>接下来，编译器在编译完上述代码后，会生成可执行代码和运行时上下文，当执行到<code class="highlighter-rouge">var a = 2</code>时，JS的引擎会先从运行时上下文中查找<code class="highlighter-rouge">a</code>是否存在，如果存在，则将其指向的内容变为<code class="highlighter-rouge">2</code>，不存在则报错。</p>
  </li>
</ol>

<p>按照上面的过程，我们就不难解释JavaScript中所谓的”Hoisting”：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="c1">//undefined</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">10</span>
</code></pre></div></div>
<p>当执行<code class="highlighter-rouge">console.log(a)</code>时，编译器已经将<code class="highlighter-rouge">a</code>注册到运行时的上下文中了，并赋予了初值<code class="highlighter-rouge">undefined</code>，因此<code class="highlighter-rouge">console.log(a)</code>输出<code class="highlighter-rouge">undefined</code>。接下来引擎会</p>

<h2 id="function">Function</h2>

<p>函数可以说是JavaScript中最出彩的设计，如果放到在当时的年代，这种设计确实很大胆也很领先。在JS中的函数是First-Class Object，它即有函数的特性，也同时具有Object的特性，这使得在JS中函数的定义和使用非常灵活，</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">func</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>函数名<code class="highlighter-rouge">func</code>也是函数对象的名称，可以像使用任何Object一样使用<code class="highlighter-rouge">func</code>，比如可以给它增加成员函数，成员变量，做参数传递，做返回值返回等等。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">func</span><span class="p">.</span><span class="nx">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">func</span><span class="p">.</span><span class="nx">log</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">text</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">func</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">some text</span><span class="dl">"</span><span class="p">)</span> <span class="c1">//some text</span>
</code></pre></div></div>
<p>和Object相同的是，它也有自己的所谓的”基类”，即<code class="highlighter-rouge">Function.prototype</code>，而<code class="highlighter-rouge">Function.prototype</code>也是一个Object，它的”基类“是<code class="highlighter-rouge">Object.prototype</code>：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">func</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">//true</span>
<span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">//true</span>
</code></pre></div></div>
<p>上述代码可看出，<code class="highlighter-rouge">Function</code>和<code class="highlighter-rouge">Object</code>均为大写开头，这种规则“暗示”其类型为一个”构造函数“。”构造函数”也是一种函数对象，而函数对象和普通对象不同的是，它还有一个<code class="highlighter-rouge">prototype</code>属性：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">func</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">//{constructor: ƒ,__proto__:Object}</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">func.prototype</code>的类型也是Object，它只有一个成员叫做<code class="highlighter-rouge">constructor</code>,而<code class="highlighter-rouge">construtor</code>的值又指向<code class="highlighter-rouge">func</code>。</p>

<p>这是一个看起来特别让人困惑的设计，为什么要给函数对象增加这么一个对象？ 实际上引入这个<code class="highlighter-rouge">prototype</code>是为了模拟”继承“或者Interface，实现代码的重用。由于JavaScript中没有提供一种专门的”构造函数“，因此每个函数都会得到一个<code class="highlighter-rouge">prototype</code>对象。而<code class="highlighter-rouge">constructor</code>属性目前看来还没有什么用。</p>

<blockquote>
  <p>在后面讨论JavaScript面向对象的时候还会继续深入讨论<code class="highlighter-rouge">prototype</code>机制。</p>
</blockquote>

<p>最后说一下函数的传参问题，在JS中，没有所谓的函数签名，因此函数的声明和函数的调用也不需要match，我们可以不给函数声明任何参数，却可以在调用它的时候传递若干个参数。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">func</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1">//1</span>
<span class="p">}</span>
<span class="nx">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="this"><code class="highlighter-rouge">this</code></h2>

<p><code class="highlighter-rouge">this</code>在JS中是另一个古怪的存在，由于这门语言没有面向对象设计，因此<code class="highlighter-rouge">this</code>应该无从谈起，但实际上<code class="highlighter-rouge">this</code>却到处都有，有global的<code class="highlighter-rouge">this</code>，函数中有<code class="highlighter-rouge">this</code>，Object中也有<code class="highlighter-rouge">this</code>。</p>

<h3 id="global-object">Global Object</h3>

<p>全局<code class="highlighter-rouge">this</code>指向global object</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="c1">//Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}</span>
<span class="k">this</span><span class="p">.</span><span class="kd">var</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">windown</span><span class="p">.</span><span class="kd">var</span><span class="p">);</span> <span class="c1">//100</span>
</code></pre></div></div>
<p>全局函数中的<code class="highlighter-rouge">this</code>同样指向window obejct</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">a</span><span class="p">(){</span>
    <span class="nx">consloe</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">//points to window obejct</span>
    <span class="k">this</span><span class="p">.</span><span class="kd">var</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">;</span> <span class="c1">//add var to window object</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">b</span><span class="p">(){</span>
    <span class="nx">consloe</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">//window obejct</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="this-in-obejct"><code class="highlighter-rouge">this</code> in Obejct</h3>

<p>如果<code class="highlighter-rouge">this</code>位于某个Object的内部，则<code class="highlighter-rouge">this</code>指向该Obejct</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
	<span class="na">firstName</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Elie</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">log</span><span class="p">:</span><span class="kd">function</span><span class="p">(){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="c1">//points to person obejct</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>但是如果你认为<code class="highlighter-rouge">person</code>内部定义的function其<code class="highlighter-rouge">this</code>都指向<code class="highlighter-rouge">person</code>的话，那么你就错了，如果在<code class="highlighter-rouge">log</code>函数中定义另一个function，那么这个function中的<code class="highlighter-rouge">this</code>指向的是<code class="highlighter-rouge">global</code> object</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
	<span class="na">firstName</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Elie</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">log</span><span class="p">:</span><span class="kd">function</span><span class="p">(){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="c1">//person</span>
        <span class="kd">var</span> <span class="nx">setname</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">firstName</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span> <span class="c1">//this points to window object</span>
        <span class="p">}</span>
        <span class="nx">setname</span><span class="p">(</span><span class="dl">"</span><span class="s2">Tom</span><span class="dl">"</span><span class="p">);</span><span class="c1">//not working </span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>正确的做法是显式的定义一个<code class="highlighter-rouge">this</code>的引用</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">log</span><span class="p">:</span><span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">setname</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
        <span class="nb">self</span><span class="p">.</span><span class="nx">firstName</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span> 
    <span class="p">}</span>
    <span class="nx">setname</span><span class="p">(</span><span class="dl">"</span><span class="s2">Tom</span><span class="dl">"</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></div></div>

<h3 id="bindapplycall"><code class="highlighter-rouge">bind</code>,<code class="highlighter-rouge">apply</code>,<code class="highlighter-rouge">call</code></h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">logName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">str1</span><span class="p">,</span> <span class="nx">str2</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getFullName</span><span class="p">())</span> <span class="c1">//window object</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上述代码中，<code class="highlighter-rouge">logName</code>是一个全局函数，由前面的讨论可知，此时<code class="highlighter-rouge">this</code>指向global object，也就是<code class="highlighter-rouge">window</code>,由于<code class="highlighter-rouge">windown</code>中没有<code class="highlighter-rouge">getFullName</code>这个方法，因此上述代码执行会出错。针对上面的情况，在JavaScript中，<code class="highlighter-rouge">this</code>的值是可以改变的，我们可以让<code class="highlighter-rouge">this</code>指向一个有<code class="highlighter-rouge">getFullName</code>方法的对象：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">firstname</span><span class="p">:</span> <span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">lastname</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Doe</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">getFullName</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="kd">var</span> <span class="nx">fullname</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">firstname</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">lastname</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">fullname</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">logName</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">str1</span><span class="p">,</span><span class="nx">str2</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getFullName</span><span class="p">())</span> <span class="c1">//wrong</span>
<span class="p">}).</span><span class="nx">bind</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>

<span class="nx">logName</span><span class="p">()</span> <span class="c1">//John Doe</span>
<span class="nx">logName</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span><span class="dl">"</span><span class="s2">str1</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">str2</span><span class="dl">"</span><span class="p">)</span> <span class="c1">//John Doe</span>
<span class="nx">logName</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">person</span><span class="p">,[</span><span class="dl">"</span><span class="s2">str1,str2</span><span class="dl">"</span><span class="p">])</span><span class="c1">//John Doe</span>
</code></pre></div></div>

<p>上述代码中令<code class="highlighter-rouge">logName</code>函数中的<code class="highlighter-rouge">this</code>指向了<code class="highlighter-rouge">person</code>。</p>

<p><code class="highlighter-rouge">bind,call,apply</code>这三种方式均可以改变<code class="highlighter-rouge">this</code>的指向，不同的是<code class="highlighter-rouge">bind</code>并不执行函数，只是改变<code class="highlighter-rouge">this</code>的值，<code class="highlighter-rouge">call</code>,<code class="highlighter-rouge">apply</code>会直接执行函数，<code class="highlighter-rouge">call</code>和<code class="highlighter-rouge">apply</code>的区别仅在传参的写法上。</p>

<p>凡是有<code class="highlighter-rouge">this</code>的函数均可以用这几种方式去改变<code class="highlighter-rouge">this</code>，比如</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">person2</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">firstname</span><span class="o">=</span><span class="dl">"</span><span class="s2">Jane</span><span class="dl">"</span><span class="p">,</span>
    <span class="nx">lastname</span><span class="o">=</span><span class="dl">"</span><span class="s2">Doe</span><span class="dl">"</span>
<span class="p">}</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">getFullName</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">person2</span><span class="p">)</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">bind</code>还以用来改变函数的行为</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">map</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">fn</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">){</span>
        <span class="nx">ret</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">fn</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="nx">map</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="kd">function</span><span class="p">(</span><span class="nx">limit</span><span class="p">,</span><span class="nx">item</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">item</span> <span class="o">&gt;</span> <span class="nx">limit</span><span class="p">;</span>
<span class="p">}.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="c1">//limit的值为1</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">map</code>接受两个参数，一个是数组，另一个是<code class="highlighter-rouge">fn</code>函数。<code class="highlighter-rouge">fn</code>函数按照上面定义，接受一个数组元素作为参数。接下来当我们在调用<code class="highlighter-rouge">map</code>的时候，却给<code class="highlighter-rouge">fn</code>传了两个参数，一个是<code class="highlighter-rouge">this</code>用作占位（对于<code class="highlighter-rouge">fn</code>来说，这个<code class="highlighter-rouge">this</code>没有实际意义）另一个是数字<code class="highlighter-rouge">1</code>，此时对于<code class="highlighter-rouge">fn</code>来说，传入的<code class="highlighter-rouge">1</code>会被自动绑定到<code class="highlighter-rouge">limit</code>上，而<code class="highlighter-rouge">fn</code>此时也等价于下面的函数：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="p">(</span><span class="nx">item</span><span class="p">){</span>
    <span class="nx">limit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">item</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="iifes">IIFEs</h3>

<p>第一次看到IIFEs这种形式的JS代码，完全不知道它是干嘛的，这种写法实际上隐含了JavaScript解释器的一些规则，看下面代码</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">greeting</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}(</span><span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">greeting</span><span class="p">);</span>
</code></pre></div></div>
<p>这时<code class="highlighter-rouge">greeting</code>的类型是什么呢？string还是function？ 显然上述写法中，<code class="highlighter-rouge">greeting</code>变成了<code class="highlighter-rouge">string</code>。不难理解上述代码的执行顺序为：</p>

<ol>
  <li>匿名函数求值</li>
  <li>将求值结果保存在<code class="highlighter-rouge">greeting</code>中。</li>
</ol>

<p>为什么会这么解释，在任何编程语言中，statement和expression是两个概念，statement是普通的语句，可以是条件语句，或者定义一个函数等等，而expression则表示一个表达式，而表达式是要立刻求值的。上面代码中，当编译器看到<code class="highlighter-rouge">var greeting = </code>时，知道后面是一个表达式，进而对后面的匿名函数进行求值。而我们如果让编译器先看到<code class="highlighter-rouge">function</code>，结果会是什么样呢？</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span> <span class="c1">//wrong</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">Hello </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>错误原因是上面的语句以<code class="highlighter-rouge">function</code>开头，编译器会认为它是一个函数定义的statement，而statement一定要有”主语”，即函数名，这样编译器才能将该符号注册到context中，由于上面语句没有函数名，因此报错。但是如果使用<code class="highlighter-rouge">()</code>将其括起来，则语义就会发生变化:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">Hello </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">})</span>
</code></pre></div></div>

<p>在JS中<code class="highlighter-rouge">()</code>包裹的statement为一个表达式expression，因此上述代码会被当做expression进行求值，显然求值的结果是得到了一个匿名函数（值得注意的是，匿名函数并没有求值）。因此该表达式的返回值是一个匿名函数，相当于</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">func</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">Hello </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">})</span>
</code></pre></div></div>
<p>如果想要执行这个匿名函数，则需要显式调用它</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//#1</span>
<span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">Hello </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">})(</span><span class="dl">"</span><span class="s2">John</span><span class="dl">"</span><span class="p">)</span>

<span class="c1">//#2</span>
<span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">Hello </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}(</span><span class="dl">"</span><span class="s2">John</span><span class="dl">"</span><span class="p">))</span>
</code></pre></div></div>
<p>这样，上述代码就变成了两个表达式。如果是第一种写法，则第一个<code class="highlighter-rouge">()</code>表达式返回了一个匿名函数，第二表达式是匿名函数调用得到一个string；如果是第二种写法，则第一个表达式为函数求值，返回一个string，第二个表达式为<code class="highlighter-rouge">()</code>什么也没做，直接返回该string。</p>

<p><mark>这两种写法的结果一样，但是表达式的执行顺序却不同。</mark></p>

<p>这种方式对于隔离全局变量很有帮助，由于JS没有命名空间，函数外定义的的变量都是全局的，如果我们想要执行一段代码又不污染全局变量，使用IIFE是一种好的方式</p>

<h3 id="closures">Closures</h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">greet</span><span class="p">(</span><span class="nx">str1</span><span class="p">){</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">str2</span><span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">str1</span><span class="o">+</span><span class="dl">'</span><span class="s1"> </span><span class="dl">'</span><span class="o">+</span><span class="nx">str2</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">func2</span> <span class="o">=</span> <span class="nx">greet</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hi</span><span class="dl">"</span><span class="p">)</span>
<span class="nx">func2</span><span class="p">(</span><span class="dl">"</span><span class="s2">Tony</span><span class="dl">"</span><span class="p">)</span> <span class="c1">//Hi Tony</span>
</code></pre></div></div>

<p>上面代码中，按照常理理解，在执行<code class="highlighter-rouge">func2</code>之前，<code class="highlighter-rouge">greet</code>函数已经执行完了，<code class="highlighter-rouge">str1</code>应该已经被释放了，为什么在执行<code class="highlighter-rouge">func2</code>的时候还能访问到<code class="highlighter-rouge">str1</code>呢？如果熟悉其它编程语言的Closure，比如C++的Lambda表达式，Objective-C的Block等，那么这个问题就不难理解。从现象看，是<code class="highlighter-rouge">str1</code>被<code class="highlighter-rouge">str2</code>所在的匿名函数给capture了，至于是怎么capture的，无外乎两种策略，拷贝或者引用，按照前面小节的推断，如果<code class="highlighter-rouge">str1</code>是Primary Type，那么应该是拷贝，如果是Object类型，那么应该是传引用。但是对于Closures，无论任何数据类型，均是传引用，下面是一个经典的例子：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">buildFunctions</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
        <span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
        <span class="p">})</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">buildFunctions</span><span class="p">();</span>
<span class="nx">fs</span><span class="p">[</span><span class="mi">0</span><span class="p">]();</span> <span class="c1">//3</span>
<span class="nx">fs</span><span class="p">[</span><span class="mi">1</span><span class="p">]();</span> <span class="c1">//3</span>
<span class="nx">fs</span><span class="p">[</span><span class="mi">2</span><span class="p">]();</span> <span class="c1">//3</span>
</code></pre></div></div>
<p>通过这个例子可以看出，即使是<code class="highlighter-rouge">i</code>作为int型的Primary Type，对于Closure而言，保存的仍是它的引用。Closure这个特性可用来做异步任务，异步任务的回调函数可以capture在执行任务前的变量，比如</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">timer_func</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">greeting</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hi!</span><span class="dl">"</span><span class="p">;</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">greeting</span><span class="p">);</span>
    <span class="p">},</span><span class="mi">3000</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">timer_func</span><span class="p">()</span>
</code></pre></div></div>
<p>上述代码中，在执行3s后输出<code class="highlighter-rouge">Hi!</code>，其原因是<code class="highlighter-rouge">setTimer</code>的回调函数capture了<code class="highlighter-rouge">greeting</code>。JavaScript的这个特性对很多Framework的设计起到了非常关键的作用。</p>

<h3 id="call-by-value--call-by-reference">Call By Value / Call by Reference</h3>

<p>这个问题是理解每一门编程语言都要绕不过去的问题，本质上是内存分配问题，无论是Python，C++，Java等等，比如C++中函数传参可以有传值和传引用两种方式，所谓传值就是拷贝，传引用就是传地址。理解这个问题是正确处理Side Effect的基础。</p>

<p>在JS中对Primary Type类型的对象传值，对Object类型的对象传引用。即是不是传参的情况，JS对象之间的赋值也是引用的传递。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//pass by value</span>
<span class="kd">function</span> <span class="nx">change</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">change</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="c1">// still 1</span>

<span class="c1">//pass object by reference</span>
<span class="kd">function</span> <span class="nx">changeObj</span><span class="p">(</span><span class="nx">d</span><span class="p">){</span>
    <span class="nx">d</span><span class="p">.</span><span class="nx">prop1</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span>  <span class="p">{}</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">prop1</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">changeObj</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span>
<span class="nx">consloe</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">prop1</span><span class="p">);</span> <span class="c1">//string</span>
</code></pre></div></div>

<h3 id="null--undefined">null &amp; undefined</h3>

<p>JavaScript中的<code class="highlighter-rouge">null</code>表示显式的指明某变量的值为空或者0，<code class="highlighter-rouge">undefined</code>表示”无”的原始值，转为数值时为NaN。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">//undefined</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span> <span class="c1">//null</span>
<span class="nb">Number</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span> <span class="c1">//0</span>
<span class="mi">5</span> <span class="o">+</span> <span class="kc">null</span> <span class="c1">//5</span>
<span class="mi">5</span> <span class="o">+</span> <span class="kc">undefined</span> <span class="c1">//NaN</span>
</code></pre></div></div>

<p>在应用上二者没有本质的区别，在条件判断中都是<code class="highlighter-rouge">false</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="kc">undefined</span><span class="p">)</span> 
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">undefined is false</span><span class="dl">'</span><span class="p">);</span><span class="c1">// undefined is false</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="kc">null</span><span class="p">)</span> 
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">null is false</span><span class="dl">'</span><span class="p">);</span><span class="c1">// null is false</span>
<span class="kc">undefined</span> <span class="o">==</span> <span class="kc">null</span> <span class="c1">// true</span>
</code></pre></div></div>
<p>对于<code class="highlighter-rouge">undefined</code>，可以用在</p>

<ol>
  <li>变量被声明了，默认值为undefined。</li>
  <li>调用函数时，缺省参数默认为undefined。</li>
  <li>对象的属性没有赋值，该属性的值为undefined。</li>
  <li>不指定函数返回值，默认返回undefined。</li>
</ol>

<p>对于<code class="highlighter-rouge">null</code>,一般用来表示</p>

<ol>
  <li>显式指定函数参数为<code class="highlighter-rouge">null</code>。</li>
  <li>显式指定原型链的终点为<code class="highlighter-rouge">null</code>。</li>
</ol>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span> <span class="c1">//null</span>
</code></pre></div></div>

<p>在设计上，二者的类型确不同，对于<code class="highlighter-rouge">null</code>的类型为Object，这个已经被人吐槽好多次了，这里就不再解释了。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typeof</span> <span class="nx">undifined</span> <span class="c1">//undefined</span>
<span class="k">typeof</span> <span class="kc">null</span> <span class="c1">//object</span>
</code></pre></div></div>

<h3 id="exceptions">Exceptions</h3>

<p>JavaScript使用<code class="highlighter-rouge">throw</code>抛异常，当函数抛出异常后会立即终止运行</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">a</span> <span class="o">!=</span> <span class="dl">'</span><span class="s1">number</span><span class="dl">'</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">b</span> <span class="o">!=</span> <span class="dl">'</span><span class="s1">number</span><span class="dl">'</span><span class="p">){</span>
        <span class="k">throw</span><span class="p">{</span>
            <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">TypeError</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">message</span><span class="p">:</span> <span class="dl">'</span><span class="s1">add needs numbers</span><span class="dl">'</span>
        <span class="p">};</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="p">);</span> <span class="c1">//won't run if there is an error</span>
<span class="p">}</span>

<span class="kd">var</span>  <span class="nx">try_it</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">){</span>
    <span class="k">try</span><span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">));</span>
    <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">try_it</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="dl">"</span><span class="s2">10</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="resources">Resources</h3>

<ul>
  <li><a href="https://github.com/getify/You-Dont-Know-JS">You don’t konw JavaScript</a></li>
  <li><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">null与undefined的区别</a></li>
  <li><a href="https://7chan.org/pr/src/OReilly_JavaScript_The_Good_Parts_May_2008.pdf">JavaScripts: The Good Part</a></li>
  <li><a href="ttps://www.udemy.com/understand-javascript">JavaScripts: Understanding the wierd parts</a></li>
</ul>
:ET