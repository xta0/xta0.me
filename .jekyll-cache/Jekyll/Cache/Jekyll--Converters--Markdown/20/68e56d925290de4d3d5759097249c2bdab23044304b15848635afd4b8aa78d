I":<p>C++中的<code class="highlighter-rouge">shared_ptr</code>用来方便管理head-allocated对象，它虽然简单易用，但会带来一些副作用，比如perf和code size的问题。<code class="highlighter-rouge">shared_ptr</code>里面维护着一个atomic的refcount</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">shared_ptr_control_block</span> <span class="p">{</span>
    <span class="n">some_atomic_counter_type</span> <span class="n">reference_count</span><span class="p">;</span>
    <span class="c1">// maybe other stuff....</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">shared_ptr</span> <span class="p">{</span>
    <span class="n">T</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="n">shared_ptr_control_block</span> <span class="o">*</span><span class="n">cntrl</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>当一个<code class="highlighter-rouge">shared_ptr</code>被创建时，这个<code class="highlighter-rouge">shared_ptr_control_block</code>是会在heap上单独创建。<code class="highlighter-rouge">shared_ptr</code>的构造函数，copy构造和析构函数都需要维护这个refcount。为了在多线程的环境下能正确工作，refcount的bump是atomic的。和正常的increament, decrement相比，atomic的操作是非常expensive的，<a href="https://uops.info/table.html">uops.info</a>的数据显示atomic increment的速度是non-atomic increment的5倍。如果多个线程同时bump refcount，性能的损失会非常大，因为原子操作无法在多线程中同时执行。</p>

<h3 id="shared_ptr作为参数传递"><code class="highlighter-rouge">shared_ptr</code>作为参数传递</h3>

<p>将<code class="highlighter-rouge">shared_ptr</code>作为参数传递要谨慎，有些时候callee只是使用<code class="highlighter-rouge">shared_ptr</code>而不需要take ownership的，因此这个时候可以用<code class="highlighter-rouge">const T&amp;</code>, <code class="highlighter-rouge">T&amp;</code>或者直接用raw pointer。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">);</span> <span class="c1">// Shares ownership</span>
<span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span><span class="p">);</span> <span class="c1">// May or may not take ownership</span>
<span class="kt">void</span> <span class="nf">h</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// Doesn't take ownership</span>
</code></pre></div></div>
<p>我们看几个例子</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">x</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">g</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span>
  <span class="n">f</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>上面这个case，<code class="highlighter-rouge">f</code>只是使用Widget，它并不需要接受一个<code class="highlighter-rouge">shared_ptr</code>，传一个引用即可</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">x</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">g</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Widget</span> <span class="n">p</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span>
  <span class="n">f</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>除此之外，如果多个objects需要引用同一个shared object，通常情况下很容易identify一个single owner，而避免使用<code class="highlighter-rouge">shared_ptr</code>，例如</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FancyUIComponent</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ProductState</span><span class="o">&gt;</span> <span class="n">state</span><span class="p">;</span>
  <span class="n">FancyButton</span> <span class="n">button1</span><span class="p">;</span>
  <span class="n">FancyButton</span> <span class="n">button2</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">FancyButton</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ProductState</span><span class="o">&gt;</span> <span class="n">state</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>由于<code class="highlighter-rouge">FancyButton</code>从属于<code class="highlighter-rouge">FancyUIComponent</code>，它的生命周期往往和parent component一致，因此它不需要使用<code class="highlighter-rouge">shared_ptr</code>来存放parent state</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FancyButton</span> <span class="p">{</span>
  <span class="n">ProductState</span><span class="o">*</span> <span class="n">state</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="什么时候需要使用shared_ptr">什么时候需要使用<code class="highlighter-rouge">shared_ptr</code></h3>

<p><code class="highlighter-rouge">shared_ptr</code>在多线程环境下往往很有用，每个线程copy一份<code class="highlighter-rouge">shared_ptr</code></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">anotherIndependentThread</span><span class="p">([</span><span class="n">p</span><span class="p">]()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">});</span>
</code></pre></div></div>
<p>由于ref count的bump是atmoic的，因此多个线程使用各自的<code class="highlighter-rouge">shared_ptr</code>是安全的。但是如果各个线程同时创建<code class="highlighter-rouge">shared_ptr</code>则是不安全的，如下面代码</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">shared</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">create</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">shared</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">get</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">*</span><span class="n">shared</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></div></div>

<p>上面代码中，如果<code class="highlighter-rouge">create()</code>和<code class="highlighter-rouge">get()</code>同时被不同线程调用，则会出现出问题，因为对<code class="highlighter-rouge">shared</code>的assignment和read不是atomic的</p>

<h3 id="shared_ptr无法避免retain-cycle的问题"><code class="highlighter-rouge">shared_ptr</code>无法避免retain cycle的问题</h3>

<p>下面代码会导致memory leak</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">StrangeLinkedListNode</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">StrangeLinkedListNode</span><span class="o">&gt;</span> <span class="n">other</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">StrangeLinkedlistNode</span><span class="o">&gt;</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">StrangeLinkedlistNode</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">a</span><span class="p">.</span><span class="n">other</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
<span class="n">b</span><span class="p">.</span><span class="n">other</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
<span class="n">b</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
<span class="c1">// Memory leak!</span>
</code></pre></div></div>
<p>上面例子中虽然<code class="highlighter-rouge">a</code>和<code class="highlighter-rouge">b</code>都进行了<code class="highlighter-rouge">reset</code>，但是他们的ref count并不会变成<code class="highlighter-rouge">1</code></p>

<h3 id="more-on-passing-smart-pointer-as-function-arguments">More on passing smart pointer as function arguments</h3>

<p><a href="https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/">这篇文章提了几个很好的问题</a>:</p>

<ol>
  <li>解释<code class="highlighter-rouge">void f( shared_ptr&lt;widget&gt; );</code>可能会带来的性能问题</li>
  <li>假设我有一个<code class="highlighter-rouge">widget</code>的对象，我该如何将它作为参数传给一个函数<code class="highlighter-rouge">f</code>呢，考虑下面几种方式</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="n">widget</span><span class="o">*</span> <span class="p">);</span>              <span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="n">widget</span><span class="o">&amp;</span> <span class="p">);</span>              <span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;</span> <span class="p">);</span>   <span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;&amp;</span> <span class="p">);</span>  <span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;</span> <span class="p">);</span>   <span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;&amp;</span> <span class="p">);</span>  <span class="p">(</span><span class="n">f</span><span class="p">)</span>
</code></pre></div></div>
<p>哪种方式适合哪种场景呢？什么时候或者要不要加上<code class="highlighter-rouge">const</code>呢？</p>

<p>第一个问题我们上面已经讨论过了，直接传递<code class="highlighter-rouge">shared_ptr</code>会带来</p>
:ET