I"uE<p>对于小型的C++项目，我们可以手写Makefile来完成项目的构建，但是当项目变的越来越复杂，模块越来越多时，模块间的依赖关系将会变得非常复杂，手写Makefile的方式扩展性会变差。此时就可以用到CMake，CMake是一套支持多语言的跨平台的代码构建工具，很多大型的C++工程都用它来构建，比如PyTorch, LLVM等。本文并不是CMake教程，而是记录一些日常使用过程中经常使用的命令和容易出错的地方，以及一些概念模糊的知识点。如果想要阅读CMake的教程，网上有很多不错资料可以参考，详见文末的参考文献。</p>

<h3 id="cmake基础">CMake基础</h3>

<p>一个常见的项目文件组织方式如下图所示</p>

<p><img src="/assets/images/2019/06/cmake-1.png" width="80%" class="md-img-center" /></p>

<p>当我们运行<code class="highlighter-rouge">cmake</code>命令时，该命令会读取项目根目录下的<code class="highlighter-rouge">CMakeLists.txt</code>，从而开始程序的构建。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>build 
<span class="nb">cd </span>build
cmake <span class="nt">-G</span> <span class="s2">"XCode"</span> ../source
</code></pre></div></div>

<p>上面命中的第二个参数是Generator的名称，我们可以用<code class="highlighter-rouge">-G</code>显式的指定用什么Generator编译。CMake提供若干个Generator，比如Visual Studio，XCode等，如下所示</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Generators
<span class="k">*</span> Unix Makefiles               <span class="o">=</span> Generates standard UNIX makefiles.
  Ninja                        <span class="o">=</span> Generates build.ninja files.
  Xcode                        <span class="o">=</span> Generate Xcode project files.
  CodeBlocks - Ninja           <span class="o">=</span> Generates CodeBlocks project files.
  CodeBlocks - Unix Makefiles  <span class="o">=</span> Generates CodeBlocks project files.
  CodeLite - Ninja             <span class="o">=</span> Generates CodeLite project files.
  CodeLite - Unix Makefiles    <span class="o">=</span> Generates CodeLite project files.
  Sublime Text 2 - Ninja       <span class="o">=</span> Generates Sublime Text 2 project files.
  Sublime Text 2 - Unix Makefiles
                               <span class="o">=</span> Generates Sublime Text 2 project files.
  Kate - Ninja                 <span class="o">=</span> Generates Kate project files.
  Kate - Unix Makefiles        <span class="o">=</span> Generates Kate project files.
  Eclipse CDT4 - Ninja         <span class="o">=</span> Generates Eclipse CDT 4.0 project files.
  Eclipse CDT4 - Unix <span class="nv">Makefiles</span><span class="o">=</span> Generates Eclipse CDT 4.0 project files.
</code></pre></div></div>

<p>使用不同的Generator，产生的结果是不同的，比如使用XCode构建，结果是一个<code class="highlighter-rouge">.xcodeproj</code>的工程文件，如果使用默认的”UNIX Makefiles”，构建结果则为Makefile文件。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">--</span> Configuring <span class="k">done</span>
<span class="nt">--</span> Generating <span class="k">done</span>
<span class="nt">--</span> Build files have been written to: /some/path/build
</code></pre></div></div>
<p>当执行<code class="highlighter-rouge">cmake</code>时，可以看到上面的log，这说明CMake在构建程序时分为两个阶段，第一阶段是COnfiguring，该阶段CMake的任务是解析<code class="highlighter-rouge">CMakeList.txt</code>，处理模块间的依赖关系；第二个阶段是Generating，这个阶段会根据第一阶段生成好的依赖关系来构建程序，注意，此时并不会编译代码，而是生成项目文件（Makefile文件，如果使用XCode作为Generator，则会生成工程文件）。除了产生项目文件外，CMake在<code class="highlighter-rouge">build</code>目录下还会生成一个<code class="highlighter-rouge">CMakeCache.txt</code>的文件，用来缓存一些变量值，当再次运行<code class="highlighter-rouge">cmake</code>时可以直接使用。</p>

<p>有了项目文件后，我们就可以来真正的编译程序了</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#build目录下</span>
cmake <span class="nt">--build</span> <span class="nb">.</span> <span class="nt">--config</span> Release <span class="nt">--target</span> MyApp
</code></pre></div></div>
<p>此时CMake会根据当前平台选择对应的Tool Chain，比如Mac下使用Clang，在Linux下则使用GCC。一个构建executable的例子如下</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake_minimum_required<span class="o">(</span>VERSION 3.5<span class="o">)</span>
project<span class="o">(</span>build_executable LANGUAGES CXX<span class="o">)</span>
<span class="nb">set</span><span class="o">(</span>src <span class="s2">"main.cpp"</span> <span class="s2">"src/person.h"</span><span class="o">)</span>
add_executable<span class="o">(</span>hello <span class="k">${</span><span class="nv">src</span><span class="k">}</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="libraries和linking">Libraries和Linking</h3>

<p>构建库文件的完整命令如下</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>add_library<span class="o">(</span>targetName <span class="o">[</span>STATIC | SHARED | MODULE]
<span class="o">[</span>EXCLUDE_FROM_ALL]
source1 <span class="o">[</span>source2 ...]
<span class="o">)</span>
</code></pre></div></div>
<p>从说明中可知，库在CMake中是一种<strong>Target</strong>，Target的概念很重要，有很多设计直接和它先关。CMake支持三种库类型，分别是静态库，动态库，以及<code class="highlighter-rouge">MODULE</code>。Module也是一种动态库，不同的地方在于它不参与最终的link，而是被用作runtime加载的动态库（<code class="highlighter-rouge">dlopen</code>）。</p>

<p>链接库的命令如下</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>target_link_libraries<span class="o">(</span>targetName
&lt;PRIVATE|PUBLIC|INTERFACE&gt; item1 <span class="o">[</span>item2 ...]
<span class="o">[</span>&lt;PRIVATE|PUBLIC|INTERFACE&gt; item3 <span class="o">[</span>item4 ...]]
...
<span class="o">)</span>
</code></pre></div></div>
<p>这里需要注意下第二个参数，也就是链接方式，我们假设有两个库A和B，令A来链接B</p>

<ol>
  <li>PRIVATE，A只有在实现上依赖B，因此B的接口会被隐藏，使用A的库不需要知道B的存在</li>
  <li>PUBLIC，A不仅在实现上依赖B，接口上也依赖，比如A的头文件中要<code class="highlighter-rouge">include</code> B的接口，这样使用A的库也可以看到B，并且也要链接B</li>
  <li>INTERFACE，A只依赖B的接口（头文件），而不依赖B的内部实现，可能A内部有自己的实现</li>
</ol>

<p>来看一个具体的例子</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake_minimum_required<span class="o">(</span>VERSION 3.5<span class="o">)</span>
project<span class="o">(</span>static_libs LANGUAGES CXX<span class="o">)</span>

<span class="nb">set</span> <span class="o">(</span>src1 <span class="s2">"src/Person.cpp"</span><span class="o">)</span>
<span class="nb">set</span> <span class="o">(</span>hdr1 <span class="s2">"src/Person.h"</span><span class="o">)</span>
<span class="nb">set</span> <span class="o">(</span>src2 <span class="s2">"src/Bar.cpp"</span><span class="o">)</span>
<span class="nb">set</span> <span class="o">(</span>hdr2 <span class="s2">"src/Bar.h"</span><span class="o">)</span>
<span class="nb">set</span> <span class="o">(</span>src3 <span class="s2">"src/Foo.cpp"</span><span class="o">)</span>
<span class="nb">set</span> <span class="o">(</span>hdr3 <span class="s2">"src/Foo.h"</span><span class="o">)</span>
<span class="nb">set</span> <span class="o">(</span>src <span class="s2">"src/main.cpp"</span><span class="o">)</span>

<span class="c">#1. genreate a static library</span>
add_library<span class="o">(</span>person STATIC <span class="k">${</span><span class="nv">src1</span><span class="k">}</span> <span class="k">${</span><span class="nv">hdr1</span><span class="k">}</span><span class="o">)</span>
add_library<span class="o">(</span>bar STATIC <span class="k">${</span><span class="nv">src2</span><span class="k">}</span> <span class="k">${</span><span class="nv">hdr2</span><span class="k">}</span><span class="o">)</span>
add_library<span class="o">(</span>foo STATIC <span class="k">${</span><span class="nv">src3</span><span class="k">}</span> <span class="k">${</span><span class="nv">hdr3</span><span class="k">}</span><span class="o">)</span>
add_executable<span class="o">(</span>app <span class="k">${</span><span class="nv">src</span><span class="k">}</span><span class="o">)</span>

<span class="c">#2. generate executable binary</span>
target_link_libraries<span class="o">(</span>person PRIVATE bar<span class="o">)</span>
target_link_libraries<span class="o">(</span>person INTERFACE foo<span class="o">)</span>
target_link_libraries<span class="o">(</span>app PUBLIC person<span class="o">)</span>
</code></pre></div></div>
<p>例子中<code class="highlighter-rouge">person</code>对<code class="highlighter-rouge">foo</code>的链接是基于<code class="highlighter-rouge">INTEFACE</code>的。在<code class="highlighter-rouge">Foo.h</code>中只有一个接口</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma once
#include &lt;iostream&gt;
</span><span class="k">namespace</span> <span class="n">Foo</span><span class="p">{</span>
    <span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>此时如果<code class="highlighter-rouge">person</code>内部有<code class="highlighter-rouge">Foo:foo</code>的实现，则<code class="highlighter-rouge">person</code>会用自己的实现，如果没有，则会用<code class="highlighter-rouge">Foo.cpp</code>中的实现</p>

<h3 id="variables">Variables</h3>

<p>CMake中变量的定义为</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set</span><span class="o">(</span>varName value... <span class="o">[</span>PARENT_SCOPE]<span class="o">)</span>
<span class="nb">unset</span><span class="o">(</span>varName value... <span class="o">[</span>PARENT_SCOPE]<span class="o">)</span>
</code></pre></div></div>
<p>变量的类型为string，定义时不需要引号，为了避免歧义，尽量使用双引号</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set</span><span class="o">(</span>myVar a b c<span class="o">)</span> <span class="c"># myVar = "abc"</span>
<span class="nb">set</span><span class="o">(</span>myVar a<span class="p">;</span>b<span class="p">;</span>c<span class="o">)</span> <span class="c"># myVar = "abc"</span>
<span class="nb">set</span><span class="o">(</span>myVar <span class="s2">"a b c"</span><span class="o">)</span> <span class="c"># myVar = "a b c"</span>
<span class="nb">set</span><span class="o">(</span>myVar a b<span class="p">;</span>c<span class="o">)</span> <span class="c"># myVar = "abc"</span>
<span class="nb">set</span><span class="o">(</span>myVar a <span class="s2">"b c"</span><span class="o">)</span> <span class="c"># myVar = "ab c"</span>
</code></pre></div></div>
<p>使用变量的语法是<code class="highlighter-rouge">${myVar}</code>，CMake并不要求变量在使用前被定义，对于没有定义的变量，其值为空字符串。</p>

<p>CMake可以将一个Variable变成<strong>Cache Variable</strong>，语法如下</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set</span><span class="o">(</span>varName value... CACHE <span class="nb">type</span> <span class="s2">"docstring"</span> <span class="o">[</span>FORCE]<span class="o">)</span>
</code></pre></div></div>
<p>被Cache的变量会保存到<code class="highlighter-rouge">CMakeCache.txt</code>中，它会存在于整个CMake构建周期中，并且对所有的CMake文件可见。这点和普通的variable不同，一般的variable的可见性和生命周期只限于该文件内。为了更好的理解，我们看一个例子</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>├── CMakeLists.txt
├── main.cpp
├── src1
│   └── CMakeLists.txt
└── src2
    └── CMakeLists.txt
</code></pre></div></div>
<p>在上述工程中，我们有一个root CMakeLists文件，和两个子CMakeLists文件，各自内容如下</p>

<div class="highlight md-flex-h md-margin-bottom-24">
<div>
<pre class="highlight language-shell md-no-padding-v md-height-full">
<code class="language-shell">
cmake_minimum_required(VERSION 3.5)
project(build_executable LANGUAGES CXX)

set(src "main.cpp")
set(ROOT "ROOT")
set(ROOT-CACHED "ROOT-CACHED" CACHE STRING "")
# set(VAR1 "var1" CACHE STRING "")
add_subdirectory(src1)
add_subdirectory(src2)
message(STATUS "[ROOT] ROOT: ${ROOT}")
message(STATUS "[ROOT] ROOT-CACHED: ${ROOT-CACHED}")
message(STATUS "[ROOT] SRC1: ${SRC1}")
message(STATUS "[ROOT] SRC2: ${SRC2}")
message(STATUS "[ROOT] SRC1-CACHED: ${SRC1-CACHED}")
message(STATUS "[ROOT] SRC2-CACHED: ${SRC2-CACHED}")

add_executable(hello ${src})
</code>
</pre>
</div>
<div class="md-margin-left-12">
<pre class="highlight language-shell md-no-padding-v md-height-full">
<code class="language-shell">
message(STATUS "[SRC1] ROOT: ${ROOT}")
set(ROOT "SRC1-ROOT")
set(ROOT-CACHED "SRC1-ROOT-CACHED" CACHE STRING "")
set(SRC1 "SRC1")
set(SRC1-CACHED "SRC1-CACHED" CACHE STRING "")
message(STATUS "[SRC1] ROOT: ${ROOT}")
message(STATUS "[SRC1] ROOT-CACHED: ${ROOT-CACHED}")
message(STATUS "[SRC1] SRC2-CACHED: ${SRC2-CACHED}")
</code>
</pre>
</div>
<div class="md-margin-left-12">
<pre class="highlight language-shell md-no-padding-v md-height-full">
<code class="language-shell">
message(STATUS "[SRC2] ROOT: ${ROOT}")
set(ROOT "SRC2-ROOT")
set(ROOT-CACHED "SRC2-ROOT-CACHED" CACHE STRING "")
set(SRC2 "SRC2")
set(SRC2-CACHED "SRC2-CACHED" CACHE STRING "")
message(STATUS "[SRC2] ROOT: ${ROOT}")
message(STATUS "[SRC2] ROOT-CACHED: ${ROOT-CACHED}")
message(STATUS "[SRC2] SRC1-CACHED: ${SRC1-CACHED}")
</code>
</pre>
</div>
</div>

<p>用CMake编译，输出如下</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">--</span> <span class="o">[</span>SRC1] ROOT: ROOT
<span class="nt">--</span> <span class="o">[</span>SRC1] ROOT: SRC1-ROOT
<span class="nt">--</span> <span class="o">[</span>SRC1] ROOT-CACHED: ROOT-CACHED
<span class="nt">--</span> <span class="o">[</span>SRC1] SRC2-CACHED: 
<span class="nt">--</span> <span class="o">[</span>SRC2] ROOT: ROOT
<span class="nt">--</span> <span class="o">[</span>SRC2] ROOT: SRC2-ROOT
<span class="nt">--</span> <span class="o">[</span>SRC2] ROOT-CACHED: ROOT-CACHED
<span class="nt">--</span> <span class="o">[</span>SRC2] SRC1-CACHED: SRC1-CACHED
<span class="nt">--</span> <span class="o">[</span>ROOT] ROOT: ROOT
<span class="nt">--</span> <span class="o">[</span>ROOT] ROOT-CACHED: ROOT-CACHED
<span class="nt">--</span> <span class="o">[</span>ROOT] SRC1: 
<span class="nt">--</span> <span class="o">[</span>ROOT] SRC2: 
<span class="nt">--</span> <span class="o">[</span>ROOT] SRC1-CACHED: SRC1-CACHED
<span class="nt">--</span> <span class="o">[</span>ROOT] SRC2-CACHED: SRC2-CACHED
</code></pre></div></div>

<p>从上面的结果我们能得到下面一些结论</p>

<ol>
  <li>父文件中的变量对子文件可见，反之则不行</li>
  <li>子文件中的Cache变量对父文件可见，对所有文件可见</li>
  <li>在子文件中修改父文件中的一般变量，仅对子文件有效，对父文件无效</li>
  <li>在子文件中修改父文件的Cache变量，对子文件无效，对父文件无效，除非使用<code class="highlighter-rouge">FORCE</code></li>
</ol>

<p>实际上Cache变量和普通变量根本上是两个不同的变量，很多时候我们会为它们取相同的名字，这造成了很多非常困惑的问题，比如下面情况</p>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://cliutils.gitlab.io/modern-cmake/modern-cmake.pdf">Modern CMake</a></li>
  <li><a href="https://www.youtube.com/watch?v=eC9-iRN2b04">Using Modern CMake Patterns to Enforce a Good Modular Design</a></li>
  <li><a href="https://www.youtube.com/watch?v=bsXLMQ6WgIk">Effective CMake</a></li>
  <li><a href="https://www.youtube.com/watch?v=y7ndUhdQuU8&amp;feature=youtu.be">More Modern CMake</a></li>
  <li><a href="http://aosabook.org/en/cmake.html">How CMake is implemented</a></li>
  <li><a href="https://www.amazon.com/CMake-Cookbook-Building-packaging-software/dp/1788470710/ref=sr_1_1?keywords=cmake&amp;qid=1579749929&amp;sr=8-1">CMake Cookbook</a></li>
  <li><a href="https://crascit.com/professional-cmake/">Professional CMake</a></li>
</ul>
:ET