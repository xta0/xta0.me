I"b<h2 id="同源策略">同源策略</h2>

<p>同源策略是指A网页设置的 Cookie，其它网页不能使用，除非这两个网页”同源”。所谓”同源”指的是”三个相同”: <mark>协议相同，域名相同，端口相同</mark>。同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>

<p>设想这样一种情况，用户在浏览A网站时，会读取用户登录Facebook留下的Cookie，然后拿着该Cookie去获取该用户的隐私数据等等。由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。
在同源策略下，在当前网页发送AJAX请求到非同源页面的行为是禁止的，比如我们随便打开一个网页，向Google发送一个HTTP的GET请求，该请求将会被禁止：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Failed to load https://www.google.com/:
No <span class="s1">'Access-Control-Allow-Origin'</span> header is present on the requested resource. 
</code></pre></div></div>

<p>随着互联网的发展，”同源政策”越来越严格。目前，如果非同源，共有三种行为受到限制。</p>

<ol>
  <li>Cookie、LocalStorage 和 IndexDB 无法读取。</li>
  <li>DOM 无法获得。</li>
  <li>AJAX 请求不能发送。</li>
</ol>

<p>虽然这些限制是必要的，但是有时很不方便，但有时合理的用途也受到影响，比如前后端分离后，前端页面调用后端的API就会遇到同源问题。</p>

<h3 id="cors跨域通信的基本原理">CORS跨域通信的基本原理</h3>

<p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向非同源的地址发送请求，从而克服了AJAX请求只能同源的问题。但实际操作起来却没那么简单，要完成CORS跨域，前端后端均需要配合改动，具体做法是在Request和Response Header中添加一些跨域协商信息，有时在请求之前还会多出一次附加请求用于协商跨域，因此，实现CORS通信的关键是服务器，只要服务器实现了CORS接口，就可以跨源通信。</p>

<p>为了便于理解，我们在本机模拟一个跨域场景，假设客户端网页地址为<code class="highlighter-rouge">127.0.0.1:5500</code>，本地Server的地址为<code class="highlighter-rouge">127.0.0.1:9000</code>，客户端向服务端发送GET请求，如下图所示</p>

<p><img class="md-img-center" src="/assets/images/2011/07/cors-1.png" /></p>

<p>由于Server的端口号不同，参照上一节的规则，客户端的GET请求将会触发跨域规则，浏览器会Block这次请求，并给出下面信息：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Failed to load http://127.0.0.1:9000/: 
No <span class="s1">'Access-Control-Allow-Origin'</span> header is present on the requested resource. 
Origin <span class="s1">'http://127.0.0.1:5500'</span> is therefore not allowed access.
</code></pre></div></div>

<p>此时客户端和服务端的代码都很简单，没有做任何跨域相关的配置：</p>

<div class="md-flex-h md-margin-bottom-24">
<div>
<pre class="highlight language-javascript md-no-padding-v md-height-full">
<code class="language-javascript">
//client
fetch('http://127.0.0.1:9000')
  .then(res =&gt; console.log(res))
  .catch(err =&gt; console.log(err));
</code>
</pre>
</div>
<div class="md-margin-left-12">
<pre class="highlight md-no-padding-v md-height-full">
<code class="language-python">
//server
const express = require('express');
const app = express();
app.get('/', (req, res) =&gt; {
  res.send('hello');
});
app.listen(9000);
</code>
</pre>
</div>
</div>

<p>接下来，我们可以讨论并实践如何使用CORS完成跨域请求</p>

<h3 id="两种请求">两种请求</h3>

<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求：</p>

<ol>
  <li>请求方法是以下三种方法之一：
    <ul>
      <li>HEAD</li>
      <li>GET</li>
      <li>POST</li>
    </ul>
  </li>
  <li>HTTP的头信息不超出以下几种字段：
    <ul>
      <li>Accept</li>
      <li>Accept-Language</li>
      <li>Content-Language</li>
      <li>Last-Event-ID</li>
      <li>Content-Type：只限于三个值<code class="highlighter-rouge">application/x-www-form-urlencoded</code>、<code class="highlighter-rouge">multipart/form-data</code>、<code class="highlighter-rouge">text/plain</code></li>
    </ul>
  </li>
</ol>

<p>凡是不同时满足上面两个条件，就属于非简单请求，浏览器对这两种请求的处理，是不一样的。</p>

<h3 id="简单请求">简单请求</h3>

<p>对于简单请求，浏览器直接发出CORS请求。具体来说，当浏览器识别出该请求是跨域请求后，检查该请求是否满足跨域请求的条件，如果满足则会在头部增加一个<code class="highlighter-rouge">Origin</code>字段。上面例子中，浏览器发出的请求Header如下：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET / HTTP/1.1
Host: 127.0.0.1:9000
Origin: http://127.0.0.1:5500
...
Connection: keep-alive
Pragma: no-cache
</code></pre></div></div>
<p>当服务端收到请求后，需要判断该<code class="highlighter-rouge">Origin</code>是否可被接受，如果可以接受则要在Response Header中告诉客户端，具体做法是在Header中增加<code class="highlighter-rouge">Access-Control-Allow-Origin</code>字段，并返回可接受的<code class="highlighter-rouge">Origin</code>。为了模拟这种情况，修改服务端代码如下：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">express</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">();</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">((</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">header</span><span class="p">(</span><span class="dl">'</span><span class="s1">Access-Control-Allow-Origin</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">http://127.0.0.1:5500</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">next</span><span class="p">();</span>
<span class="p">}</span>
<span class="nx">app</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">9000</span><span class="p">);</span>
</code></pre></div></div>
<p>在Header中加入该字段后，浏览器可成功执行跨域请求，报错消失。重新观察Request和Response的Header信息，与CORS有关的字段有</p>

<ul>
  <li><code class="highlighter-rouge">Access-Control-Allow-Origin</code> 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</li>
  <li><code class="highlighter-rouge">Access-Control-Allow-Credentials</code> 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</li>
</ul>

<p>如果想要浏览器带上Cookie，只有<code class="highlighter-rouge">Access-Control-Allow-Credentials:true</code>是不够的，客户端这边也需要做一定的处理来告诉浏览器可以携带Cookie</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">http://127.0.0.1:9000</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span><span class="na">credentials</span><span class="p">:</span> <span class="dl">'</span><span class="s1">include</span><span class="dl">'</span><span class="p">})</span>
</code></pre></div></div>
<p>此时可以看到客户端请求的Header中包含了Cookie值。需要注意的是，如果要发送Cookie，<code class="highlighter-rouge">Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名</p>

<h3 id="非简单请求">非简单请求</h3>

<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者<code class="highlighter-rouge">Content-Type</code>字段的类型是<code class="highlighter-rouge">application/json</code>。此时在正式通信之前，浏览器和Server之前会增加一次HTTP的OPTION请求，称为”preflight”。</p>

<p>我们继续修改上面的例子，在客户端请求的Header中增加<code class="highlighter-rouge">"Content-Type:application/json"</code>，此时客户端和Server在GET请求前会先发一次OPTIONS请求，交换跨域信息，Request header中多出了下面两个字段</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Access-Control-Request-Headers: content-type
Access-Control-Request-Method: GET
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">Access-Control-Request-Method</code> 该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是GET。</li>
  <li><code class="highlighter-rouge">Access-Control-Request-Headers</code> 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是<code class="highlighter-rouge">content-type</code></li>
</ul>

<p>如果要接受客户端的跨域请求，服务端也需要配合做相应的修改，其目的是告诉客户端自己可以接受哪些跨域操作：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">((</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">header</span><span class="p">(</span><span class="dl">'</span><span class="s1">Access-Control-Allow-Origin</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">http://127.0.0.1:5500</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">header</span><span class="p">(</span><span class="dl">'</span><span class="s1">Access-Control-Allow-Methods</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">GET</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">header</span><span class="p">(</span><span class="dl">'</span><span class="s1">Access-Control-Allow-Headers</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1"> Content-Type</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">next</span><span class="p">();</span>
<span class="p">});</span>
</code></pre></div></div>
<ul>
  <li><code class="highlighter-rouge">Access-Control-Allow-Methods</code>
  该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”Preflight”请求。</li>
  <li><code class="highlighter-rouge">Access-Control-Allow-Headers</code>
  如果浏览器请求包括A<code class="highlighter-rouge">ccess-Control-Request-Headers</code>字段，则<code class="highlighter-rouge">Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</li>
</ul>

<p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个<code class="highlighter-rouge">Origin</code>头信息字段。服务器的回应，也都会有一个<code class="highlighter-rouge">Access-Control-Allow-Origin</code>头信息字段。在跨域信息沟通完成后，接下来客户端便可以向服务端发送GET请求来获取数据。</p>

<h2 id="csrfxsrf">CSRF/XSRF</h2>

<p>CSRF指的是跨站点请求伪造(Cross-Site Request Forgery)，其本质是利用身份校验的漏洞进行攻击。考虑下面一个场景，用户Alice登录某银行网站后，进行转账操作，form表单地址为<code class="highlighter-rouge">somebank.com/transfer</code>，请求为POST，当银行server收到这个请求后，服务器会根据cookie验证该请求是否来自一个合法的session。假设有一个恶意用户Bob，了解该银行系统的API设计，于是他伪造了一个A的转账请求，将转账对象改为自己，但由于Bob无法得到Alice的cookie信息，进而服务端session校验失败，因此该伪造的请求并未成功。这时，Bob为了获取A的cookie信息，做了一个钓鱼网站，诱导用户Alice点击了某个button，随后便触发了一段脚本：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">myFunction</span><span class="p">(</span><span class="nx">event</span><span class="p">){</span>
    <span class="kd">const</span> <span class="nx">url</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">http://somebank.com/transfer</span><span class="dl">'</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">name=Bob&amp;amount=1000</span><span class="dl">"</span><span class="p">;</span>
    <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">,{</span>
            <span class="na">method</span><span class="p">:</span><span class="dl">"</span><span class="s2">POST</span><span class="dl">"</span><span class="p">,</span>
            <span class="na">headers</span><span class="p">:{</span>
                <span class="dl">"</span><span class="s2">Content-Type</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">application/x-www-form-urlencoded; charset=utf-8</span><span class="dl">"</span>
            <span class="p">},</span>
            <span class="na">credentials</span><span class="p">:</span> <span class="dl">'</span><span class="s1">include</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">body</span><span class="p">:</span><span class="nx">data</span>
        <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>
<p>该脚本会向银行系统发出转账请求，转账对象为<code class="highlighter-rouge">Bob</code>, 转账金额为<code class="highlighter-rouge">1000</code>。 大多数情况下，该请求会失败，因为他要求Alice的认证信息。但是，如果Alice次时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的cookie之中含有Alice的认证信息。此时，上述POST请求很容易通过银行的校验，从而完成对Bob的转账。等以后Alice发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。</p>

<p>透过例子能够看出，攻击者并不能通过CSRF攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是骗用户浏览器来获取用户cookie，模拟用户操作。</p>

<h3 id="检查referer字段">检查Referer字段</h3>

<p>HTTP头中有一个<code class="highlighter-rouge">Referer</code>字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，<code class="highlighter-rouge">Referer</code>字段应和请求的地址位于同一域名下。以上文银行操作为例，<code class="highlighter-rouge">Referer</code>字段地址通常应该是转账按钮所在的网页地址，应该也位于<code class="highlighter-rouge">somebank.com</code>之下。而如果是CSRF攻击传来的请求，<code class="highlighter-rouge">Referer</code>字段会是包含恶意网址的地址，不会位于<code class="highlighter-rouge">somebank.com</code>之下，这时候服务器就能识别出恶意的访问。</p>

<p>然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。</p>

<p>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p>

<h3 id="使用token">使用Token</h3>

<p>另一个防御措施是改变用户的校验规则，CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>

<h3 id="xss">XSS</h3>

<p>XSS(Cross-site Scripting)是一种代码注入技术，恶意攻击者往Web页面里插入恶意javaScript代码，当用户浏览该页之时，嵌入其中Web里面的javaScript代码会被执行，从而达到恶意攻击用户的目的。</p>

<h2 id="password">Password</h2>

<p>最后讨论一下如何存储Password的问题，保存用户密码的策略和上一篇文章中介绍计算Cookie的策略类似，都是使用哈希函数，对明文密码 + 一个随机数（salt）进行hash</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">string</span>

<span class="k">def</span> <span class="nf">make_salt</span><span class="p">():</span>
    <span class="n">seed</span> <span class="o">=</span> <span class="s">"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$</span><span class="si">%</span><span class="s">^&amp;*()_+=-"</span>
    <span class="n">sa</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">salt</span><span class="o">=</span><span class="s">''</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="n">sa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">seed</span><span class="p">))</span>
    <span class="n">salt</span> <span class="o">=</span> <span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sa</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">salt</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">make_salt</span><span class="p">())</span>
<span class="n">vZMV1</span>
</code></pre></div></div>
<p>上述代码可以生成5个字符的随机字符串, 用该字符串对密码进行加密，密码加密以及用户登录校验密码的逻辑如下</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">make_pwd_hash</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">pwd</span><span class="p">,</span><span class="n">salt</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">salt</span><span class="p">:</span>
        <span class="n">salt</span> <span class="o">=</span> <span class="n">make_salt</span><span class="p">()</span>
    <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="n">pwd</span><span class="o">+</span><span class="n">salt</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">'utf-8'</span><span class="p">)</span>
    <span class="n">hash_code</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha256</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">f</span><span class="s">"{hash_code},{salt}"</span>

<span class="c1">#check user password
#hash_code comes from database
</span><span class="k">def</span> <span class="nf">valid_pw</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">pw</span><span class="p">,</span><span class="n">hash_code</span><span class="p">):</span>
    <span class="n">salt</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">h</span> <span class="o">==</span> <span class="n">make_pwd_hash</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">pwd</span><span class="p">,</span><span class="n">salt</span><span class="p">)</span>
</code></pre></div></div>
<p>在密码的加密算法上，sha256比较慢，可以选择使用bcrypt。许多成熟的web framework均自带<code class="highlighter-rouge">bcrypt</code>方法。</p>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://www.w3.org/Security/wiki/Same_Origin_Policy">Same Origin Policy</a></li>
  <li><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">浏览器同源政策及其规避方法</a></li>
  <li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享CORS详解</a></li>
  <li><a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/index.html">CSRF 攻击的应对之道</a></li>
  <li><a href="https://auth0.com/learn/json-web-tokens/">Learn JSON Web Tokens</a></li>
</ul>
:ET