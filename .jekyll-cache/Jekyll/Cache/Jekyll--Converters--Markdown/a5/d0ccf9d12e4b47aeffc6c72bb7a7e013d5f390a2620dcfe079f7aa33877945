I"<h2 id="动态索引">动态索引</h2>

<p>动态索引主要用于处理索引结构本身可能发生变化的场景，比如数据库中的primary key可能会频繁插入，删除，造成索引结构的频繁更新。建立动态索引的目的视为了保持较好的查询性能，提高检索效率。常用的动态索引结构有B/B+树，红黑树等。</p>

<h3 id="b树">B树</h3>

<p>B树是R.Bayer和E.MacCreight在1970年提出的一种平衡的多路查找树。所谓的多路搜索树和前面提到的二路搜索树实际上是等价的，只需要将BST的父节点和子节点进行合并即可得到B树的节点。例如下图中，将BST的根节点和两个子节点进行“两代”合并：</p>

<p><img class="md-img-center" src="/assets/images/2010/09/b-tree-2.png" width="80%" /></p>

<p>可见经过“父子”2代的合并，可以得到4路B树，其中每个节点有3个Key值，类似的:</p>

<ol>
  <li>每<code class="highlighter-rouge">3</code>代合并，可得<code class="highlighter-rouge">8</code>路B树，每个节点有<code class="highlighter-rouge">7</code>个关键码</li>
  <li>每<code class="highlighter-rouge">d</code>代合并，可得到<code class="highlighter-rouge">m=2^d</code>路，每个节点有<code class="highlighter-rouge">m-1</code>个关键码</li>
</ol>

<p>正如开篇提到的，B树适合对频繁操作的数据进行动态索引，其原因是什么呢？ 如果使用前面介绍的AVL树查询，由于其具有自平衡性，其性能也应该不会太差，那为什么不用AVL树做动态索引呢？我们可以看一个具体例子：</p>

<p>假如我们有个1G的文件记录，我们需要查找其中的某一个，如果不允许将文件读入内存，则使用AVL树需要<code class="highlighter-rouge">log(2,2^30) = 30</code>次I/O查询操作。如果使用B树，则一次I/O可读取一组关键码，对于多数的数据库系统，通常可以支持<code class="highlighter-rouge">m=256</code>，那么回到上面问题中，使用B树一次I/O可以读入256个关键码，因此只需要查询<code class="highlighter-rouge">log(256,2^30) &lt;= 4</code>次I/O即可。</p>

<h3 id="b树的定义">B树的定义</h3>

<p>任何B树都有一个固定的指标，就是它的阶次，用<code class="highlighter-rouge">m</code>表示。所谓<code class="highlighter-rouge">m</code>阶B树，即<code class="highlighter-rouge">m</code>路平衡搜索树(<code class="highlighter-rouge">m&gt;=2</code>)，它有如下性质</p>

<ol>
  <li>所有叶节点的深度是一致的，是一种理想平衡的搜索树</li>
  <li>如果每个节点有<code class="highlighter-rouge">n</code>个关键码（n&lt;=m-1），则每个节点最多有<code class="highlighter-rouge">n+1</code>个分支</li>
  <li>每个节点对应的分支数都不能超过<code class="highlighter-rouge">m</code>个，所含关键码的个数不能超过<code class="highlighter-rouge">m-1</code>个（上限）</li>
  <li>每个节点对应的分支数不能少于 $\lceil {m/2} \rceil$ 个，其中根节点可以例外（下限）</li>
  <li>B树的命名规则为 $ (\lceil {m/2} \rceil, m)$树</li>
</ol>

<p>例如下图中的B树也叫做<code class="highlighter-rouge">2-3</code>树，其<code class="highlighter-rouge">m=3</code>，也叫3阶B树，根据上面的规则，每个节点的关键码最多为<code class="highlighter-rouge">m-1=2</code>个，每个节点的分支数上限为<code class="highlighter-rouge">m=3</code>，下限为<code class="highlighter-rouge">m/2=2（上取整）</code>个</p>

<p><img class="md-img-center" src="/assets/images/2008/09/B-Tree-1.png" width="80%" /></p>

<h3 id="b树的表示">B树的表示</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BTNode</span><span class="p">{</span>
    <span class="n">BTNode</span><span class="o">*</span> <span class="n">parent</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">key</span><span class="p">;</span> <span class="c1">//存放key</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">BTNode</span><span class="o">*</span> <span class="o">&gt;</span><span class="n">children</span><span class="p">;</span> <span class="c1">//存放子节点</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="查找操作">查找操作</h3>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://www.youtube.com/watch?v=NcZ2cu7gc-A&amp;list=PLnfg8b9vdpLn9exZweTJx44CII1bYczuk">CS106B-Stanford-YouTube</a></li>
  <li><a href="https://www.coursera.org/learn/algorithms-divide-conquer/home/welcome">Algorithms-Stanford-Cousera</a></li>
  <li><a href="https://www.coursera.org/learn/shuju-jiegou-suanfa/home/welcome">算法与数据结构-1-北大-Cousera</a></li>
  <li><a href="https://www.coursera.org/learn/gaoji-shuju-jiegou/home/welcome">算法与数据结构-2-北大-Cousera</a></li>
  <li><a href="https://courses.edx.org/courses/course-v1:TsinghuaX+30240184.1x+3T2017/course/">算法与数据结构-1-清华-EDX</a></li>
  <li><a href="https://courses.edx.org/courses/course-v1:PekingX+04833050X+1T2016/course/">算法与数据结构-2-清华-EDX</a></li>
  <li><a href="https://www.coursera.org/learn/algorithms/home/welcome">算法设计与分析-1-北大-Cousera</a></li>
  <li><a href="https://courses.edx.org/courses/course-v1:PekingX+04833050X+1T2016/course/">算法设计与分析-2-北大-EDX</a></li>
</ul>

:ET