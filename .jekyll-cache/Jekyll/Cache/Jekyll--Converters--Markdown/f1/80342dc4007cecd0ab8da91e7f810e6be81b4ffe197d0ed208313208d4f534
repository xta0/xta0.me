I"\1<p>我们继续讨论动态库的问题，接下来我们将把关注点放在符号的可见性问题上。符号的可见性对于动态库至关重要，在Linux系统中，默认情况下，动态库的符号都是全局可见的，但实际应用中，我们往往希望隐藏掉不必要的符号，因此，我们需要一些手段来控制符号的可见性</p>

<h3 id="符号的可见性问题">符号的可见性问题</h3>

<p>我们还是以一个例子来看符号可见性的问题，假如我们有下面代码</p>

<div class="highlight md-flex-h md-margin-bottom-24">
<div>
<pre class="highlight language-cpp md-no-padding-v md-height-full">
<code class="language-cpp">
//a.c
int myintvar = 5;
 
int func0 () {
  return ++myintvar;
}
 
int func1 (int i) {
  return func0() * i;
}
</code>
</pre>
</div>
<div class="md-margin-left-12">
<pre class="highlight language-cpp md-no-padding-v md-height-full">
<code class="language-cpp">
//main.cpp
extern int myintvar;
int main(){
    printf("%d",myintvar); 
}
</code>
</pre>
</div>
</div>

<p>我们将<code class="highlighter-rouge">a.c</code>编译为动态库，并查看其中的符号</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> clang <span class="nt">-fPIC</span> <span class="nt">-shared</span> a.c <span class="nt">-o</span> a.so
<span class="o">&gt;</span> nm a.so

0000000000000f70 T _func0
0000000000000f90 T _func1
0000000000001000 D _myintvar
                 U dyld_stub_binder
</code></pre></div></div>

<p>我们发现三个符号的类型均为大写字母T或D，说明他们是global的符号，全局可见。 因此我们的<code class="highlighter-rouge">main</code>函数可以打印出<code class="highlighter-rouge">5</code>。</p>

<p>如果我们想要隐藏<code class="highlighter-rouge">a.so</code>中的所有符号，只需要加上<code class="highlighter-rouge">-fvisibility=hidden</code>的Compiler flag即可，此时<code class="highlighter-rouge">a.so</code>中的所有符号都变成了不可见</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> clang <span class="nt">-fPIC</span> <span class="nt">-shared</span> <span class="nt">-fvisibility</span><span class="o">=</span>hidden a.c <span class="nt">-o</span> a.so
<span class="o">&gt;</span> nm a.so

0000000000000f70 t _func0
0000000000000f90 t _func1
0000000000001000 d _myintvar
                 U dyld_stub_binder
</code></pre></div></div>

<p>由于这种方式会一次性hide掉所有符号，因此不够灵活，假如我们的动态库只需要导出<code class="highlighter-rouge">func1</code>，而隐藏<code class="highlighter-rouge">func0</code>和<code class="highlighter-rouge">myintvar</code>，该怎么做呢？我们至少有三种方法，包括使用<code class="highlighter-rouge">static</code>关键字，定义符号的<code class="highlighter-rouge">GNU visibility</code>，以及使用exported symbol list。每种方式都有各自的优缺点，我们接下来一一讨论</p>

<h3 id="使用static关键字">使用static关键字</h3>

<p>在C/C++中被<code class="highlighter-rouge">static</code>声明的变量符号类型会变成local，也就是说禁止该符号被外部链接，则编译器不会为该符号生成任何信息，因此这种方式是一种最简单的方式，我们修改<code class="highlighter-rouge">a.c</code>如下</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="n">myintvar</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
 
<span class="k">static</span> <span class="kt">int</span> <span class="nf">func0</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">++</span><span class="n">myintvar</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">func1</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">func0</span><span class="p">()</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>重新编译动态库，并查看符号表</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> clang <span class="nt">-fPIC</span> <span class="nt">-shared</span> a.c <span class="nt">-o</span> a.so
<span class="o">&gt;</span> nm a.so

0000000000000fa0 t _func0
0000000000000f80 T _func1
0000000000001000 d _myintvar
                 U dyld_stub_binder

</code></pre></div></div>

<p>我们发现<code class="highlighter-rouge">_func0</code>和<code class="highlighter-rouge">_myintvar</code>的符号类型变成了小写的<code class="highlighter-rouge">t</code>和<code class="highlighter-rouge">d</code>，说明这两个符号变成了<code class="highlighter-rouge">local</code>的。</p>

<p>虽然<code class="highlighter-rouge">static</code>可以隐藏符号，但是它同样限制了符号的作用域，<code class="highlighter-rouge">func0</code>和<code class="highlighter-rouge">myintvar</code>只可以在<code class="highlighter-rouge">a.c</code>中使用，即被<code class="highlighter-rouge">static</code>修饰的符号，只可在定义它们的文件中使用。我们来看一个例子，假设我有个<code class="highlighter-rouge">b.c</code>如下</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="kt">int</span> <span class="n">myintvar</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">func2</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">myintvar</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>它依赖<code class="highlighter-rouge">a.c</code>中的全局变量<code class="highlighter-rouge">myintvar</code>，当我们将<code class="highlighter-rouge">a.c</code>和<code class="highlighter-rouge">b.c</code>一起编译为一个动态库时，<code class="highlighter-rouge">b.c</code>将无法看到<code class="highlighter-rouge">myintvar</code>这个符号，因为它只对<code class="highlighter-rouge">a.c</code>可见</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> clang <span class="nt">-fPIC</span> <span class="nt">-shared</span> a.c b.c <span class="nt">-o</span> lib.so
Undefined symbols <span class="k">for </span>architecture x86_64:
  <span class="s2">"_myintvar"</span>, referenced from:
      _func2 <span class="k">in </span>b-ad7f57.o
ld: symbol<span class="o">(</span>s<span class="o">)</span> not found <span class="k">for </span>architecture x86_64
</code></pre></div></div>

<p>小结一下，使用<code class="highlighter-rouge">static</code>这种方式更多的是用于控制文件内的符号可见性，而不用于控制低级别的符号可见性。实际上，大多数函数或者变量不会依赖于static来控制符号可见性。</p>

<h3 id="使用visibility关键字">使用<code class="highlighter-rouge">visibility</code>关键字</h3>

<p>更常用的方法是使用GNU的visibility关键字，常用的有两个</p>

<ul>
  <li><code class="highlighter-rouge">default</code>，符号将被导出，默认可见</li>
  <li><code class="highlighter-rouge">hidden</code>，符号不被导出，不能被其它对象使用</li>
</ul>

<p>我们修改<code class="highlighter-rouge">a.c</code>的代码如下</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">myintvar</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">visibility</span> <span class="p">(</span><span class="s">"hidden"</span><span class="p">)));</span>
<span class="kt">int</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">visibility</span> <span class="p">(</span><span class="s">"hidden"</span><span class="p">)))</span> <span class="n">func0</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">++</span><span class="n">myintvar</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>重新编译动态库并查看其符号</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> clang <span class="nt">-fPIC</span> <span class="nt">-shared</span> a.c a.so
<span class="o">&gt;</span> nm a.so

0000000000000f70 t _func0
0000000000000f90 T _func1
0000000000001000 d _myintvar
                 U dyld_stub_binder
</code></pre></div></div>
<p>可见其符号类型和上面一样，<code class="highlighter-rouge">myintvar</code>以及<code class="highlighter-rouge">_fun0</code>变成了local的。不同的是，<code class="highlighter-rouge">_myintvar</code>此时对所有动态库源文件可见(前面的<code class="highlighter-rouge">b.c</code>)。实际上，隐藏的符号(<code class="highlighter-rouge">_myintvar</code>,<code class="highlighter-rouge">_func0</code>)将不会出现在动态符号表中，但是还被保留在符号表中用于做静态链接。</p>

<blockquote>
  <p>注意，对于用 visibility 属性指定的变量，将它声明为 static 可能会让编译器感到混淆</p>
</blockquote>

<h3 id="使用symbol-list">使用Symbol List</h3>

<p>在前面静态库的文章中，我们曾使用过符号表来告诉Linker保留哪些符号。对于符号的可见性，我们同样可以通过Symbol list来控制。具体来说，对于上面例子，我们可以使用下面的列表</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//exportmap.map
<span class="o">{</span>
  global: func1<span class="p">;</span>
  <span class="nb">local</span>: <span class="k">*</span><span class="p">;</span>
<span class="o">}</span><span class="p">;</span>
</code></pre></div></div>

<p>接下来我们将<code class="highlighter-rouge">a.c</code>编译为动态库，并查看其symbol</p>

<blockquote>
  <p>注意，这一部分我们将编译器从clang变回gcc，因为clang不支持version script</p>
</blockquote>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> gcc <span class="nt">-shared</span> <span class="nt">-o</span> mylib.so a.c <span class="nt">-fPIC</span> <span class="nt">-Wl</span>,--version-script<span class="o">=</span>exportmap.map
<span class="o">&gt;</span> nm mylib.so

0000000000201024 b __bss_start
...
0000000000000590 t func0
00000000000005b4 T func1
...
0000000000201020 d myintvar
</code></pre></div></div>
<p>我们看到只有<code class="highlighter-rouge">func1</code>是global的，说明符号表起到了作用</p>

<h3 id="符号的覆盖">符号的覆盖</h3>

<p>此时如果有另一个文件<code class="highlighter-rouge">b.c</code>中有这样一行代码</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">myintvar</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></div></div>
<p>那么我们将<code class="highlighter-rouge">b.c</code>,<code class="highlighter-rouge">a.so</code>一起和<code class="highlighter-rouge">main.c</code>进行编译，并观察输出结果</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> clang a.so b.c main.c
<span class="o">&gt;</span> ./a.out //10
</code></pre></div></div>
<p>我们发现输出结果为10，也就是说动态库中的符号被覆盖掉了。</p>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://www.amazon.com/Linkers-Kaufmann-Software-Engineering-Programming/dp/1558604960">Linkers and Loaders</a></li>
  <li><a href="https://www.amazon.com/Advanced-C-Compiling-Milan-Stevanovic/dp/1430266678">Advanced C and C++ compiling</a></li>
</ul>
:ET