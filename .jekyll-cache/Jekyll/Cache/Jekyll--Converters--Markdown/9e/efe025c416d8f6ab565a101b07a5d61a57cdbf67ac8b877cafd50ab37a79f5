I"0<p>排查内存问题，是每个项目都会遇到的。几个项目下来，总结下经验：</p>

<ul>
  <li>要了解iOS内存模型的基本概念，懂了这些才能更有效的debug。</li>
  <li>需要学习一些使用Instrument调试的技巧。</li>
  <li>深入到内核看一看内存是如何分配的，能否从内核的角度来优化内存的分配和使用</li>
</ul>

<p>本文主要讨论是第一点</p>

<h3 id="虚拟内存与常驻内存">虚拟内存与常驻内存</h3>

<p>首先我们从寻址开始。iOS设备CPU是32位，因此寻址空间为：<code class="highlighter-rouge">0x00000000 ~ 0xffffffff</code>，例如一个指针地址为<code class="highlighter-rouge">0x8031 fea0</code>，将其每一位展开得到 <code class="highlighter-rouge">1000 0000 0011 0001 1111 1110 1010 0000</code>为32bit。</p>

<p>而<code class="highlighter-rouge">2^32 = 4Gb</code>，理论上可以寻址4GB的空间，这个范围远大于设备的物理内存：iPhone4/4S的内存为<code class="highlighter-rouge">512MB</code>，iPhone5的内存为<code class="highlighter-rouge">1G</code>。多出的部分怎么处理？</p>

<ul>
  <li>虚拟内存</li>
</ul>

<p>操作系统的RAM有限，所有进程分配的内存总量会超过系统的RAM数量，于是才会有虚拟内存，虚拟内存是中逻辑上的内存，它保证了进程的地址空间不受RAM数量的限制，每个进程都假设自己拥有全部的RAM:寻址范围从<code class="highlighter-rouge">0x00000000~0xffffffffff</code>。有了虚拟内存，操作系统可以使用硬盘来缓存RAM中无法保存的数据。但使用虚拟内存带来的一个问题是：进程使用的内存地址与物理RAM并不对应，也就是说我们程序中看到的内存地址并不是物理地址，而是虚拟内存地址。这就需要内核做一个从虚拟内存到物理RAM的映射。</p>

<blockquote>
  <p>注意iOS中没有内存置换的技术，本节讨论的是一般的操作系统，比如OSX或者Windows</p>
</blockquote>

<p>回忆我们以前学的微机原理，内存是按照4KB为一帧被划分开。虚拟内存同样按照4KB为一页来划分，每页的字节数与每帧的字节数始终相同。这样便可以将进程中的每页无缝映射到物理RAM中的每帧。WWDC的这张图说明了上面的过程：</p>

<p><a href="/assets/images/2014/01/virtual_mem.png"><img src="/assets/images/2014/01/virtual_mem.png" alt="virtual_mem" width="625" height="342" /></a></p>

<p>虚拟内存这么划分的好处是，可以将进程中连续的地址空间映射到物理RAM中不连续的地址空间中，这可以最大限度节省内存碎片的产生。因此，当一个进程启动时，OS会创建一张表，来保存虚拟内存到物理RAM的映射关系，这个表被成为“分页表”，类似windows中的HANDLE。然后我们讨论两种情况：</p>

<ul>
  <li>当RAM被写满后怎么办？</li>
</ul>

<p>在OS X中，会将某些不活跃的帧存到磁盘。但是在iOS中，由于没有内存置换技术，系统会直接将某些不活跃的帧清空！也就是进程在后台被系统杀死了，这主要是由于RAM和磁盘进行数据交换会极大的影响性能。</p>

<ul>
  <li>如果进程访问的地址找不到怎么办？</li>
</ul>

<p>如果OS确定进程访问的地址是错误的，则报错，终止进程；如果进程访问的地址被保存到了硬盘上，OS首先分配一帧，用来保存请求页。如果当前没有可用帧，将现有帧缓存到磁盘，腾出空间。然后将请求页读到内存中，更新进程的页表，最后将控制权返回给进程。</p>

<p>Resident Memory是进程的virtual memory中常驻在物理RAM中的部分。</p>

<h3 id="heap和stack">Heap和Stack</h3>

<p>mike ash的<a href="https://www.mikeash.com/pyblog/friday-qa-2010-01-15-stack-and-heap-objects-in-objective-c.html">这篇文章</a>总结的很详细。除了在Heap上创建的Object，还有很多看不到的内存被占用，比如：layer的backing store；代码段和常量段<code class="highlighter-rouge">(__TEXT,__DATA)</code>，<code class="highlighter-rouge">Thread stack</code>，图片数据，cache等等。</p>

<h3 id="memory-footprint">Memory Footprint</h3>

<p>操作系统中的内存按页分布，一般来说每个Page的大小为16KB，我们平时分配的heap object都存放在Page中，一个Page上可以存放多个Object，如果Object大小很大，比如NSData，那么该对象可能同时占用多个page。系统占用内存的大小可以用下面式子计算：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Memory in use = Number of pages x page size
</code></pre></div></div>
<p>例如下面代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">20000</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">array</span><span class="p">[</span><span class="mi">19999</span><span class="p">]</span> <span class="o">=</span> <span class="mi">64</span>
</code></pre></div></div>
<p>上面代码中假设一个<code class="highlighter-rouge">int</code>为<code class="highlighter-rouge">4</code>字节，那么我们一共在heap上分配了约<code class="highlighter-rouge">80k</code>大小的空间，此时系统会给我们<code class="highlighter-rouge">6</code>个page约为<code class="highlighter-rouge">96k</code>。当这个6个page被分配给我们的时候，每个page都是clean的，但是一旦某个page中有数据写入，则这个page就变成了dirty，例如上面代码中<code class="highlighter-rouge">array[0]=32</code>会将page#0变为dirty状态，<code class="highlighter-rouge">array[19999]=64</code>会将page#6变为dirty，如下图所示：</p>

<p><img class="md-img-center" src="/assets/images/2012/07/memory-1.png" /></p>

<blockquote>
  <p>对于Clean和Dirty Memory的概念我们后面讨论。</p>
</blockquote>

<p>通常对于一个进程内的App，其内存的结构如下：</p>

<p><img class="md-img-center" src="/assets/images/2012/07/memory-2.png" /></p>

<p>对于操作系统分配的每个page，其内存类型可分为两种，Clean和Dirty</p>

<h3 id="clean-memory">Clean Memory</h3>

<p>通常来说，Clean Memory是<mark>只读</mark>的，比如被加载到内存中的应用程序的二进制代码，常量段（<code class="highlighter-rouge">__TEXT</code>段），系统的各种framework代码和资源，上面提到的分页表（memory-mapped files）等，clean内存在memory warning的时候可以被discard掉，然后recreate出来。例如, JPEG图片被加载到内存中时，用的就是<code class="highlighter-rouge">mmap</code>，是Clean Memory，系统可以对其进行回收。</p>

<h3 id="dirty-memory">Dirty Memory</h3>

<p>与Clean Memory相对应的是Dirty Memory，指的是应用程序可以写的那部分内存，或者说是用来保存应用程序产生的数据。它包括Heap上分配对象的控件，<code class="highlighter-rouge">UIImage，Caches</code>等。Dirty Memory在内存紧张时会被清空。</p>

<p>对于Clean和Dirty Memory，我们看几个例子：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NSString</span><span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithUTF8String</span><span class="p">:</span><span class="s">"welcome"</span><span class="p">];</span>
</code></pre></div></div>

<p>这属于动态分配在heap上变量，为dirty memory，会被回收,但是</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NSString</span><span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="s">@"welcome"</span><span class="p">;</span>
</code></pre></div></div>
<p>是clean的，因为这个字符串在编译的时候会被存放在程序代码段中的read-only的常量区</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UIImage</span><span class="o">*</span> <span class="n">wwdcLogo</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nf">imageNamed</span><span class="p">:</span><span class="s">@"WWDC12logo"</span><span class="p">];</span>
</code></pre></div></div>
<p>由于<code class="highlighter-rouge">UIImage</code>是decompress出来的data，是dirty memory</p>

<h3 id="memory-warning">Memory Warning</h3>

<p>当我们的app在前台运行时，不断消耗内存，导致内存不足时，系统首先会将不用的clean memroy干掉一部分，腾出空间来继续创建drity memory，当dirty memory越来越多，又导致内存不足时，系统会将运行在后台app的dirty memory干掉，然后将之前干掉的clean memory重新load回来。</p>

<p>注意，Memory Warning也可以被系统触发，比如当内存紧张时，接到电话时，可能会触发内存警告。</p>

<h3 id="compress-memory">Compress Memory</h3>

<p>由于iOS中没有memory swap技术，无法时用硬盘资源来置换内存，因此当资源紧张时，需要新的手段来提高内存资源利用率。Compress Memory是iOS 7之后引入的内存压缩技术，它可以将没有被访问的内存对象所在的Page进行压缩(Compresses unaccessed pages )，从而腾出更多的空间。如果程序在某个时刻要访问被压缩的对象，则再将该对象所在的Page进行Decompression（Decompresses pages upon access）。</p>

<p>这就会引发一个很有趣的问题，假设我们用一个<code class="highlighter-rouge">NSDictionary</code>进行图片缓存，当程序运行一段时间后，它的大小为4个page，通常来说，当收到<code class="highlighter-rouge">memoryWarning</code>后，我们会释放该缓存中的数据，代码如下：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">override</span> <span class="kd">func</span> <span class="nf">didReceiveMemoryWarning</span><span class="p">()</span> <span class="p">{</span>
 <span class="n">cache</span><span class="o">.</span><span class="nf">removeAllObjects</span><span class="p">()</span>
 <span class="k">super</span><span class="o">.</span><span class="nf">didReceiveMemoryWarning</span><span class="p">()</span>
<span class="p">}</span> 
</code></pre></div></div>

<p>如果在Compress Memory的场景下，<code class="highlighter-rouge">cache</code>已经被压缩了，大小从4个page减小到了1个page，而此时在收到内存警告时访问它则会触发其Decompression，反而会将其大小从1个page恢复到4个page。当回复完成后，又释放其空间，大小又回到了1个page，显然这中间有着不必要的内存开销。解决办法是使用<code class="highlighter-rouge">NSCache</code>，<code class="highlighter-rouge">NSCache</code>不仅线程安全，而且对内存警告和内存压缩均作了优化。</p>

<h3 id="private和shared-memroy">Private和Shared Memroy</h3>

<p>RAM中可以被多个进程共享的部分称为Shared Memory，比如系统的framework，它只映射一份代码到内存，这部分内存会被不同的进程共用。而每个进程单独alloc的内存，则是Private Memory。</p>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://manybutfinite.com/post/anatomy-of-a-program-in-memory/">Anatomy of a program in memory</a></li>
  <li><a href="https://developer.apple.com/videos/play/wwdc2013/410/">WWDC2013 - 410</a></li>
  <li><a href="https://developer.apple.com/videos/play/wwdc2018/416/">WWDC2018 - 416_ios_memory_deep_dive</a></li>
</ul>
:ET