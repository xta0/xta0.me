I"?<h3 id="memory-model">Memory Model</h3>

<p>基本上所有语言的变量内存模型都类似，如果习惯了使用静态语言或者偏底层一点的语言，对这个概念应该不陌生，它就是一块用存放某个对象的内存区域。对象创建方式的不同会导致变量在内存中分配位置的不同，比如C++中有栈对象和堆对象，这点在C++中很容易区分，分配在堆上的对象可以用指针索引，分配在栈上的对象按变量名索引。而现在的绝大部分的脚本语言淡化了这个概念，使得有时候搞不清楚变量到底是在哪里创建的，为什么这个问题如此重要呢？因为它关系到一些很重要的问题，比如拷贝控制，生命周期，内存回收等等。</p>

<p><img src="/assets/images/2016/08/dpy-1.png" width="60%" /></p>

<p>对于Python来说，它的对象是在堆上创建的，变量名相当于指针或者是引用。Python提供了一个函数<code class="highlighter-rouge">id()</code>可以查看对象的内存地址</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span>
<span class="k">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span> <span class="c1">#0x107e2bb90
</span></code></pre></div></div>
<p>既然Python的对象都是分配在堆上，那么它就需要处理好指针的管理问题，对于指针来说，有两个重要的问题，分别是引用计数管理和内存回收问题</p>

<h3 id="reference-count">Reference Count</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_var</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">other_var</span> <span class="o">=</span> <span class="n">my_var</span>
</code></pre></div></div>
<p>上述代码如果C++中，它的行为是拷贝，也就是说<code class="highlighter-rouge">other_var</code>有自己的一片内存空间，值为<code class="highlighter-rouge">10</code>，而对于python来说，既然是指针索引，那么内存中只有一份<code class="highlighter-rouge">10</code>，<code class="highlighter-rouge">my_var</code>和<code class="highlighter-rouge">other_var</code>都是这片内存的引用，因此指针的引用计数为2。没错，Python也是使用引用计数的，引用计数可以通过系统的API查看</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">sys</span><span class="o">.</span><span class="n">getrefcount</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1">#2
</span></code></pre></div></div>
<p>但是如果使用该API查看，<code class="highlighter-rouge">a</code>的引用计数并不准确，因为<code class="highlighter-rouge">a</code>做参数传递过去，其引用计数会自动+1，因此更精确的做法是使用下面的API，传递地址而非变量</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">import</span> <span class="n">ctypes</span>
<span class="n">def</span> <span class="n">ref_count</span><span class="p">(</span><span class="n">address</span><span class="o">:</span><span class="kt">int</span><span class="p">)</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">ctypes</span><span class="p">.</span><span class="n">c_long</span><span class="p">.</span><span class="n">from_address</span><span class="p">(</span><span class="n">address</span><span class="p">).</span><span class="n">value</span> 

<span class="n">ref_count</span><span class="p">(</span><span class="n">id</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="err">#</span><span class="mi">1</span>
</code></pre></div></div>

<blockquote>
  <p>注意，这里有一个问题是，将<code class="highlighter-rouge">a</code>递个id函数时，引用计数也会+1， 但是当id函数返回时，引用计数-1，因此可以得到正确的结果</p>
</blockquote>

<p>这时我们如果将<code class="highlighter-rouge">a</code>清空，<code class="highlighter-rouge">a</code>的引用计数变为0，<code class="highlighter-rouge">a</code>应该被回收</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a_address</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">ref_count</span><span class="p">(</span><span class="n">a_address</span><span class="p">)</span> <span class="c1">#1
</span><span class="n">ref_count</span><span class="p">(</span><span class="n">a_address</span><span class="p">)</span> <span class="c1">#0
</span><span class="n">ref_count</span><span class="p">(</span><span class="n">a_address</span><span class="p">)</span> <span class="c1">#9899200214
</span></code></pre></div></div>
<p>上述测试可见<code class="highlighter-rouge">a</code>并不是马上被回收的，而就算<code class="highlighter-rouge">a</code>被会后之后，它的地址仍有效，但引用计数就不对了，出现这中情况也不难理解，Python底层是C实现，<code class="highlighter-rouge">a</code>被释放后，其内存可能被其它对象占用，因此结果是不可预测的。通常情况下使用Python除了偶尔需要debug，并不会去折腾内存，因此了解到这里应该也就足够了，如果要继续深入，可以接着去研究C/C++的内存分配和回收机制</p>

<h3 id="garbage-collection">Garbage Collection</h3>

<p>接下来我们讨论内存回收，提到这个话题，有经验的程序员很自然的想到一个非常头疼的问题，就是如何检测循环引用导致的内存泄漏，即某对象的引用计数永远不可能为1。循环引用，有点类似多线程的死锁，引用双方都等待对方释放，从而进入等僵持状态。Python脱离底层确更容易遇到这个问题</p>

<p><img src="/assets/images/2016/08/dpy-2.png" width="60%" /></p>

<p>幸运的是，Python的垃圾回收机制可以检测到这种情况，从而强制将其双双回收掉。默认情况下GC是开着的，每隔几秒检查并回收一次，当然也可以手动调用让其强制回收一次。如果想要追求性能，也可以主动将其关掉，但要程序员来确保不出现循环引用的情况，which is very hard to do so.</p>

<blockquote>
  <p>对于Python&lt;3.4的版本，如果其中一个循环引用的对象重载了析构函数<code class="highlighter-rouge">__del__</code>，GC会认为该对象的对析构顺序有要求，但GC并不知道谁该被先析构，因此这种情况下GC会将两个对象标记为uncollectable，均不回收</p>
</blockquote>

<p>我们可以使用下面代码来查找某object是否处于GC待回收的列表中</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">gc</span>

<span class="k">def</span> <span class="nf">ref_count</span><span class="p">(</span><span class="n">address</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>

<span class="k">def</span> <span class="nf">object_by_id</span><span class="p">(</span><span class="n">object_id</span><span class="p">):</span>
    <span class="k">for</span>  <span class="n">obj</span> <span class="ow">in</span> <span class="n">gc</span><span class="o">.</span><span class="n">get_objects</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">==</span> <span class="n">object_id</span><span class="p">:</span>
                <span class="k">return</span> <span class="s">"Object Exists"</span>
    <span class="k">return</span> <span class="s">"Not Found"</span>
</code></pre></div></div>

<p>接下来我们创建两个循环引用的对象，并暂停GC，观察内存地址</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'A: self:{hex(id(self))},b:{hex(id(self.b))}'</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'B: self:{hex(id(self))},a:{hex(id(self.a))}'</span><span class="p">)</span>

<span class="n">gc</span><span class="o">.</span><span class="n">disable</span><span class="p">()</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>

<span class="c1"># B: self:0x10aa2b208,a:0x10aa2b160
# A: self:0x10aa2b160,b:0x10aa2b208
</span></code></pre></div></div>
<p>从逻辑上分析，<code class="highlighter-rouge">a</code>持有<code class="highlighter-rouge">b</code>对象，<code class="highlighter-rouge">b</code>对象中的<code class="highlighter-rouge">a</code>又指回<code class="highlighter-rouge">a</code>，产生循环引用。查看<code class="highlighter-rouge">a</code>和<code class="highlighter-rouge">b</code>的引用计数</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">id_a</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">id_b</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">b</span><span class="p">)</span> 
<span class="k">print</span><span class="p">(</span><span class="n">ref_count</span><span class="p">(</span><span class="n">id_a</span><span class="p">))</span> <span class="c1">#2
</span><span class="k">print</span><span class="p">(</span><span class="n">ref_count</span><span class="p">(</span><span class="n">id_b</span><span class="p">))</span> <span class="c1">#1
</span><span class="k">print</span><span class="p">(</span><span class="n">object_by_id</span><span class="p">(</span><span class="n">id_a</span><span class="p">))</span> <span class="c1">#Object Exists
</span><span class="k">print</span><span class="p">(</span><span class="n">object_by_id</span><span class="p">(</span><span class="n">id_b</span><span class="p">))</span> <span class="c1">#Object Exists
</span></code></pre></div></div>

<p><code class="highlighter-rouge">a</code>的引用计数为2，<code class="highlighter-rouge">a</code>被自身引用和被<code class="highlighter-rouge">b.a</code>引用，<code class="highlighter-rouge">b</code>的引用计数为1，只被<code class="highlighter-rouge">a.b</code>引用，符合推理，同样，<code class="highlighter-rouge">a,b</code>均存在与GC的列表中。接下来我们将<code class="highlighter-rouge">a</code>的引用计数-1</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="bp">None</span>
<span class="k">print</span><span class="p">(</span><span class="n">ref_count</span><span class="p">(</span><span class="n">id_a</span><span class="p">))</span> <span class="c1">#1
</span><span class="k">print</span><span class="p">(</span><span class="n">ref_count</span><span class="p">(</span><span class="n">id_b</span><span class="p">))</span> <span class="c1">#1
</span></code></pre></div></div>
<p>可见即使显式的释放了对象，其内存仍然没有被安全回收，产生内存泄漏，最后我们可以开启GC，令其对<code class="highlighter-rouge">a,b</code>进行强制回收</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">object_by_id</span><span class="p">(</span><span class="n">id_a</span><span class="p">))</span> <span class="c1">#Not Found
</span><span class="k">print</span><span class="p">(</span><span class="n">object_by_id</span><span class="p">(</span><span class="n">id_b</span><span class="p">))</span> <span class="c1">#Not Found
</span><span class="k">print</span><span class="p">(</span><span class="n">ref_count</span><span class="p">(</span><span class="n">id_a</span><span class="p">))</span> <span class="c1">#0
</span><span class="k">print</span><span class="p">(</span><span class="n">ref_count</span><span class="p">(</span><span class="n">id_b</span><span class="p">))</span> <span class="c1">#0
</span></code></pre></div></div>
<p>最后需要注意的是，被回收之后的<code class="highlighter-rouge">a,b</code>其地址仍然存在，但该地址是无效的，因为对象已经不存在了。</p>

<h3 id="important-note">Important Note</h3>

<p>上面讨论的内容，以及后面要讨论的内容均和Python的底层实现相关，这里我们是以标准的<code class="highlighter-rouge">CPython</code>作为引擎来研究Python。除了<code class="highlighter-rouge">CPython</code>之外，还有很多其他的Python引擎，比如</p>

<ul>
  <li><code class="highlighter-rouge">Jython</code>可将python代码编译为JVM可识别的某种中间代码(类似<code class="highlighter-rouge">javac</code>)从可使其运行在JVM中</li>
  <li><code class="highlighter-rouge">IronPython</code>是用<code class="highlighter-rouge">C#</code>编写的，可以运行在<code class="highlighter-rouge">.net</code>平台上的Python引擎</li>
  <li><code class="highlighter-rouge">PyPy</code>是用Python写的一个Python解释器</li>
</ul>

<p>更多的Python引擎可以参考wiki</p>

<p class="md-p-center md-margin-top-24">（全文完）</p>

<h3 id="resource">Resource</h3>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/List_of_Python_software#Python_implementations">Python wiki</a></li>
  <li><a href="https://rushter.com/blog/python-garbage-collector/">Python Garbage collection in Python: things you need to know</a></li>
  <li><a href="https://en.wikipedia.org/wiki/List_of_Python_software#Python_implementations">Python的各种引擎</a></li>
</ul>
:ET