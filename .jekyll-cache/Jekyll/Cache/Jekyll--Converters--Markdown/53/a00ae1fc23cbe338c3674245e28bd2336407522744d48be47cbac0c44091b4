I"C<p><em></em></p>

<p>对于Quartz我觉得有两个点值得讨论：一是坐标系，二是绘制bitmap</p>

<h3 id="坐标系">坐标系</h3>

<p>如果熟悉openGL，那么对Quartz的坐标系相信不会有太多的疑惑。Quartz的坐标系是二维的坐标系，通过<code class="highlighter-rouge">CGAffineTransform</code>的状态矩阵来表示，顾名思义，它是一种二维线性的可逆变换，也叫<a href="http://zh.wikipedia.org/zh-cn/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2">仿射变换</a>。在openGL中，物体是通过矩阵表示的，对于二维平面，只需要让z方向分量为单位向量:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{bmatrix}a & b &0 \\ c & d &0 \\ tx &ty &1 \end{bmatrix} %]]></script>

<p>这就是CGAffineTransform矩阵。在iOS中，它的定义如下：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">CGAffineTransform</span> <span class="p">{</span>
  <span class="n">CGFloat</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>
  <span class="n">CGFloat</span> <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>这个矩阵和openGL中的矩阵表示的含义是相同的：</p>

<ul>
  <li>a ： 水平方向的缩放</li>
  <li>c :  水平方向的旋转</li>
  <li>
    <p>tx:  水平方向的位移</p>
  </li>
  <li>b ：竖直方向的旋转</li>
  <li>d ：竖直方向的缩放</li>
  <li>ty：竖直方向的位移</li>
</ul>

<p>如果有一个点<code class="highlighter-rouge">(x,y,1)</code>乘以这个状态矩阵，将得到新的点：</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{aligned}
& x' = ax + cy + tx \\
& y' = bx + dy + ty; \\
\end{aligned} %]]></script>

<p>其中，如果旋转变量b,c为0的话，那么</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{aligned}
& x' = ax + tx \\
& y' = dy + ty; \\
\end{aligned} %]]></script>

<p>即新的<code class="highlighter-rouge">x</code>值等于旧<code class="highlighter-rouge">x</code>值乘以缩放值 + 位移值。y同理。 如果使用Core Graphic绘制，我们可以得到一些矩阵：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Drawing code</span>
<span class="n">CGContextRef</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
<span class="c1">//得到当前的状态矩阵</span>
<span class="n">CGAffineTransform</span> <span class="n">t0</span> <span class="o">=</span> <span class="n">CGContextGetCTM</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="c1">//得到当前状态矩阵的逆矩阵</span>
<span class="n">CGAffineTransform</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">CGAffineTransformInvert</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span>
<span class="c1">//得到单位阵</span>
<span class="n">CGAffineTransform</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">CGAffineTransformIdentity</span><span class="p">;</span>
</code></pre></div></div>

<p>CTM是Current Transform Matrix的缩写，为了理解的更直观，我们从Quartz的坐标系统开始：</p>

<p><a href="/assets/images/2012/04/quartz.png"><img src="/assets/images/2012/04/quartz.png" alt="quartz" width="244" height="290" /></a></p>

<p>在Quartz的坐标系中左下角为（0，0），但是我们是用Core Graphic的api都是以左上角为(0，0)的，这中间的转换就是通过了CGAffineTransform这个状态矩阵，我们可以看一下一个普通view的CGAffineTransform矩阵：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(lldb) p t0
(CGAffineTransform) $1 = {
  (CGFloat) a = 1
  (CGFloat) b = 0
  (CGFloat) c = 0
  (CGFloat) d = -1
  (CGFloat) tx = 0
  (CGFloat) ty = 568
}
</code></pre></div></div>

<p>这个矩阵的意思很明确：将y轴翻转然后再向上平移568个单位，就是(0,0)了。假如我们在(100,100)画了一个点，实际上在Quartz的坐标系中，这个点是(100,468)。</p>

<p><a href="/assets/images/2012/04/quartz2.png"><img src="/assets/images/2012/04/quartz2.png" alt="quartz2" width="236" height="289" /></a></p>

<h4>改变坐标系</h4>

<p>了解这个原理后，我们便可以随便改变坐标系，我们先在(0,0)点画个圆:</p>

<p><a href="/assets/images/2012/04/quartz3.png"><img src="/assets/images/2012/04/quartz3.png" alt="quartz3" width="284" height="127" /></a></p>

<p>然后将坐标系的原点平移到(20,20)：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//得到单位阵</span>
<span class="n">CGAffineTransform</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">CGAffineTransformIdentity</span><span class="p">;</span>
<span class="c1">//平移单位阵</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">CGAffineTransformTranslate</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="c1">//改变当前状态阵</span>
<span class="n">CGContextConcatCTM</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">t1</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span> 
</code></pre></div></div>
<p>得到结果如下：</p>

<p><a href="/assets/images/2012/04/quartz4.png"><img src="/assets/images/2012/04/quartz4.png" alt="quartz4" width="198" height="137" /></a></p>

<p>这种变换不难想象其实是改变了tx,ty的偏移值：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(CGAffineTransform) $0 = {
  a = 1
  b = 0
  c = 0
  d = -1
  tx = 10
  ty = 558
}
</code></pre></div></div>
<p>同样我们也可以旋转坐标系：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">//旋转坐标系</span>
 <span class="n">CGContextRotateCTM</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">)</span><span class="o">*</span><span class="n">M_PI</span><span class="o">/</span><span class="mi">180</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="绘制图片">绘制图片</h2>

<h3 id="使用uigraphicsbeginimagecontextwithoptions">使用<code class="highlighter-rouge">UIGraphicsBeginImageContextWithOptions</code></h3>

<p>我们经常需要使用context绘制bitmap,Core Graphic提供了很多方法来实现它，多到令人费解。我们先看一种常用的方法：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UIImage</span><span class="o">*</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
<span class="n">CGSize</span> <span class="n">newSize</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">newSize</span><span class="p">,</span> <span class="nb">NO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">CGRect</span> <span class="n">newRect</span> <span class="o">=</span> <span class="p">(</span><span class="n">CGRect</span><span class="p">){</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">newSize</span><span class="p">};</span>
<span class="p">[</span><span class="n">_img</span> <span class="nf">drawInRect</span><span class="p">:</span><span class="n">newRect</span><span class="p">];</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">();</span>
<span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">UIGraphicsBeginImageContextWithOptions</code>这个API用来在内存中生成一个RBGA格式的Bitmap，上面代码是将原图缩小到10x10，绘制一张新图:</p>

<p><img src="/assets/images/2012/04/quartz5.png" /></p>

<p>接下来，我们可以换一种绘图方式</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CGSize</span> <span class="n">newSize</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">CGRect</span> <span class="n">newRect</span> <span class="o">=</span> <span class="p">(</span><span class="n">CGRect</span><span class="p">){</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">newSize</span><span class="p">};</span>

<span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">newSize</span><span class="p">,</span> <span class="nb">NO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">CGContextRef</span> <span class="n">srcContext</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
<span class="n">CGContextDrawImage</span><span class="p">(</span><span class="n">srcContext</span><span class="p">,</span> <span class="n">newRect</span><span class="p">,</span> <span class="n">_img</span><span class="p">.</span><span class="n">CGImage</span><span class="p">);</span>
<span class="n">CGImageRef</span> <span class="n">newImgRef</span> <span class="o">=</span> <span class="n">CGBitmapContextCreateImage</span><span class="p">(</span><span class="n">srcContext</span><span class="p">);</span>
<span class="n">UIImage</span><span class="o">*</span> <span class="n">newImg</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nf">imageWithCGImage</span><span class="p">:</span><span class="n">newImgRef</span><span class="p">];</span>
<span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</code></pre></div></div>

<p>结果却是这样的：</p>

<p><img src="/assets/images/2012/04/quartz6.png" /></p>

<p>图片为什么反了呢？熟悉图像处理的人应该知道bitmap的数据排列和显示是成镜像关系的，bitmap 数据指针指向图片的末行。因此，如果想把bitmap按照正确的顺序绘制出来，需要改变Quartz的绘制顺序，让它从从远点开始，然后从底向上绘制。</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CGContextScaleCTM</span><span class="p">(</span><span class="n">srcContext</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">srcContext</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码的意思是坐标系反转了之后，状态矩阵变成了：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$0</span> <span class="o">=</span> <span class="o">[</span>
  a <span class="o">=</span> 1
  b <span class="o">=</span> 0
  c <span class="o">=</span> 0
  d <span class="o">=</span> 1
  tx <span class="o">=</span> 0
  ty <span class="o">=</span> 0
<span class="o">]</span>
</code></pre></div></div>

<p>按照上面的计算公式，坐标变成了</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x<span class="o">(</span>new<span class="o">)</span> <span class="o">=</span> x<span class="o">(</span>old<span class="o">)</span><span class="k">*</span>1<span class="p">;</span>
y<span class="o">(</span>new<span class="o">)</span> <span class="o">=</span> y<span class="o">(</span>old<span class="o">)</span><span class="k">*</span>1<span class="p">;</span>
</code></pre></div></div>

<p>也就是说Quartz从（0，0）点开始绘制了，读bitmap第一行像素，从屏幕最底部显示出来，这样bitmap的绘制顺序就正确了。
这种方式确实很麻烦，需要developer理解Quartz的坐标并且对bitmap图片格式也要熟悉，因此并不建议使用。</p>

<h3 id="使用renderincontext">使用<code class="highlighter-rouge">RenderInContext</code></h3>

<p>layer.renderInContext：可以将当前layer的content变成一张CGImageRef，这和Quartz有什么关系呢？很久以前我试图render部分layer的内容到一张image，就是说给View的一部分截图。例如一个view的bounds是(0,0,100,100)，我想截取其（50，50，30，30）的部分。实现这个功能有很多种办法，最笨的就是把layer的content先通过context生成bitmap，然后去找像素点，聪明一点的就可以使用layer的二维状态矩阵。假如我们要实现下面的效果：</p>

<p><img src="/assets/images/2012/04/quartz7.png" /></p>

<p>假设左边原图大小为<code class="highlighter-rouge">100x100</code>，待截取区域矩形的origin位于原图的<code class="highlighter-rouge">(25,15</code>)处，大小为<code class="highlighter-rouge">50x50</code>。</p>

<p>首先我们需要一个context，创建一个50x50的bitmap，左上角为(0,0)。然后当layer通过context渲染时，只要保证layer的(25,15)这个点在context的状态矩阵中是(0,0)即可。那么怎么做到这一点？上面有提到平移坐标系，例如上面讨论中，我们将tx，ty各增加10。那么对于UIKit的坐标系，（0，0）点便成了(10,10)点，也就是图从（10,10）开始显示。那么反推这种运算，我们现在可以将tx = -25, ty = -15，这样UIKit的坐标系，（0，0）点便成了(-25,-15)点。这样便相当于从原图的(25，15)开始绘制。</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CGSize</span> <span class="n">newSize</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>  
<span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">newSize</span><span class="p">,</span> <span class="nb">NO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">CGContextRef</span> <span class="n">srcContext</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>

<span class="c1">//得到layer的状态矩阵</span>
<span class="n">CGAffineTransform</span> <span class="n">m</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">affineTransform</span><span class="p">;</span>

<span class="c1">//得到layer在context中的状态矩阵</span>
<span class="n">CGContextConcatCTM</span><span class="p">(</span><span class="n">srcContext</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>

<span class="c1">//平移UIKit坐标系</span>
<span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">srcContext</span><span class="p">,</span> <span class="o">-</span><span class="mi">25</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">);</span>

<span class="p">[</span><span class="n">v</span><span class="p">.</span><span class="n">layer</span> <span class="nf">renderInContext</span><span class="p">:</span><span class="n">srcContext</span><span class="p">];</span>

<span class="n">UIImage</span><span class="o">*</span> <span class="n">newImg</span> <span class="o">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">();</span>
<span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>

<span class="k">return</span> <span class="n">newImg</span><span class="p">;</span>
</code></pre></div></div>
:ET