I"Æ<blockquote>
  <p>Programming Languageè¯¾ç¨‹ç¬”è®°</p>
</blockquote>

<h3 id="course-content">Course Content</h3>

<ul>
  <li>Essential concepts relevant in any programming language</li>
  <li>Use ML,Racket,Ruby</li>
  <li>Big Focus on Functional Programming</li>
  <li><strong>3 parts (100-200 hours),11 weeks</strong>
    <ul>
      <li>Part A
        <ul>
          <li>Syntax vs. semantics vs. idioms vs. libraries vs. tools</li>
          <li>ML basics (bindings, conditionals, records, functions)</li>
          <li>Recursive functions and recursive types</li>
          <li>Benefits of no mutation</li>
          <li>Algebraic datatypes, pattern matching</li>
          <li>Tail recursion</li>
          <li>Higher-order functions; closures</li>
          <li>Lexical scope</li>
          <li>Currying</li>
          <li>Syntactic sugar</li>
          <li>Equivalence and effects</li>
          <li>Parametric polymorphism and container types</li>
          <li>Type inference</li>
          <li>Abstract types and modules</li>
        </ul>
      </li>
      <li>Part B
        <ul>
          <li>Racket basics</li>
          <li>Dynamic vs. static typing</li>
          <li>Laziness, streams, and memoization</li>
          <li>Implementing languages, especially higher-order functions</li>
          <li>Macros</li>
          <li>Eval</li>
        </ul>
      </li>
      <li>Part C
        <ul>
          <li>Ruby basics</li>
          <li>Object-oriented programming is dynamic dispatch</li>
          <li>Pure object-orientation</li>
          <li>Implementing dynamic dispatch</li>
          <li>Multiple inheritance, interfaces, and mixins</li>
          <li>OOP vs. functional decomposition and extensibility</li>
          <li>Subtyping for records, functions, and objects</li>
          <li>Class-based subtyping</li>
          <li>Subtyping</li>
          <li>Subtyping vs. parametric polymorphism; bounded polymorphism</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="environment-setup">Environment Setup</h3>

<ul>
  <li>SML Interpreter
    <ul>
      <li><code class="highlighter-rouge">brew install sml</code></li>
      <li><a href="http://pages.cs.wisc.edu/~fischer/cs538.s08/sml/sml.html">Commandline reference</a></li>
    </ul>
  </li>
  <li>Code Editor
    <ul>
      <li><a href="https://code.visualstudio.com/">VSCode</a></li>
      <li><a href="https://github.com/freebroccolo/vscode-sml">Standard ML extension</a></li>
    </ul>
  </li>
</ul>

<h1 id="week-1">Week 1</h1>

<h2 id="variable-bindings-and-expressions">Variable Bindings and Expressions</h2>

<ul>
  <li>â€œLet goâ€ of all programming languages you already knowâ€</li>
  <li><mark>Treat "ML" as a "totally new thing"</mark>
    <ul>
      <li>Time later to compare / contrast to what you konw</li>
    </ul>
  </li>
  <li>Start from a blank file</li>
</ul>

<pre><code class="language-Haskell">(* This is a comment. This is our first program. *)
val x = 34; 

(* static enviroment: x : int *)
(* dynamic enviroment: x --&gt; 34 *)
val y = 17;

(* static enviroment: x:int, y:int *)
(* dynamic enviroment: x --&gt; 34, y --&gt; 17 *)
val z = (x+y) + (y+2);

(* static enviroment: x:int, y:int, z:int *)
(* dynamic enviroment: x--&gt; 34, y--&gt;17, z --&gt; 70 *)
val q = z+1

(* static enviroment: x:int, y:int, z:int, q:int *)
(* dynamic enviroment: x--&gt; 34, y--&gt;17, q --&gt; 71 *)
val abs_of_z = if z&lt;0 then 0-z else z;(* bool *)(* int *)

(* dynamic enviroment: ..., abs_of_z --&gt; 70 *)
val abs_of_z_simpler = abs(z)
</code></pre>

<ul>
  <li>Static environment: é™æ€ç¯å¢ƒæ˜¯æŒ‡ä»£ç åœ¨è¿è¡Œæ—¶ç¯å¢ƒä¹‹å‰ï¼ˆæ‰§è¡Œå‰ï¼‰ï¼ŒMLä¼šå¯¹å˜é‡åšç±»å‹æ¨æ–­ï¼Œç­¾åæ£€æŸ¥ï¼Œæ¯”å¦‚<code class="highlighter-rouge">x:int</code>ã€‚</li>
  <li>Dynamic environment: ç¨‹åºçš„è¿è¡Œæ—¶ç¯å¢ƒï¼Œä¿å­˜å˜é‡å½“å‰çŠ¶æ€</li>
</ul>

<h3 id="a-variable-binding">A Variable Binding</h3>

<ul>
  <li>å®šä¹‰
    <ul>
      <li><code class="highlighter-rouge">val x = e;</code></li>
    </ul>
  </li>
  <li>Syntax(è¯­æ³•):
    <ul>
      <li><strong>Syntax</strong> is just how you write something</li>
      <li><code class="highlighter-rouge">val</code>, <code class="highlighter-rouge">=</code> , <code class="highlighter-rouge">;</code></li>
      <li>variable <code class="highlighter-rouge">x</code></li>
      <li>Expression <code class="highlighter-rouge">e</code></li>
    </ul>
  </li>
  <li>Semantics(è¯­ä¹‰):
    <ul>
      <li>Syntax is just how you write something</li>
      <li><strong>Semantics</strong> is what that something means
        <ul>
          <li><strong>Type Checking</strong> (before program runs)</li>
          <li><strong>Evaluation</strong> (as program runs)</li>
        </ul>
      </li>
      <li>For variable bindings:
        <ul>
          <li>Type-check expresson and extend <strong>static environment</strong></li>
          <li>Evaluate expression and extend <strong>dynamic environment</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>åœ¨å‡½æ•°å‹è¯­è¨€é‡Œï¼Œæ²¡æœ‰èµ‹å€¼(assign)çš„æ¦‚å¿µï¼Œè€Œæ˜¯å«åšbindingã€‚ä¸€ä¸ªå˜é‡(ç¬¦å·)è¢«bindä¸€ä¸ªvalueåï¼Œè¿™ä¸ªå˜é‡æ˜¯ä¸å…è®¸å†å»bindå…¶å®ƒçš„valueã€‚</p>
</blockquote>

<h2 id="rules-for-expressions">Rules for Expressions</h2>

<h3 id="expressions">Expressions</h3>

<ul>
  <li>We have seen many kinds of expressions:
    <ul>
      <li><code class="highlighter-rouge">34 true false x e1+e2 e1&gt;e2</code></li>
      <li><code class="highlighter-rouge">if e1 then e2 else e3</code></li>
    </ul>
  </li>
  <li><mark>Every kind of expression has</mark>
    <ul>
      <li><strong>Syntax</strong>
        <ul>
          <li>è¯­æ³•</li>
        </ul>
      </li>
      <li><strong>Type-checking rules</strong>
        <ul>
          <li>ç±»å‹æ£€æŸ¥</li>
          <li>Produces a type or fails(with a bad error message)</li>
          <li>types so far: <code class="highlighter-rouge">int</code> <code class="highlighter-rouge">bool</code> <code class="highlighter-rouge">unit</code></li>
        </ul>
      </li>
      <li><strong>Evaluation rules</strong>(used only on things that type-check)
        <ul>
          <li>æ±‚å€¼è§„åˆ™</li>
          <li>Produces a value(or exception or infinite-loop)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="åˆ†æ">åˆ†æ</h3>

<ul>
  <li><code class="highlighter-rouge">a=3</code>
    <ul>
      <li>Syntax:
        <ul>
          <li>sequence of letters,digits,_,not starting with digit</li>
        </ul>
      </li>
      <li>Type-checking:
        <ul>
          <li>Look up type in current <strong>static enviroment</strong>. if not there, fail</li>
        </ul>
      </li>
      <li>Evaluation:
        <ul>
          <li>look up value in current <strong>dynamic enviroment</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">+</code>
    <ul>
      <li>Syntax:
  <code class="highlighter-rouge">e1+e2</code> where <code class="highlighter-rouge">e1</code> and <code class="highlighter-rouge">e2</code> are expressions</li>
      <li>Type-checking:
        <ul>
          <li>if <code class="highlighter-rouge">e1</code> and <code class="highlighter-rouge">e2</code> have type <code class="highlighter-rouge">int</code>,</li>
          <li>then <code class="highlighter-rouge">e +e2</code> has type <code class="highlighter-rouge">int</code></li>
        </ul>
      </li>
      <li>Evaluation:
        <ul>
          <li>if <code class="highlighter-rouge">e1</code> evaluates to <code class="highlighter-rouge">v1</code> and <code class="highlighter-rouge">e2</code> evaluates to <code class="highlighter-rouge">v2</code>,</li>
          <li>then <code class="highlighter-rouge">e1+e2</code> evaluates to sum of <code class="highlighter-rouge">v1</code> and <code class="highlighter-rouge">v2</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">if-else</code>
    <ul>
      <li>Syntax:
        <ul>
          <li>if <code class="highlighter-rouge">e1</code> then <code class="highlighter-rouge">e2</code> else <code class="highlighter-rouge">e3</code></li>
          <li>where <code class="highlighter-rouge">if</code>,<code class="highlighter-rouge">then</code>,<code class="highlighter-rouge">else</code> are keywords and <code class="highlighter-rouge">e1</code>,<code class="highlighter-rouge">e2</code>,<code class="highlighter-rouge">e3</code> are subexpressions</li>
        </ul>
      </li>
      <li>Type-checking:
        <ul>
          <li>first <code class="highlighter-rouge">e1</code> must have type <code class="highlighter-rouge">bool</code>.</li>
          <li><code class="highlighter-rouge">e2</code> and <code class="highlighter-rouge">e3</code> can have any type <code class="highlighter-rouge">t</code>, but they must have the same type <code class="highlighter-rouge">t</code>.</li>
          <li>the type of the entire expression is also <code class="highlighter-rouge">t</code></li>
        </ul>
      </li>
      <li>Evaluation rules:
        <ul>
          <li>first evaluate <code class="highlighter-rouge">e1</code> to a value call it <code class="highlighter-rouge">v1</code>, if the result is ture, then evaluate <code class="highlighter-rouge">e2</code> as the result of whole expression. else, evaluate <code class="highlighter-rouge">e3</code> and that result is the whole expressionâ€™s result.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="values">Values</h3>

<ul>
  <li>All values are expressions</li>
  <li>Not all expressions are values</li>
  <li>Every value <strong>â€œevaluates to itselfâ€</strong> in â€œzero stepsâ€</li>
  <li>Examples:
    <ul>
      <li><code class="highlighter-rouge">34</code>,<code class="highlighter-rouge">17</code>,<code class="highlighter-rouge">42</code> have type <code class="highlighter-rouge">int</code></li>
      <li><code class="highlighter-rouge">true</code>, <code class="highlighter-rouge">false</code> have type <code class="highlighter-rouge">bool</code></li>
      <li><code class="highlighter-rouge">()</code> has type <code class="highlighter-rouge">unit</code></li>
    </ul>
  </li>
</ul>

<h3 id="the-repl-and-erros">The REPL and Erros</h3>

<ul>
  <li>ä½¿ç”¨å‘½ä»¤è¡Œè§£é‡Šæ‰§è¡Œå•æ¡è¯­å¥è¦åŠ <code class="highlighter-rouge">;</code>
    <ul>
      <li><code class="highlighter-rouge">val x=1;</code></li>
    </ul>
  </li>
  <li>
    <p>è¯»æ–‡ä»¶<code class="highlighter-rouge">use "foo.sml";</code></p>
  </li>
  <li>Error
    <ul>
      <li>syntax:
        <ul>
          <li>what you wrote means nothing or not the construct you intended.</li>
        </ul>
      </li>
      <li>Type-checking:
        <ul>
          <li>What you wrote does not type-checked</li>
        </ul>
      </li>
      <li>Evaluation:
        <ul>
          <li>It runs but produces wrong answer, or an exception, or an infinite loop</li>
        </ul>
      </li>
      <li>common error:
        <ul>
          <li><code class="highlighter-rouge">if</code> - <code class="highlighter-rouge">then</code> - <code class="highlighter-rouge">else</code></li>
          <li>if takes a <code class="highlighter-rouge">bool</code> type value</li>
          <li><code class="highlighter-rouge">then</code> and <code class="highlighter-rouge">else</code> must return the same type of result</li>
          <li>è´Ÿå·ç”¨<code class="highlighter-rouge">~</code>è¡¨ç¤ºï¼š<code class="highlighter-rouge">~5</code></li>
          <li>é™¤å·ç”¨<code class="highlighter-rouge">div</code>è¡¨ç¤º <code class="highlighter-rouge">10 div 5</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="shadowing">Shadowing</h2>

<h3 id="multiple-binding-of-same-variable">Multiple binding of same variable</h3>

<p><mark>shadowing</mark>æŒ‡çš„æ˜¯add a variable to the environmentï¼Œä½†æ˜¯è¿™ä¸ªvariableåœ¨environmentä¸­å·²ç»å­˜åœ¨äº†ï¼Œä¸‹é¢ä»£ç ï¼š</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">val</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span>
<span class="p">(</span><span class="o">*</span> <span class="n">a</span><span class="o">:</span><span class="n">int</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="mi">10</span> <span class="o">*</span><span class="p">)</span>

<span class="n">val</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="mi">2</span>
<span class="p">(</span><span class="o">*</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="mi">20</span> <span class="o">*</span><span class="p">)</span>

<span class="n">val</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span> <span class="p">(</span><span class="o">*</span>  <span class="n">this</span> <span class="n">is</span> <span class="n">not</span> <span class="n">an</span> <span class="n">assignment</span> <span class="n">statement</span> <span class="o">*</span><span class="p">)</span>
<span class="p">(</span><span class="o">*</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="mi">5</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span> <span class="mi">20</span> <span class="o">*</span><span class="p">)</span>
</code></pre></div></div>

<p>ä¸Šé¢ä»£ç ä¸­ï¼Œ<code class="highlighter-rouge">a=5</code>å¹¶æ²¡æœ‰æ”¹å˜åŸæ¥çš„<code class="highlighter-rouge">a</code>å€¼ï¼Œåœ¨MLä¸­æ˜¯æ²¡æœ‰åŠæ³•ä¿®æ”¹åŸå…ˆå†…å­˜ä¸­çš„å€¼çš„ã€‚å› æ­¤è¿™é‡Œå¾—åˆ°çš„<code class="highlighter-rouge">a</code>æ˜¯ä¸€ä¸ªæ–°çš„environmentä¸­çš„<code class="highlighter-rouge">a</code>,åé¢çš„å˜é‡éƒ½æ³¨å†Œåˆ°è¿™ä¸ªenviromentä¸­ï¼Œå› æ­¤åŸæ¥çš„aè¢«shadowæ‰äº†ã€‚</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">val</span> <span class="n">c</span> <span class="o">=</span> <span class="n">b</span>
<span class="p">(</span><span class="o">*</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="mi">5</span><span class="p">,</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="mi">20</span> <span class="p">,</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="mi">20</span>  <span class="o">*</span><span class="p">)</span>
</code></pre></div></div>

<p>æ­¤æ—¶bä¸æ˜¯å‰é¢çš„bäº†ï¼Œè€Œæ˜¯æ–°environmentä¸­çš„b</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">val</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span>
<span class="p">(</span><span class="o">*</span> <span class="o">...</span><span class="p">,</span><span class="kr">in</span> <span class="n">the</span> <span class="n">current</span> <span class="n">envrioment</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="mi">5</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="mi">5</span> <span class="o">*</span><span class="p">)</span>

<span class="n">val</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">(</span><span class="o">*</span><span class="n">create</span> <span class="n">a</span> <span class="n">new</span> <span class="n">envrioment</span><span class="p">,</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="mi">6</span><span class="o">*</span><span class="p">)</span>
</code></pre></div></div>
<p>å’Œä¸Šé¢åŸç†ç›¸åŒï¼Œåœ¨å½“å‰çš„envrionmentä¸­<code class="highlighter-rouge">a+1 = 6</code>ï¼Œæ­¤æ—¶éœ€è¦å¢åŠ ä¸€ä¸ªvariableï¼Œä¹Ÿå«<code class="highlighter-rouge">a</code>ï¼Œåˆäº§ç”Ÿäº†shadowingã€‚ç³»ç»Ÿä¼šå†åˆ›å»ºä¸€ä¸ªæ–°çš„environmentä¿å­˜æ–°çš„<code class="highlighter-rouge">a</code>ã€‚</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">val</span> <span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">hidden</span><span class="o">-</span><span class="n">value</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">int</span>
<span class="n">val</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">:</span> <span class="n">int</span>
<span class="n">val</span> <span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">hidden</span><span class="o">-</span><span class="n">value</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">int</span>
<span class="n">val</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">:</span> <span class="n">int</span>
<span class="n">val</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">:</span> <span class="n">int</span>
<span class="n">val</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">:</span> <span class="n">int</span>
<span class="n">val</span> <span class="n">it</span> <span class="o">=</span> <span class="nb">()</span> <span class="o">:</span> <span class="n">unit</span>
</code></pre></div></div>
<p>æŸ¥çœ‹å½“å‰ç¯å¢ƒçš„è½¬å°ï¼Œå¯ä»¥çœ‹åˆ°ä¹‹å‰çš„ä¸¤ä¸ªè¢«shadowæ‰çš„<code class="highlighter-rouge">a</code>æç¤º<code class="highlighter-rouge">&lt;hidden-value&gt;</code></p>

<h2 id="functionsinformally">Functions(informally)</h2>

<h3 id="function">Function</h3>

<ul>
  <li>the most important build block in the whole course
    <ul>
      <li>Like Java methods,have arguments and result</li>
      <li>But no classes,<code class="highlighter-rouge">self</code>,<code class="highlighter-rouge">this</code>,<code class="highlighter-rouge">return</code></li>
    </ul>
  </li>
</ul>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">*</span> <span class="n">val</span> <span class="n">pow</span> <span class="o">=</span> <span class="n">fn</span> <span class="o">:</span> <span class="n">int</span> <span class="o">*</span> <span class="n">int</span> <span class="o">-&gt;</span> <span class="n">int</span> <span class="o">*</span><span class="p">)</span>
<span class="n">fun</span> <span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">int</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span><span class="n">int</span><span class="p">)</span> <span class="o">=</span> 
	<span class="kr">if</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span> 
	<span class="kr">then</span> <span class="mi">1</span> 
	<span class="kr">else</span> <span class="n">x</span><span class="o">*</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>å‡½æ•°ç­¾å
    <ul>
      <li>Example: <code class="highlighter-rouge">int * int -&gt; int</code> è¡¨ç¤ºæœ‰ä¸¤ä¸ªå‚æ•°ï¼Œç±»å‹éƒ½æ˜¯<code class="highlighter-rouge">int</code>,è¿”å›å€¼ä¹Ÿæ˜¯<code class="highlighter-rouge">int</code></li>
      <li>In expressions, <code class="highlighter-rouge">*</code> is multiplication: <code class="highlighter-rouge">x*pow(x,y-1)</code></li>
    </ul>
  </li>
  <li>Cannot refer to later function bindings
    <ul>
      <li>Thatâ€™s simply MLâ€™s rule</li>
      <li>Helper functions must come before their uses</li>
      <li>Need spection construct for mutual recursion(later)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>ä¸Šé¢ä¾‹å­å¯çŸ¥MLä¸­Functionæ˜¯first-class object, å‡½æ•°çš„ç±»å‹å°±æ˜¯å®ƒçš„ç­¾å</p>
</blockquote>

<h3 id="recursion">Recursion</h3>

<ul>
  <li>â€œMakes senseâ€ because calls to same function solve â€œsimpler problemsâ€</li>
  <li>Recursion more powerful than loops
    <ul>
      <li>We wonâ€™t use a single loop in ML</li>
      <li>Loops ofter(not always)obscure simple, elegant solutions</li>
    </ul>
  </li>
</ul>

<p><mark>Everything you can do in loop, you can do it in recursion</mark>ï¼Œä½¿ç”¨é€’å½’å¯ä»¥å–ä»£å¾ªç¯ï¼Œç®€åŒ–ä»£ç </p>

<blockquote>
  <p>ç”±äº<code class="highlighter-rouge">for</code>æˆ–<code class="highlighter-rouge">while</code>æ˜¯ä¸€ç§è¿‡ç¨‹æ€§çš„è¡¨è¾¾å¼ï¼Œå®ƒè¡¨è¾¾çš„æ˜¯å¦‚ä½•å®Œæˆå¾ªç¯ï¼Œè¿˜éœ€è¦å¼•å…¥ä¸€äº›çŠ¶æ€å˜é‡ã€‚åœ¨å‡½æ•°å‹è¯­è¨€ä¸­ï¼Œè¿™ç§åšæ³•ä¸ç›´è§‚ï¼Œæ˜¯ä¸€ç§è¿‡ç¨‹å¼çš„é£æ ¼</p>
</blockquote>

<h2 id="functionsformally">Functionsï¼ˆformally)</h2>

<h3 id="function-binding">Function binding</h3>

<ul>
  <li>Syntax : <code class="highlighter-rouge">fun x0ï¼ˆx1:t1,...,xn:tnï¼‰= e</code>
    <ul>
      <li><code class="highlighter-rouge">x0</code>æ˜¯å‡½æ•°å</li>
      <li>(will generalize in later lecture)</li>
    </ul>
  </li>
  <li>Type-Checking:
    <ul>
      <li>é¦–å…ˆå°†<code class="highlighter-rouge">x0</code>çš„ç±»å‹ç»‘å®šä¸º<code class="highlighter-rouge">(t1 *...* tn)-&gt;t</code></li>
      <li>å¯¹å‡½æ•°çš„body<code class="highlighter-rouge">e</code>è¿›è¡Œtype-checking, ä½¿ç”¨static environmentä¸­å·²æœ‰çš„ä¿¡æ¯ï¼Œæ¯”å¦‚ä¹‹å‰åˆ›å»ºçš„bindingï¼ˆå‡½æ•°bodyä¸­å¯èƒ½ä½¿ç”¨ä»¥å‰çš„bindingï¼‰</li>
      <li>å¯¹å‡½æ•°çš„å‚æ•°ç±»å‹æ£€æŸ¥å’Œå‡½æ•°è‡ªèº«çš„ç±»å‹æ£€æŸ¥
        <ul>
          <li>å‡½æ•°bodyä¸­å¯èƒ½å‡ºç°é€’å½’ï¼Œå› æ­¤å¯¹å‡½æ•°è‡ªèº«ä¹Ÿè¦è¿›è¡Œtype-checking</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Evaluation :
    <ul>
      <li>è¿è¡Œæ—¶æ±‚å€¼ï¼Œå¯¹å‡½æ•°çš„bodyä¸è¿›è¡Œæå‰Evaluation</li>
      <li>Add <code class="highlighter-rouge">x0</code> to dynamic enviroment so later expression can call it.</li>
      <li>Funcation call semantics will also allow recursion</li>
    </ul>
  </li>
</ul>

<h3 id="more-on-type-checking">More on type-checking</h3>

<div style="text-align:center">
	<code>fun x0ï¼ˆx1:t1,...,xn:tnï¼‰= e</code>
</div>

<ul>
  <li>New kind of type : <code class="highlighter-rouge">(t1 *...* tn ) -&gt; t</code>
    <ul>
      <li>Result type on right</li>
      <li>åœ¨static environmentä¸­ï¼Œåªæœ‰å‡½æ•°å¯¹è±¡<code class="highlighter-rouge">x0</code>çš„ç±»å‹ã€‚MLå‡½æ•°ä¹Ÿæ˜¯åœ¨è¿è¡Œæ—¶æ±‚å€¼çš„ï¼Œå› æ­¤å‡½æ•°ä½“ä¸­ä½¿ç”¨çš„bindingæ˜¯åœ¨dynamic environmentä¸­å¯»æ‰¾çš„</li>
      <li>å‚æ•°åªèƒ½åœ¨å‡½æ•°ä½“å†…éƒ¨<code class="highlighter-rouge">e</code>ä¸­ä½¿ç”¨</li>
      <li><code class="highlighter-rouge">x0</code>çš„è¿”å›å€¼ç±»å‹æ˜¯å‡½æ•°ä½“<code class="highlighter-rouge">e</code>çš„ç±»å‹ï¼ŒType-checkerå¯ä»¥æ ¹æ®<code class="highlighter-rouge">e</code>æ¨æ–­å‡ºè¿”å›å€¼ç±»å‹<code class="highlighter-rouge">t</code></li>
    </ul>
  </li>
</ul>

<h3 id="function-calls">Function Calls</h3>

<p>A new kind of expression:</p>

<ul>
  <li>Syntax : <code class="highlighter-rouge">e0 (e1,...,en)</code>
    <ul>
      <li>å¦‚æœåªæœ‰ä¸€ä¸ªå‚æ•°ï¼Œåˆ™å¯ä»¥çœç•¥æ‹¬å·ã€‚MLä¸­ä¸æ”¯æŒå¯å˜å‚æ•°</li>
      <li><code class="highlighter-rouge">pow(2,3)</code></li>
    </ul>
  </li>
  <li>Type-Checking:
    <ul>
      <li><code class="highlighter-rouge">e0</code> has some type <code class="highlighter-rouge">(t1 *...* tn ) -&gt; t</code>ï¼Œthen <code class="highlighter-rouge">e0 (e1,...,en)</code> has type <code class="highlighter-rouge">t</code>
        <ul>
          <li>Example:<code class="highlighter-rouge">pow(x,y-1)</code> in previouse example has type <code class="highlighter-rouge">int</code></li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">e1</code> has type <code class="highlighter-rouge">t1</code>, â€¦ , <code class="highlighter-rouge">en</code> has type <code class="highlighter-rouge">tn</code></li>
    </ul>
  </li>
  <li>Evaluation:
    <ol>
      <li>åœ¨å½“å‰è¿è¡Œæ—¶ç¯å¢ƒ(<mark>current dynamic enviroment</mark>)ä¸­å¯¹<code class="highlighter-rouge">e0</code>è¿›è¡Œæ±‚å€¼
        <ul>
          <li><code class="highlighter-rouge">e0</code>æ±‚å€¼ä¹‹åæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œç±»å‹ä¸º :<code class="highlighter-rouge">(t1 *...* tn ) -&gt; t</code></li>
        </ul>
      </li>
      <li>åœ¨å½“å‰è¿è¡Œæ—¶ç¯å¢ƒä¸­æ±‚è§£å‚æ•° <code class="highlighter-rouge">v1,...,vn</code>
        <ul>
          <li>æ¯”å¦‚å‚æ•°ä¸­æœ‰<code class="highlighter-rouge">2+2</code>ï¼Œè¿™ç§æƒ…å†µä¸‹éœ€è¦å¯¹å…¶è¿›è¡Œæ±‚å€¼åå†ç»§ç»­evaluate function</li>
        </ul>
      </li>
      <li>Result is evaluation of <code class="highlighter-rouge">e</code> in an enviroment extended to map <code class="highlighter-rouge">x1</code> to <code class="highlighter-rouge">v1</code>, â€¦ <code class="highlighter-rouge">xn</code> to <code class="highlighter-rouge">vn</code>
   	- (â€œAn envriomentâ€ is actually the enviroment where the function was defined, and includes <code class="highlighter-rouge">x0</code> for recursion)</li>
    </ol>
  </li>
</ul>

<h2 id="tuples-and-pairs">Tuples and Pairs</h2>

<h3 id="paris">Paris</h3>

<ul>
  <li>Syntax :
    <ul>
      <li><code class="highlighter-rouge">(e1,e2)</code></li>
    </ul>
  </li>
  <li>Type-checking:
    <ul>
      <li>if <code class="highlighter-rouge">e1</code> has type <code class="highlighter-rouge">ta</code> and <code class="highlighter-rouge">e2</code> has type <code class="highlighter-rouge">tb</code> then the expression has type <code class="highlighter-rouge">ta * tb</code></li>
      <li>A new kind of type</li>
    </ul>
  </li>
  <li>Evaluation:
    <ul>
      <li>Evaluate <code class="highlighter-rouge">e1</code> to <code class="highlighter-rouge">v1</code> and <code class="highlighter-rouge">e2</code> to <code class="highlighter-rouge">v2</code>; result is <code class="highlighter-rouge">(v1,v2)</code></li>
      <li>A pair of values is a value</li>
    </ul>
  </li>
</ul>

<h4 id="access">Access</h4>

<ul>
  <li>Syntaxï¼š
    <ul>
      <li><code class="highlighter-rouge">#1 e</code> and <code class="highlighter-rouge">#2 e</code></li>
    </ul>
  </li>
  <li>Evaluation:
    <ul>
      <li>Evaluate e to a pair of values and return first or section piece</li>
      <li>Example: if <code class="highlighter-rouge">e</code> is a variable x then look up x in enviroment</li>
    </ul>
  </li>
  <li>Type-checking:
    <ul>
      <li>if <code class="highlighter-rouge">e</code> has type <code class="highlighter-rouge">ta * tb</code> then <code class="highlighter-rouge">#1 e</code> has type <code class="highlighter-rouge">ta</code> and <code class="highlighter-rouge">#2 e</code> has type <code class="highlighter-rouge">tb</code></li>
    </ul>
  </li>
</ul>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fun</span> <span class="n">swap</span><span class="p">(</span><span class="n">pr</span> <span class="o">:</span> <span class="n">int</span><span class="o">*</span><span class="n">bool</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="o">#</span><span class="mi">2</span> <span class="n">pr</span><span class="p">,</span> <span class="o">#</span><span class="mi">1</span> <span class="n">pr</span><span class="p">)</span>

<span class="p">(</span><span class="o">*</span> <span class="p">(</span><span class="n">int</span><span class="o">*</span><span class="n">int</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">int</span><span class="o">*</span><span class="n">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">int</span> <span class="o">*</span><span class="p">)</span> 
<span class="n">fun</span> <span class="n">sum_two_pairs</span> <span class="p">(</span><span class="n">pr1</span> <span class="o">:</span> <span class="n">int</span> <span class="o">*</span> <span class="n">int</span><span class="p">,</span> <span class="n">pr2</span> <span class="o">:</span> <span class="n">int</span> <span class="o">*</span> <span class="n">int</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="o">#</span><span class="mi">1</span> <span class="n">pr1</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="o">#</span><span class="mi">2</span> <span class="n">pr1</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="o">#</span><span class="mi">1</span> <span class="n">pr2</span><span class="p">)</span><span class="o">+</span> <span class="p">(</span><span class="o">#</span><span class="mi">2</span> <span class="n">pr2</span><span class="p">)</span>

<span class="p">(</span><span class="o">*</span> <span class="n">int</span><span class="o">*</span><span class="n">int</span> <span class="o">-&gt;</span> <span class="n">int</span> <span class="o">*</span><span class="n">int</span> <span class="o">*</span><span class="p">)</span>
<span class="n">fun</span> <span class="n">div_mod</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">int</span><span class="p">,</span><span class="n">y</span><span class="o">:</span><span class="n">int</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="n">div</span> <span class="n">y</span> <span class="p">,</span> <span class="n">x</span> <span class="n">mod</span> <span class="n">y</span><span class="p">)</span>

<span class="n">fun</span> <span class="n">sort_pair</span><span class="p">(</span><span class="n">pr</span><span class="o">:</span><span class="n">int</span><span class="o">*</span><span class="n">int</span><span class="p">)</span> <span class="o">=</span> 
    <span class="kr">if</span> <span class="p">(</span><span class="o">#</span><span class="mi">1</span> <span class="n">pr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="o">#</span><span class="mi">2</span> <span class="n">pr</span><span class="p">)</span>
    <span class="kr">then</span> <span class="n">pr</span> 
    <span class="kr">else</span> <span class="p">(</span><span class="o">#</span><span class="mi">2</span> <span class="n">pr</span><span class="p">,</span> <span class="o">#</span><span class="mi">1</span> <span class="n">pr</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="tuples">Tuples</h3>

<p>Actually , you can have tuples with more than two parts.</p>

<ul>
  <li>(e1,e2,â€¦,en)</li>
  <li>ta * tb * â€¦ * tn</li>
  <li>â€œ#1 e, #2 e, #3 e â€¦â€</li>
</ul>

<h3 id="nesting">Nesting</h3>

<p>Pairs and tuples can be nested however you want</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">val</span> <span class="n">x1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span><span class="p">,(</span><span class="n">true</span><span class="p">,</span><span class="mi">9</span><span class="p">))</span> <span class="p">(</span><span class="o">*</span> <span class="n">int</span> <span class="o">*</span> <span class="p">(</span><span class="n">bool</span><span class="o">*</span><span class="n">int</span><span class="p">)</span> <span class="o">*</span><span class="p">)</span>

<span class="n">val</span> <span class="n">x2</span> <span class="o">=</span> <span class="o">#</span><span class="mi">1</span> <span class="p">(</span><span class="o">#</span><span class="mi">2</span> <span class="n">x1</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span> <span class="n">bool</span> <span class="o">*</span><span class="p">)</span>

</code></pre></div></div>

<h2 id="lists">Lists</h2>

<ul>
  <li>Despite nested tuples, tye type of variable still â€œcommitsâ€ to a particular â€œamountâ€ of data</li>
</ul>

<p>In contrast, a list:</p>

<ul>
  <li>Can have any number of elements</li>
  <li>But all list elements have the same type</li>
</ul>

<h3 id="building-lists">Building Lists</h3>

<ul>
  <li>
    <p>The empty list is a value <code class="highlighter-rouge">[]</code></p>
  </li>
  <li>
    <p>In general, a list of values is a value; elements separated by commas:<code class="highlighter-rouge">[v1,v2,...,vn]</code></p>
  </li>
</ul>

<blockquote>
  <p>åœ¨SMLä¸­listä¸­æ¯ä¸ªå…ƒç´ çš„ç±»å‹æ˜¯ç›¸åŒçš„</p>
</blockquote>

<ul>
  <li>if <code class="highlighter-rouge">e1</code> evaluates to <code class="highlighter-rouge">v</code> and <code class="highlighter-rouge">e2</code> evaluates to a list <code class="highlighter-rouge">[v1,...,vn]</code>,then <code class="highlighter-rouge">e1::e2</code> evaluates to <code class="highlighter-rouge">[v,..,vn]</code></li>
</ul>

<p><code class="highlighter-rouge"> e1::e2 (*pronounced "cons"*) </code>example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- val list = 1::[1,2];
val list = [1,1,2] : int list

</code></pre></div></div>

<h3 id="accessing-lists">Accessing Lists</h3>

<p>Until we learn pattern-matching, we will use three standard-library functions</p>

<ul>
  <li><code class="highlighter-rouge">null e</code> evaluates to <code class="highlighter-rouge">true</code> if and only if <code class="highlighter-rouge">e</code> evaluates to []</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- null list;
val it = false : bool

</code></pre></div></div>

<ul>
  <li>if <code class="highlighter-rouge">e</code> evaluates to <code class="highlighter-rouge">[v1,v2,...,vn]</code> then <code class="highlighter-rouge">hd e</code> evaluates to <code class="highlighter-rouge">v1</code>
    <ul>
      <li>raise exception if e evaluates to []</li>
    </ul>
  </li>
  <li>if <code class="highlighter-rouge">e</code> evaluates to <code class="highlighter-rouge">[v1,v2,...,vn]</code> then <code class="highlighter-rouge">tl e</code> evaluates to <code class="highlighter-rouge">[v2,...,vn]</code>
    <ul>
      <li>raise exception if e evaluates to []</li>
      <li>Notice result is a list</li>
    </ul>
  </li>
</ul>

<h3 id="type-checking-list-operations">Type-checking list operations</h3>

<p>Lots of new typesï¼š For any type <code class="highlighter-rouge">t</code>, the type <code class="highlighter-rouge">t list</code> describes lists where all elements have type <code class="highlighter-rouge">t</code></p>

<p>æ•°ç»„çš„ç±»å‹ä¸º<code class="highlighter-rouge">t list</code>ï¼Œ<code class="highlighter-rouge">t</code>ä¸ºä»»æ„ç±»å‹</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- [1,2,3];
val it = [1,2,3] : int list

</code></pre></div></div>

<p>Examples:</p>

<p><code class="highlighter-rouge">int list</code> <code class="highlighter-rouge">bool list</code> <code class="highlighter-rouge">int list list</code> <code class="highlighter-rouge">(int * int) list</code> <code class="highlighter-rouge">(int list*int) list</code></p>

<ul>
  <li>So [] can have type t list of any type
    <ul>
      <li>SML uses type <code class="highlighter-rouge">Â·a list</code> to indicate this(â€œquote aâ€ or â€œalphaâ€)</li>
    </ul>
  </li>
  <li>
    <p>For <code class="highlighter-rouge">e1::e2</code> to type-check, we need a <code class="highlighter-rouge">t</code> such that <code class="highlighter-rouge">e1</code> has type <code class="highlighter-rouge">t</code> and <code class="highlighter-rouge">e2</code> has type <code class="highlighter-rouge">t list</code>. Then the result type is <code class="highlighter-rouge">t list</code></p>
  </li>
  <li>null : <code class="highlighter-rouge">.a list -&gt; bool</code></li>
</ul>

<p>Takes a alpha list(any type of list)(Â·a list) and returns a boolean value</p>

<ul>
  <li>
    <p>hd : <code class="highlighter-rouge">.a list -&gt; .a</code></p>
  </li>
  <li>
    <p>tl : <code class="highlighter-rouge">.a list -&gt; .a list</code></p>
  </li>
</ul>

<h2 id="1---9list-function">1 - 9:List Function</h2>

<p>Gain experience with lists and recursion by writing several functions that process and/or produce listsâ€¦</p>

<p>example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun sum_list (xs:int list) = 
	if null xs then 0
	else hd xs + sum_list(tl xs)
	
	
fun countdown(x:int) = 
	if x=0 then []
	else x::countdown(x-1)
	
fun append(xs : int list, ys : int list) =
	if null xs then ys
    else (hd xs) :: append((tl xs),ys)

</code></pre></div></div>
<p>Functions over lists are usually recursive</p>

<ul>
  <li>
    <p>Only way to â€œget to all the elementsâ€</p>
  </li>
  <li>
    <p>what should the answer be for the empty list?</p>
  </li>
  <li>
    <p>what should the answer be for a non-empty list?</p>

    <ul>
      <li>Typically in terms of the answer for the tail of the list !</li>
    </ul>
  </li>
</ul>

<p>Similarly, functions that produce lists of potentially any size will be recursive</p>

<ul>
  <li>You create a list out of smaller list</li>
</ul>

<blockquote>
  <p>åŸºæœ¬ä¸Šå‡½æ•°å‹è¯­è¨€å…³äºæ•°ç»„çš„å¤„ç†éƒ½æ˜¯é€’å½’è¿ç®—ã€‚</p>
</blockquote>

<h2 id="let-expression">Let Expression</h2>

<p>###Review</p>

<p>Huge progress already on the core pieces of ML:</p>

<ul>
  <li>
    <p>Types: <code class="highlighter-rouge">int bool unit t1...tn t list t1...tn-&gt;t</code></p>

    <ul>
      <li>Types are â€œnestâ€(each t above can be itself a compound type)</li>
    </ul>
  </li>
  <li>
    <p>Variables, environments, and basic expressions</p>
  </li>
  <li>
    <p>Functions</p>

    <ul>
      <li>
        <p>Build: <code class="highlighter-rouge">fun x0(x1:t1,....,xn:tn) = e</code></p>
      </li>
      <li>
        <p>Use: e0(e1,e2â€¦en)</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Tuples</p>

    <ul>
      <li>
        <p>Build: <code class="highlighter-rouge">(e1,...,en)</code></p>
      </li>
      <li>
        <p>Use: <code class="highlighter-rouge">#1 e, #2 e, ....</code></p>
      </li>
    </ul>
  </li>
  <li>
    <p>Lists</p>

    <ul>
      <li>
        <p>Build: <code class="highlighter-rouge">[]</code>, <code class="highlighter-rouge">e1::e2</code></p>
      </li>
      <li>
        <p>Use: <code class="highlighter-rouge">null e</code>, <code class="highlighter-rouge">hd e</code>, <code class="highlighter-rouge">tl e</code></p>
      </li>
    </ul>
  </li>
</ul>

<p>###Nowâ€¦</p>

<p>å¼•å…¥å±€éƒ¨å˜é‡</p>

<p>The big thing we need: local bindings</p>

<ul>
  <li>For style and convenience</li>
</ul>

<p>This segment:</p>

<ul>
  <li>Basic let-expressions</li>
</ul>

<p>Next segments:</p>

<ul>
  <li>
    <p>A big but natural idea: nested function bindings</p>
  </li>
  <li>
    <p>For efficiency</p>
  </li>
</ul>

<p>The construct to introduce local bindings is <strong><em>just an expressions</em></strong>*,
so we can use it anywhere an expression can go.</p>

<p>###Let - expressions</p>

<p>3 questions:</p>

<ul>
  <li>
    <p>Syntax: <code class="highlighter-rouge">let b1 b2...bn in e end</code></p>

    <ul>
      <li>Each <code class="highlighter-rouge">bi</code> is any <em>binding</em> and <strong>e</strong> is any expression</li>
    </ul>
  </li>
  <li>
    <p>Type-checking: Type-check each <code class="highlighter-rouge">bi</code> and <code class="highlighter-rouge">e</code> in a static environment that includes the previous bindings.Type of whole let-expression is the type of <code class="highlighter-rouge">e</code>.</p>
  </li>
  <li>
    <p>Evaluation: Evaluate each <code class="highlighter-rouge">bi</code> and <code class="highlighter-rouge">e</code> in a dynamic environment that includes the previous binding.Result of whole let-expression is result of evaluating <code class="highlighter-rouge">e</code>.</p>
  </li>
</ul>

<p>example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun silly1(z:int) = 

	let 
		val x = if z&gt;0 then z else 34
		val y = x + z + 9
	in
		if x&gt;y then x*2 else y*y
	end
	
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func silly2() = 

	let 
		val x = 1
	in 
		//è¿™é‡Œçš„xæ˜¯åœ¨æ–°çš„environmenté‡Œé¢ï¼Œä¸Šé¢çš„xä¼šè¢«shadowæ‰
		(let val x = 2 in x+1 end) + 
		
		//è¿™é‡Œçš„xå€¼ä¸º1
		(let val y=x+2 in y+1 end)
	end
	
</code></pre></div></div>

<p>###Whatâ€™s new</p>

<p>ä¸Šé¢<code class="highlighter-rouge">let in end</code>è¯­æ³•å®é™…ä¸Šæ˜¯å¯¹<strong><em>scope</em></strong>çš„æè¿°ï¼š</p>

<ul>
  <li>
    <p>Whatâ€™s new is scope: where a binding is in the enviroment</p>

    <ul>
      <li>
        <p>In later bindings and body of the let-expression</p>

        <ul>
          <li>(Unless a later or nested binding shadows it)</li>
        </ul>
      </li>
      <li>
        <p>Only in later bindings and body of the let-expression</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Nothing else is new:</p>

    <ul>
      <li>
        <p>Can put any binding we want, event function bindings</p>
      </li>
      <li>
        <p>type-check and evaluate just like at â€œtop-levelâ€</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="1-11nested-functions">1-11ï¼šNested Functions</h2>

<p>###Any binding</p>

<p>According to our rules for let-expressions, we can define functions inside any let-expression</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let b1 b2 ... bn in e end

</code></pre></div></div>
<p>This is a natural idea, and often good style</p>

<p>example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
fun countup_from1(x:int) = 
    let
	fun count (from: int) = 
	    if from = x
	    then x::[]
	    else from :: count(from+1)
    in 
	count(1)
    end
    
    
</code></pre></div></div>

<p>ç”±äºå‡½æ•°æ˜¯first classçš„ï¼Œå¯ä»¥åœ¨å‡½æ•°ä¸­å®šä¹‰å‡½æ•°ï¼Œå¹¶ä¸”åœ¨scopeä¸­ç”Ÿæ•ˆã€‚</p>

<ul>
  <li>
    <p>Functions can use bindings in the environment where they are defined:</p>

    <ul>
      <li>
        <p>Bindings from â€œouterâ€ environments</p>

        <ul>
          <li>Such as parameters to the outer function</li>
        </ul>
      </li>
      <li>
        <p>Earlier bindings in the let-expression</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Unnecessary parameters are usually bad style</p>

    <ul>
      <li>Like to in previous example</li>
    </ul>
  </li>
</ul>

<p>###Nested functions: style</p>

<ul>
  <li>
    <p>Good style to define helper functions inside the functions they help if they are:</p>

    <ul>
      <li>Unlikely to be useful elsewhere</li>
      <li>Likely to be misued if available elsewhere</li>
      <li>Likely to be changed or removed later</li>
    </ul>
  </li>
  <li>
    <p>A fundamental trade-off in code design:reusing code saves effort and avoids bugs, but makes the reused code harder to change later.</p>
  </li>
</ul>

<h2 id="1-12-let-expressions-to-avoid-repeated-comupatation">1-12 Let Expressions to Avoid Repeated Comupatation</h2>

<p>example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun bad_max(xs:int list) = 
    if null xs then 0
    else if null (tl xs) then (hd xs)
    else if hd xs &gt; bad_max(tl xs) then hd xs
    else bad_max(tl xs)
    
let x = bad_max [50,49,...,1]
let y = bad_max [1,2,...,59]  

</code></pre></div></div>
<p>Consider this code and the recursive calls it makes</p>

<ul>
  <li>Donâ€™t worry about calls to <code class="highlighter-rouge">null</code>,<code class="highlighter-rouge">hd</code> and <code class="highlighter-rouge">tl</code> because they do a small constant amount of work</li>
</ul>

<p>ä¸Šé¢ä»£ç çš„æ•ˆç‡ï¼š</p>

<ul>
  <li>
    <p>å¯¹äºç¬¬ä¸€ç§æƒ…å†µ[50,49,â€¦,1]æ‰§è¡Œbad_maxçš„æ¬¡æ•°ä¸º50ã€‚</p>
  </li>
  <li>
    <p>å¯¹äºç¬¬äºŒç§æƒ…å†µ[1,2,â€¦,50]æ¯ä¸€æ¬¡æ‰§è¡Œbad_maxåˆä¼šé€’å½’æ‰§è¡Œä¸¤æ¬¡bad_maxï¼Œæ‰§è¡Œæ¬¡æ•°ä¸º2^50æ–¹</p>
  </li>
</ul>

<p>ä¸€ç§è§£æ³•æ˜¯ç¼“å­˜bad_maxçš„ç»“æœï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun good_max(xs: int list) = 
    if null xs then 0
    else if null (tl xs) then hd xs
    else
	let val tl_ans = good_max(tl xs)
	in
	    if hd xs &gt; tl_ans then hd xs
	    else tl_ans
    end
</code></pre></div></div>

<p>ä¸Šé¢çš„ä»£ç åªè°ƒç”¨good_maxä¸€æ¬¡ã€‚</p>

<h3 id="math-never-lies">Math never lies</h3>

<p>The key is not to do repeated work that might do repeated work that do â€¦</p>

<ul>
  <li>Saving recursive results in local bindings is essential.</li>
</ul>

<p>##Options</p>

<p>Motivedï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun get_ max(xs: int list) = 
    if null xs then 0
    else if null (tl xs) then hd xs
    else
	let val tl_ans = good_max(tl xs)
	in
	    if hd xs &gt; tl_ans then hd xs
	    else tl_ans
    end
</code></pre></div></div>

<h3 id="motivating-options">Motivating Options</h3>

<p>Having <code class="highlighter-rouge">max</code> return 0 for the empty list is really awful</p>

<ul>
  <li>
    <p>Could raise an exception</p>
  </li>
  <li>
    <p>Could return a zero-element or one-element list</p>

    <ul>
      <li>That works but is poor style because the built-in support for options expresses this situation directly</li>
    </ul>
  </li>
</ul>

<p>###Options</p>

<p>ç±»ä¼¼Swiftä¸­çš„optional</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">t option</code> is a type for any type t</p>

    <ul>
      <li>(much like <code class="highlighter-rouge">t list</code>ï¼Œbut a different type, not a list)</li>
    </ul>
  </li>
  <li>
    <p>Building:</p>

    <ul>
      <li>
        <p><code class="highlighter-rouge">NONE</code> has type <code class="highlighter-rouge">.a option</code> (much like[] has type <code class="highlighter-rouge">.a list</code>)</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">SOME e</code> has type <code class="highlighter-rouge">t option</code> if <code class="highlighter-rouge">e</code> has type <code class="highlighter-rouge">t</code>(much like <code class="highlighter-rouge">e::[]</code>)</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Accessing:</p>

    <ul>
      <li>
        <p><code class="highlighter-rouge">isSome</code>  has type <code class="highlighter-rouge">.a option -&gt; bool</code></p>
      </li>
      <li>
        <p><code class="highlighter-rouge">valOf</code> has type <code class="highlighter-rouge">.a option -&gt; .a </code> (exception if given NONE)</p>
      </li>
    </ul>
  </li>
</ul>

<p>æ”¹å†™åçš„maxæ–¹æ³•</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun max1(xs:int list) = 
    if null xs then NONE
    else
	let val tl_ans = max1(tl xs)
	in if isSome tl_ans andalso valof tl_ans &gt; hd xs
	   then tl_ans
	   else SOME(hd xs)
    end

</code></pre></div></div>

<h2 id="1-13-more-boolean-and-comparison-expressions">1-13 More Boolean and Comparison Expressions</h2>

<p>SOme â€œodds and endsâ€ that havenâ€™t come up much yet:</p>

<ul>
  <li>Combining Boolean expressions(and,or,not)</li>
  <li>Comparison operations</li>
</ul>

<p>###Boolean operations</p>

<p><code class="highlighter-rouge">e1 andalso e2</code> =&gt; â€œ&amp;&amp;â€</p>

<table>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">e1 orelse e2</code> =&gt; â€œ</td>
      <td>Â </td>
      <td>â€</td>
    </tr>
  </tbody>
</table>

<p><code class="highlighter-rouge">not e1</code> =&gt; â€œ!â€</p>

<p>###Comparisions</p>

<p><code class="highlighter-rouge">= &lt;&gt; &gt; &lt; &gt;= &lt;=</code></p>

<h2 id="114-a-key-benefit-of-immutable-data">1.14 A Key Benefit of Immutable Data</h2>

<h3 id="a-valuable-non-feature-no-mutation">A valuable non-feature: no mutation</h3>

<p>Have now covered all the features you need.</p>

<p>Now learn a very important <em>non-feature</em>:</p>

<ul>
  <li>
    <p>Huh??How could the lock of a feature be important?</p>
  </li>
  <li>
    <p>When it lets you know things other code will not do with your code and the results your code produces</p>
  </li>
</ul>

<p>A major aspect and contribution of functional programming:</p>

<p>Not being able to assign to (a.k.a. mutate) variables or parts of tuples and lists</p>

<p><strong><em>This is a Big Deal</em></strong></p>

<p>æ„æ€æ˜¯SMLæˆ–è€…å‡½æ•°å‹è¯­è¨€åœ¨è®¾è®¡çš„æ—¶å¯¹æ•°æ®çš„æ“ä½œå°±æ˜¯immutableçš„,è¿™ç§çœ‹ä¼¼çš„ç¼ºé™·åè€Œæˆäº†å®ƒçš„ä¼˜ç‚¹ã€‚</p>

<p>###Cannot tell if you copy</p>

<p>æ¯”è¾ƒä¸‹é¢ä¸¤ä¸ªæ–¹æ³•:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun sort_pair (pr: int * int) = 

	if #1 pr &lt; #2 pr then pr
	else (#2 pr, #1 pr)

</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun sort_pair (pr: int * int) = 

	if #1 pr &lt; #2 pr 
	then (#1 pr, #2 pr)
	else (#2 pr, #1 pr)

</code></pre></div></div>

<p>In ML, there two implementations of <code class="highlighter-rouge">sort_pair</code> are <em>indistinguishable</em></p>

<ul>
  <li>
    <p>But only beacause tuples are immutable</p>
  </li>
  <li>
    <p>The first is better style: simpler and avoids making a new pair in the then-branch</p>
  </li>
  <li>
    <p>In langauges with mutable compound data, these are different!</p>
  </li>
</ul>

<p>ä»å®ç°ä¸Šçœ‹ï¼Œè¿™ä¸¤ç§æ–¹æ³•æ˜¯æœ‰åŒºåˆ«çš„ï¼Œå‰è€…æ˜¯ç›´æ¥è¿”å›äº†å…¥å‚å¯¹è±¡ï¼Œåè€…åˆ™æ˜¯æ–°åˆ›å»ºäº†ä¸€ä¸ª<code class="highlighter-rouge">pr</code>çš„<code class="highlighter-rouge">copy</code>å‡ºæ¥:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val p = (3,4)

val x = sort_pair p

val y = x


</code></pre></div></div>

<p>å¯¹äºç¬¬ä¸€ç§æƒ…å†µï¼Œyæ˜¯pçš„aliasï¼Œå¯¹äºç¬¬äºŒç§æƒ…å†µyæ˜¯pçš„copy</p>

<p>ä½†æ˜¯å¯¹äºä½¿ç”¨è€…æ¥è¯´ï¼Œåœ¨MLä¸­è¿™ä¸¤ç§æ–¹æ³•æ˜¯æ²¡æœ‰åŒºåˆ«çš„ï¼Œå› ä¸ºMLä¸­æ•°æ®ç»“æ„æ˜¯immutableçš„ï¼Œä¹Ÿå°±æ˜¯è¯´pæ— æ³•æ”¹å˜è‡ªå·±çš„å€¼ã€‚</p>

<p>å› æ­¤æ— è®ºæ˜¯å¼•ç”¨è¿˜æ˜¯copy, éƒ½ä¸ä¼šå½±å“yã€‚</p>

<p>é‚£ä¹ˆï¼Œå¦‚æœMLæ˜¯mutableçš„ä¼šæ€ä¹ˆæ ·å‘¢?</p>

<p>å‡å¦‚ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
//å‡å¦‚pä¸­çš„valueå¯ä»¥è¢«ä¿®æ”¹ï¼Œå˜ä¸º(5ï¼Œ4)
 #1 p = 5 
 
 val z = #1 y

</code></pre></div></div>

<p>é‚£ä¹ˆ zçš„å€¼æ˜¯å¤šå°‘å‘¢ï¼Ÿ</p>

<p>å¯¹äºç¬¬ä¸€ç§æƒ…å†µï¼Œyæ˜¯pçš„aliasï¼Œé‚£ä¹ˆzçš„å€¼ä¸º5</p>

<p>å¯¹äºç¬¬äºŒç§æƒ…å†µï¼Œyæ˜¯pçš„copyï¼Œé‚£ä¹ˆzçš„å€¼ä»ä¸º3</p>

<p>è¿™æ ·ä½ å°±å¿…é¡»ä¸åœçš„å»å…³æ³¨yæ˜¯pçš„copyè¿˜æ˜¯aliasã€‚</p>

:ET