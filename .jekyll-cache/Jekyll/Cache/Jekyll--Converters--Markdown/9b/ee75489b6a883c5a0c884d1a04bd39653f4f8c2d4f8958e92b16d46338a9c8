I"¢â<h3 id="functional-programming">Functional Programming</h3>

<p>â€œ<em>Functional Programming</em>â€ can mea a few different things:</p>

<ul>
  <li>Avoid mutation in most cases</li>
  <li>Using functions as values</li>
  <li>Style encouraging recursion and recursive data structures</li>
  <li>Style closer to mathematical definitions</li>
  <li>Programming idioms using laziness</li>
  <li>Anything not OOP or C?(not a good definiation)</li>
</ul>

<p>Not sure a definiation of â€œfunctional languageâ€ exits beyond makes functional programming easy / default / required</p>

<h3 id="first-class-functions">First-class Functions</h3>

<ul>
  <li>First-Class functions: Can use them wherever we use values</li>
  <li>Functions are values too</li>
  <li>Arguments,results parts of tuples, bound to variable, carried by datatype constructors exceptionsâ€¦</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fun</span> <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="n">fun</span> <span class="n">incr</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span>
<span class="n">val</span> <span class="n">a_tuple</span> <span class="o">=</span> <span class="o">(</span><span class="kt">double</span><span class="o">,</span><span class="n">incr</span><span class="o">,</span><span class="kt">double</span><span class="o">(</span><span class="n">incr</span> <span class="mi">7</span><span class="o">))</span>
<span class="n">val</span> <span class="n">eighteen</span> <span class="o">=</span> <span class="o">(</span><span class="err">#</span><span class="mi">1</span> <span class="n">a_tuple</span><span class="o">)</span> <span class="mi">9</span>
</code></pre></div></div>

<ul>
  <li>Most common use is as an argument / result of another function
    <ul>
      <li>Other function is called a <em>higher-order-function</em></li>
      <li>Powerful way to factor out common functionality</li>
    </ul>
  </li>
</ul>

<h3 id="function-closures">Function Closures</h3>

<ul>
  <li>Function closure: Functions can use bindings from outside the function defination(in scope where function is defined)
    <ul>
      <li>Makes first-class functions much more powerful</li>
      <li>Will get to this feature in a bit, after simpler examples</li>
    </ul>
  </li>
  <li>Distinction between terms first-class functions and function closure is not universally understood
    <ul>
      <li>Important conceptual distinction even if terms get muddled</li>
    </ul>
  </li>
</ul>

<h3 id="functions-as-arguments">Functions As Arguments</h3>

<ul>
  <li>We can pass one function as an argument to another function
    <ul>
      <li>Not a new feature,just never thought to do it before</li>
    </ul>
  </li>
  <li>
    <p>Elegant strategy for factoring out common code</p>

    <ul>
      <li>REplace N similar functions with calls to 1 function where you pass in N different(short) functions as arguments.</li>
    </ul>
  </li>
  <li>æ•°å­¦æè¿° : f(g(x))</li>
</ul>

<h2 id="polymorphic-types-and-functions-as-arguments">Polymorphic Types and Functions As Arguments</h2>

<h3 id="the-key-point">The Key point</h3>

<ul>
  <li>
    <p>HOF are often so â€œgenericâ€ and â€œreusableâ€ that they have polymorphic types, i.e, types with type variables</p>
  </li>
  <li>
    <p>But there are HOF that are polymorphic</p>
  </li>
  <li>
    <p>ALways a good idea to understand the type of a a function, especially a HOF</p>
  </li>
</ul>

<h3 id="types">Types</h3>

<p>å‡½æ•°<code class="highlighter-rouge">n_times</code>çš„ç±»å‹ä¸º: <code class="highlighter-rouge">val n_times = fn : ('a -&gt; 'a) * int * 'a -&gt; 'a</code>ï¼Œå…¶ä¸­<code class="highlighter-rouge">'a</code>ä¸ºæ³›å‹ï¼›fnçš„è¿”å›å€¼ç±»å‹è¦å’Œn_timesçš„è¿”å›å€¼ç±»å‹ç›¸åŒï¼›æˆ‘ä»¬å¯ä»¥æŠŠ<code class="highlighter-rouge">n_times</code>ä¸¥æ ¼çš„é™åˆ¶æˆæŸä¸€ç±»å‹:<code class="highlighter-rouge">(int -&gt; int) * int * int -&gt; int</code>ï¼Œä½†æ˜¯è¿™ç§é™åˆ¶æ²¡æœ‰æ„ä¹‰</p>

<blockquote>
  <p>This <em>polymorphism</em> makes <code class="highlighter-rouge">n_times</code> more useful</p>
</blockquote>

<h3 id="anonymous-functions">Anonymous Functions</h3>

<p>ä»¥è¿™ä¸ªå‡½æ•°ä¸ºä¾‹ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun n_times(f,n,x) = 
    if n=0 then x
    else f(n_times(f,n-1,x))
    
fun triple x = 3*x

fun triple_n_times(n,x) = n_times(triple,n,x)

val x3 = triple_n_times(2,3)

</code></pre></div></div>

<p>æ¥ä¸‹æ¥çš„é—®é¢˜æ˜¯å¦‚ä½•å°†<code class="highlighter-rouge">triple</code>å‡½æ•°å˜ä¸ºåŒ¿åå‡½æ•°ä»£å…¥åˆ°<code class="highlighter-rouge">n_times</code>ä¸­</p>

<ul>
  <li>ä½¿ç”¨<code class="highlighter-rouge">let-in-end</code>:</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun triple_n_times(n,x) = n_times(let triple x = x*3 in triple end ,n,x)


</code></pre></div></div>

<ul>
  <li>ä½¿ç”¨åŒ¿åå‡½æ•°:</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun triple_n_times(n,x) = n_times(ï¼ˆfn x =&gt; 3*x),n,x)

</code></pre></div></div>
<p>åŒ¿åå‡½æ•°åªæä¾›ä¸€ä¸ªå‡½æ•°åŸå‹</p>

<ul>
  <li>
    <p>Like all expression forms, can appear anywhere</p>
  </li>
  <li>
    <p>Syntax:</p>

    <ul>
      <li><code class="highlighter-rouge">fn</code> not <code class="highlighter-rouge">fun</code></li>
      <li><code class="highlighter-rouge">=&gt;</code> not <code class="highlighter-rouge">=</code></li>
      <li>no function name,just argument pattern</li>
    </ul>
  </li>
</ul>

<h3 id="using-anonymous-functions">Using anonymous functions</h3>

<ul>
  <li>
    <p>Most common use : Argument to a HOF</p>

    <ul>
      <li>Donâ€™t need a name just to pass a function</li>
    </ul>
  </li>
  <li>
    <p>But : cannot use an anonymous function for a recursive function</p>

    <ul>
      <li>
        <p>Beacause there is no name for making recursive calls</p>
      </li>
      <li>
        <p>If not for recursion, <code class="highlighter-rouge">fun</code>bindings would be syntactic sugar for <code class="highlighter-rouge">val</code> bindings and anonymous functions</p>
      </li>
    </ul>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  fun triple x = 3 * x
	
  val triple = fn y =&gt; 3*y
	
</code></pre></div>    </div>
    <p>ç¬¬ä¸€ä¸ªtripleå®é™…ä¸Šæ˜¯ç¬¬äºŒä¸ªtripleçš„è¯­æ³•ç³–ã€‚</p>

    <p>åŒæ ·ï¼Œ<code class="highlighter-rouge">triple_n_times</code>ä¹Ÿå¯ä»¥å†™æˆè¿™æ ·ï¼Œä½†æ˜¯å¹¶ä¸æ˜¯ä¸€ç§å¥½çš„è¡¨è¿°æ–¹å¼</p>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ( * poor style * )
  fun triple_n_times(n,x) = fn(n,x) =&gt; n_times(ï¼ˆfn x =&gt; 3*x),n,x)

	
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="2-5-unnecessary-function-wrapping">2-5 Unnecessary Function Wrapping</h2>

<p>çœ‹è¿™ä¸ªä¾‹å­ï¼š</p>

<div class="language-ml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">fun</span> <span class="nf">n_times</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="p">=</span> 
    <span class="kr">if</span> <span class="n">n</span><span class="p">=</span><span class="mi">0</span> <span class="kr">then</span> <span class="n">x</span>
    <span class="kr">else</span> <span class="n">f</span><span class="p">(</span><span class="n">n_times</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">n-</span><span class="mi">1</span><span class="p">,</span><span class="n">x</span><span class="p">))</span>
    
<span class="kr">fun</span> <span class="nf">nth_tail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">xs</span><span class="p">)</span> <span class="p">=</span> <span class="n">n_times</span><span class="p">((</span><span class="kr">fn</span> <span class="n">y</span> <span class="p">=&gt;</span> <span class="n">tl</span> <span class="n">y</span><span class="p">),</span> <span class="n">n</span> <span class="p">,</span> <span class="n">xs</span><span class="p">)</span>

</code></pre></div></div>

<p>æ ¹æ®ä¸Šä¸€èŠ‚å­¦åˆ°çš„ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠ<code class="highlighter-rouge">n_times</code>ä¸­çš„<code class="highlighter-rouge">f</code>ç”¨åŒ¿åå‡½æ•°ä»£æ›¿:<code class="highlighter-rouge">fn y =&gt; tl y</code></p>

<p>ä½†æ˜¯è¿™ç§æƒ…å†µä¸‹ä½¿ç”¨åŒ¿å å‡½æ•°æ˜¯ä¸æ­£ç¡®çš„ï¼Œæ­£ç¡®çš„æ˜¯:</p>

<div class="language-ml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">fun</span> <span class="nf">nth_tail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">xs</span><span class="p">)</span> <span class="p">=</span> <span class="n">n_times</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span> <span class="n">n</span> <span class="p">,</span> <span class="n">xs</span><span class="p">)</span>

</code></pre></div></div>

<p>ç”±äº<code class="highlighter-rouge">fn y =&gt; tl y</code>è¡¨è¿°çš„æ„æ€å’Œ<code class="highlighter-rouge">tl</code>ä¸€æ ·ï¼Œå› æ­¤ç›´æ¥ä½¿ç”¨<code class="highlighter-rouge">tl</code>æ›´æœ‰æ•ˆç‡ã€‚</p>

<p>æŠ½è±¡æ¥è¯´å½“ä¸€ä¸ªå‡½æ•°æ»¡è¶³:</p>

<div class="language-ml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">f</span> <span class="n">x</span>

</code></pre></div></div>

<p>ä¸éœ€è¦ä½¿ç”¨åŒ¿åå‡½æ•°ï¼Œç›´æ¥ä½¿ç”¨<code class="highlighter-rouge">f</code>ï¼Œåœ¨çœ‹ä¸€ä¸ªä¾‹å­</p>

<div class="language-ml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">fun</span> <span class="nf">rev</span> <span class="n">xs</span> <span class="p">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">xs</span>

<span class="kr">val</span> <span class="nv">rev</span> <span class="p">=</span> <span class="kr">fn</span> <span class="n">xs</span> <span class="p">=&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">xs</span>

<span class="kr">val</span> <span class="nv">rev</span> <span class="p">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">rev</span>

</code></pre></div></div>

<h2 id="2-6-map-and-filter">2-6 Map and Filter</h2>

<p>###Map</p>

<div class="language-ml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">fun</span> <span class="nf">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">xs</span><span class="p">)</span> <span class="p">=</span> 
    <span class="kr">case</span> <span class="n">xs</span> <span class="kr">of</span> 
	 <span class="p">[]</span> <span class="p">=&gt;</span> <span class="p">[]</span>
      <span class="p">|</span> <span class="n">x</span><span class="p">:</span><span class="n">xs'</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="n">::map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">xs'</span><span class="p">)</span> 


</code></pre></div></div>
<ul>
  <li>mapçš„ç±»å‹ä¸ºï¼š</li>
</ul>

<div class="language-ml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">val</span> <span class="nv">map</span> <span class="p">=</span> <span class="kr">fn</span> <span class="p">:</span> <span class="p">(</span><span class="nd">'a</span> <span class="p">-&gt;</span> <span class="nd">'b</span><span class="p">)</span> <span class="n">*</span> <span class="nd">'a</span> <span class="n">list</span> <span class="p">-&gt;</span> <span class="nd">'b</span> <span class="n">list</span>

</code></pre></div></div>

<ul>
  <li>ä½¿ç”¨map:</li>
</ul>

<div class="language-ml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">val</span> <span class="nv">result</span> <span class="p">=</span> <span class="n">map</span><span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x+</span><span class="mi">1</span> <span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>

</code></pre></div></div>

<ul>
  <li>
    <p>Map is without doubt æ˜¯æœ€æœ‰åçš„ HOF:</p>
  </li>
  <li>
    <p>The name is standard</p>
  </li>
  <li>
    <p>You use it all the time once you know it: saves a little space,ä½†æ˜¯æ›´æ‰¾ä½ æ›´è¦çš„æ˜¯ï¼Œä¿æŒè¿ç®—çš„è¿ç»­æ€§</p>
  </li>
  <li>
    <p>Similar predefined functionï¼š<code class="highlighter-rouge">List.map</code></p>
  </li>
</ul>

 	- But it uses currying 

<p>###Filter</p>

<div class="language-ml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">fun</span> <span class="nf">filter</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">xs</span><span class="p">)</span> <span class="p">=</span> 
    <span class="kr">case</span> <span class="n">xs</span> <span class="kr">of</span> 
	<span class="p">[]</span> <span class="p">=&gt;</span> <span class="p">[]</span>
     <span class="p">|</span> <span class="n">x::xs'</span> <span class="p">=&gt;</span> <span class="kr">if</span> <span class="n">f</span> <span class="n">x</span>
                 <span class="kr">then</span> <span class="n">x::</span><span class="p">(</span><span class="n">filter</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">xs'</span><span class="p">))</span>
		 <span class="kr">else</span> <span class="n">filter</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">xs'</span><span class="p">)</span>

</code></pre></div></div>

<ul>
  <li>filterç±»å‹ä¸ºï¼š</li>
</ul>

<div class="language-ml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">val</span> <span class="nv">filter</span> <span class="p">=</span> <span class="kr">fn</span> <span class="p">:</span> <span class="p">(</span><span class="nd">'a</span> <span class="p">-&gt;</span> <span class="n">bool</span><span class="p">)</span> <span class="n">*</span> <span class="nd">'a</span> <span class="n">list</span> <span class="p">-&gt;</span> <span class="nd">'a</span> <span class="n">list</span>

</code></pre></div></div>

<ul>
  <li>ä½¿ç”¨filter</li>
</ul>

<div class="language-ml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">val</span> <span class="nv">filter_result</span> <span class="p">=</span> <span class="n">filter</span><span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x&gt;</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>

</code></pre></div></div>

<ul>
  <li>Filterä¹Ÿæ˜¯å¾ˆæœ‰åçš„HOF</li>
</ul>

<h2 id="2-7-generalizing-prior-topics">2-7 Generalizing Prior Topics</h2>

<p>Our examples of first-class functions so far have all:</p>

<ul>
  <li>
    <p>Take one function as an argument to another function</p>
  </li>
  <li>
    <p>Processed a number or a list</p>
  </li>
</ul>

<p>But first-class functions are usefule anywhere for any kind of data</p>

<ul>
  <li>
    <p>Can pass serveral functions as arguments</p>
  </li>
  <li>
    <p>Can put functions in data structures</p>
  </li>
  <li>
    <p>Can return funtions as results</p>
  </li>
  <li>
    <p>Can wirte HOF that traverse your own data structures</p>
  </li>
</ul>

<p>Useful whenever you want to abstract over â€œWhat to compute withâ€</p>

<ul>
  <li>No new language features</li>
</ul>

<h3 id="return-function-as-result">Return function as result</h3>

<div class="language-ml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">fun</span> <span class="nf">double_or_triple</span> <span class="n">f</span> <span class="p">=</span> 

	<span class="kr">if</span> <span class="n">f</span> <span class="mi">7</span> 
	<span class="kr">then</span> <span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="mi">2</span><span class="n">*x</span>
	<span class="kr">else</span> <span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="mi">3</span><span class="n">*x</span>

</code></pre></div></div>

<p><code class="highlighter-rouge">double_or_triple</code>çš„ç­¾åä¸ºï¼š<code class="highlighter-rouge">(* (int -&gt; bool) -&gt; (int -&gt; int) * )</code></p>

<p>ä½¿ç”¨ï¼š</p>

<div class="language-ml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">val</span> <span class="nv">double</span> <span class="p">=</span> <span class="n">double_or_triple</span><span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x-</span><span class="mi">3</span> <span class="p">=</span> <span class="mi">4</span><span class="p">)</span>

</code></pre></div></div>

<p>ä½†æ˜¯REPLè¾“å‡ºçš„<code class="highlighter-rouge">double_or_triple</code>çš„ç­¾åä¸º:<code class="highlighter-rouge">(* (int -&gt; bool) -&gt; int -&gt; int * )</code></p>

<p>Because it never prints uncessary parentheses and</p>

<p><code class="highlighter-rouge">t1-&gt;t2-&gt;t3-&gt;t4</code> ç­‰ä»·äº <code class="highlighter-rouge">t1 -&gt; (t2 -&gt; (t3 -&gt; t4))</code></p>

<h2 id="2-8-definition-of-lexical-scope">2-8 Definition of Lexical Scope</h2>

<ul>
  <li>
    <p>We know function bodies can use any bindings in scope</p>
  </li>
  <li>
    <p>But now that functions can be passed around: In scope where?</p>
  </li>
  <li>
    <p>This semantics is called <code class="highlighter-rouge">lexical scope</code></p>
  </li>
  <li>
    <p>There are lots of good reasons for this semantics</p>

    <ul>
      <li>
        <p>Discussed after explaining what the semantics is</p>
      </li>
      <li>
        <p>Later in course: implementing it</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Must â€œget thisâ€ for competent programming</p>
  </li>
</ul>

<p>å°†çš„æ˜¯å˜é‡çš„ä½œç”¨åŸŸ:</p>

<div class="language-ml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">1</span>

<span class="c">(*</span><span class="cm"> f maps to a function that adds 1 to its argument *)</span>
<span class="kr">fun</span> <span class="nf">f</span> <span class="n">y</span> <span class="p">=</span> <span class="n">x</span> <span class="n">+</span> <span class="n">y</span>

<span class="c">(*</span><span class="cm"> x maps to 2 , shadows 1 *)</span>
<span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">2</span> 

<span class="kr">val</span> <span class="nv">y</span> <span class="p">=</span> <span class="mi">3</span>

<span class="c">(*</span><span class="cm"> call the function defined on line2 with 5 *)</span>
<span class="kr">val</span> <span class="nv">z</span> <span class="p">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">x+y</span><span class="p">)</span>

<span class="c">(*</span><span class="cm"> z maps to 6 *)</span>

</code></pre></div></div>
<p>The semantics of functions has two parts:</p>

<ul>
  <li>
    <p>The <code class="highlighter-rouge">code</code> part</p>
  </li>
  <li>
    <p>The <code class="highlighter-rouge">environment</code> that was current when the function was defined</p>
  </li>
  <li>
    <p>This is a â€œpairâ€ but unlike ML pairs, you cannot access the pieces</p>
  </li>
  <li>
    <p>All you do is call this â€œpairâ€</p>
  </li>
  <li>
    <p>This pair is called <code class="highlighter-rouge">function closure</code></p>
  </li>
  <li>
    <p>A call evaluates the code part in the environment part</p>
  </li>
</ul>

<h3 id="coming-up">coming up:</h3>

<ul>
  <li>
    <p>demonstrate how the rule works with HOF</p>
  </li>
  <li>
    <p>why the other natural rule, dynamic scope is a bad idea</p>
  </li>
  <li>
    <p>powerful <code class="highlighter-rouge">idioms</code> with HOF use this rule</p>

    <ul>
      <li>
        <p>Passing functions to iterators like <code class="highlighter-rouge">filter</code></p>
      </li>
      <li>
        <p>Several more idims</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="2-9-why-lexical-scope">2-9 Why lexical scope</h2>

<ul>
  <li>
    <p>Lexical Scope : use environment where function is defined</p>
  </li>
  <li>
    <p>Dynamic Scope : use environment where function is called</p>
  </li>
</ul>

<p>Decades ago, both might have been considered reasonable, but now we know lexical scope makes much more sense</p>

<ul>
  <li>
    <p>Here are three reasions:</p>
  </li>
  <li>
    <p>Function meaning does not depend on variable names used</p>
  </li>
  <li>
    <p>Function can be type-checked and reasoned about where defined</p>
  </li>
  <li>
    <p>Closures can easily store the data they need</p>
  </li>
</ul>

<p>### Does dynamic scope exist?</p>

<ul>
  <li>Lexical scope for variables is definitely the right default</li>
</ul>

 	- Very common across languages

<ul>
  <li>Dynamic scope is occasionally convenient in some situations</li>
</ul>

 	- Some languages(e.g. Racket)have special ways to do it

 	- BUt most do not bother

<ul>
  <li>if you squint some, exception handling is more like dynamic scope:</li>
</ul>

 	- <code class="highlighter-rouge">raise e</code> transfers control to the current innermost handler

 	- Does not have to by syntactically inside a handl expression

<h2 id="2-10-closure-and-recomputation">2-10 Closure and Recomputation</h2>

<h3 id="when-things">When things</h3>

<p>Things we know:</p>

<ul>
  <li>
    <p>A function body is not evaluated until the function is called</p>
  </li>
  <li>
    <p>A function body is evaluated every time the function is called</p>
  </li>
  <li>
    <p>A variable binding evaluates its expression when the binding is evaluated, not every time the variable is used.</p>
  </li>
</ul>

<p>With closures, this means we can avoid repeating computations that do not depend on function arguments</p>

<ul>
  <li>Not so worried about performance but good example to emphasize the semantics of functions</li>
</ul>

<p>è¿™ä¸€èŠ‚çš„Danæƒ³è¡¨è¾¾çš„æ„æ€æ˜¯: closureå¯ä»¥capture valueï¼Œè¿™ä¸ªvalueå¯ä»¥åªè®¡ç®—ä¸€æ¬¡ï¼Œè¿™æ ·å°±é¿å…é‡å¤è®¡ç®—ã€‚</p>

<h2 id="2-11-fold-and-more-closure">2-11 Fold and More Closure</h2>

<h3 id="another-famous-function-fold">Another famous function: Fold</h3>

<p><code class="highlighter-rouge">fold</code>(and synonyms/close relatives reduce, inject,etc.) is another very famous iterator over recursive structures</p>

<p>Accumulates an answer by repeatedly applying <code class="highlighter-rouge">f</code> to answer so far</p>

<ul>
  <li><code class="highlighter-rouge">fold(f,acc,[x1,x2,x3,x4])</code> computes <code class="highlighter-rouge">f(f(f(f(acc,x1),x2),x3),x4)</code></li>
</ul>

<div class="language-ml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">fun</span> <span class="nf">fold</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">acc</span><span class="p">,</span><span class="n">xs</span><span class="p">)</span> <span class="p">=</span> 
    <span class="kr">case</span> <span class="n">xs</span> <span class="kr">of</span> <span class="p">[]</span> <span class="p">=&gt;</span> <span class="n">acc</span>
	    <span class="p">|</span> <span class="n">x::xs</span> <span class="p">=&gt;</span><span class="n">fold</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">f</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span><span class="n">x</span><span class="p">),</span><span class="n">xs</span><span class="p">)</span> 

</code></pre></div></div>

<ul>
  <li>This version â€œfolds leftâ€; another version â€œfolds rightâ€</li>
  <li>Whether the direction matters depends on <code class="highlighter-rouge">f</code>(often not)</li>
</ul>

<p><code class="highlighter-rouge">fold</code>çš„ç­¾åä¸º:</p>

<div class="language-ml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">val</span> <span class="nv">fold</span> <span class="p">=</span> <span class="kr">fn</span> <span class="p">:</span> <span class="p">(</span><span class="nd">'a</span> <span class="n">*</span> <span class="nd">'b</span> <span class="p">-&gt;</span> <span class="nd">'a</span><span class="p">)</span> <span class="n">*</span> <span class="nd">'a</span> <span class="n">*</span> <span class="nd">'b</span> <span class="n">list</span> <span class="p">-&gt;</span> <span class="nd">'a</span>

</code></pre></div></div>

<h3 id="why-iterators-again">Why iterators again?</h3>

<ul>
  <li>
    <p>These â€œiterator-likeâ€ functions are not build into the language</p>

    <ul>
      <li>
        <p>Just a programming pattern</p>
      </li>
      <li>
        <p>Though many languages have built-in support, which often allows stopping early without resorting to exceptions</p>
      </li>
    </ul>
  </li>
  <li>
    <p>This pattern separates recursive traversal from data processing</p>

    <ul>
      <li>
        <p>Can reuse same traversal for different data processing</p>
      </li>
      <li>
        <p>Can reuse same data processing for different data structures</p>
      </li>
      <li>
        <p>In both cases, using common vocabulary concisely communicates intent</p>
      </li>
    </ul>
  </li>
</ul>

<p>è¿™é‡ŒDanæƒ³è¡¨è¾¾çš„æ„æ€æ˜¯ï¼šå¦‚æœæˆ‘ä»¬èƒ½æŠ½è±¡ä¸€ä¸ªè¿­ä»£å™¨å‡ºæ¥ï¼Œé‚£ä¹ˆå¯¹äºå¤æ‚çš„æ•°æ®ç»“æ„ï¼Œä¸€ä¸ªäººå¯ä»¥å¤æ‚å®ç°è¿­ä»£å™¨ï¼Œå¦ä¸€ä¸ªäººå¯ä»¥å®ç°å¤æ‚çš„è®¡ç®—ï¼Œè¿™ä¸¤è€…å‡å¯å¤ç”¨ã€‚</p>

<ul>
  <li>æ•°ç»„æ±‚å’Œï¼š</li>
</ul>

<div class="language-ml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">fun</span> <span class="nf">f_sum</span> <span class="n">xs</span> <span class="p">=</span> <span class="n">fold</span> <span class="p">((</span><span class="kr">fn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">x+y</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>

<span class="kr">val</span> <span class="nv">sum</span> <span class="p">=</span> <span class="n">f_sum</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>

</code></pre></div></div>

<h3 id="iterators-made-better">Iterators made better</h3>

<ul>
  <li>
    <p>Function like <code class="highlighter-rouge">map,filter</code> and <code class="highlighter-rouge">fold</code> are much more powerful thanks to closures and lexical scope</p>
  </li>
  <li>
    <p>Function passed in can use any â€œprivateâ€ data in its environment</p>
  </li>
  <li>
    <p>Iterator â€œdoesnâ€™t event know the data is thereâ€ or what type it has</p>
  </li>
</ul>

<h2 id="2-12--another-closure-idiom-combining-functions">2-12 : Another Closure Idiom: Combining Functions</h2>

<h3 id="more-idioms">More idioms</h3>

<ul>
  <li>
    <p>We know the rule for lexical scope and function closures</p>

    <ul>
      <li>Now what is it good for</li>
    </ul>
  </li>
</ul>

<p>A partial but wide-ranging list:</p>

<ul>
  <li>
    <p>Pass functions with private data to iterators: Done</p>
  </li>
  <li>
    <p>Combine functions(e.g., composition)</p>
  </li>
  <li>
    <p>Currying(multi-arg functions and partial application)</p>
  </li>
  <li>
    <p>Callbacks (e.g., in reactive programming)</p>
  </li>
  <li>
    <p>Implementing an ADT with a record of functions</p>
  </li>
</ul>

<h3 id="combing-functions">Combing Functions</h3>

<p>Canonical example is function composition:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun compose(f,g) = fn x =&gt; f(g x)

</code></pre></div></div>

<ul>
  <li>
    <p>Creates a closure that â€œremembersâ€ what <code class="highlighter-rouge">f</code> and <code class="highlighter-rouge">g</code> are bound to</p>
  </li>
  <li>
    <p>å®ƒçš„ç­¾åä¸º:</p>
  </li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val compose = fn : ('a -&gt; 'b) * ('c -&gt; 'a) -&gt; 'c -&gt; 'b

</code></pre></div></div>

<ul>
  <li>åœ¨MLä¸­ï¼Œè¿™ç§function composeæœ‰ç‰¹æ®Šçš„ç¬¦å·è¡¨ç¤º:</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f o g è¡¨ç¤º f (g x)

</code></pre></div></div>

<ul>
  <li>ä¾‹å­ï¼š</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun sqirt_of_abs i = Math.sqart (Real.fromInt (abs i ))

</code></pre></div></div>
<p>ä¹Ÿå¯ä»¥å†™æˆ:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun sqrt_of_abs i = ( Math.sqrt o Real.fromInt o abs ) i

</code></pre></div></div>

<h3 id="left-to-right-or-right-to-left">Left-to-right or right-to-left</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val sqrt_of_abs  =  Math.sqrt o Real.fromInt o abs 

</code></pre></div></div>

<p>As in math, function composition is â€œright to leftâ€</p>

<ul>
  <li>
    <p>â€œtake absolute value, convert to real, and take square rootâ€</p>
  </li>
  <li>
    <p>â€œsquare root of the conversion to real of absolute valueâ€</p>
  </li>
</ul>

<p>â€œPipelinesâ€ of functions are common in functional programming and many programmers prefer left-to-right</p>

<h2 id="2-13another-closure-idiomcurrying">2-13:Another Closure Idiom:Currying</h2>

<p>###Currying</p>

<ul>
  <li>
    <p>Recall every ML function takes exactly one argument</p>
  </li>
  <li>
    <p>Previously encoded <code class="highlighter-rouge">n</code> arguments via one <code class="highlighter-rouge">n-tuple</code></p>
  </li>
  <li>
    <p>Another Way: Take one argument and return a function that takes another argument and â€¦</p>

    <ul>
      <li>Called â€œcurryingâ€ after famous logican Haskell Curry</li>
    </ul>
  </li>
  <li>
    <p>ä¹‹å‰å¤„ç†å¤šä¸ªå…¥å‚çš„æ–¹å¼ä½¿ç”¨tupleï¼š</p>
  </li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun sorted3_tupled (x,y,z) = z &gt;= y andalso y &gt;= x

val t1 = sorted3_tupled(7,9,11)

</code></pre></div></div>
<ul>
  <li>å¼•å…¥currying:</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val sorted3 = fn x =&gt; fn y =&gt; fn z =&gt; z &gt;=y andalso y &gt;= x

fun sorted x = fn y =&gt; fn z =&gt; z &gt;= y andalso y&gt;=x 

</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val t2 = (((sorted3 7) 9) 11)

</code></pre></div></div>

<ul>
  <li>
    <p>Calling (sorted3 7) returns a closure with:</p>

    <ul>
      <li>Code <code class="highlighter-rouge">fn y =&gt; fn z =&gt; z &gt;= y andalso y&gt;= x</code></li>
      <li>Environment maps <code class="highlighter-rouge">x</code> to <code class="highlighter-rouge">7</code></li>
    </ul>
  </li>
  <li>
    <p>Calling that closure with 9 returns a closure with</p>

    <ul>
      <li>Code <code class="highlighter-rouge">fn z =&gt; z&gt;=y andalso y &gt;= x</code></li>
      <li>Environment maps <code class="highlighter-rouge">x</code> to <code class="highlighter-rouge">7</code>, <code class="highlighter-rouge">y</code> to <code class="highlighter-rouge">9</code></li>
    </ul>
  </li>
  <li>
    <p>Calling that closure with <code class="highlighter-rouge">11</code> returns <code class="highlighter-rouge">true</code></p>
  </li>
</ul>

<h3 id="syntactic-sugar-part1">Syntactic sugar, part1</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val t2 = (((sorted3 7) 9) 11)

</code></pre></div></div>

<ul>
  <li>
    <p>In general , e1, e2, e3, e4, â€¦ means (((e1, e2), e3), e4,)</p>
  </li>
  <li>
    <p>So instead of <code class="highlighter-rouge">(((sorted3 7) 9) 11)</code> can just write <code class="highlighter-rouge">sorted3 7 9 11</code></p>
  </li>
  <li>
    <p>Callers can just think â€œmulti-argument function with spaces instead of tuple expressionâ€</p>

    <ul>
      <li>Different than tupling; caller and callee must use same technique</li>
    </ul>
  </li>
  <li>
    <p>Wrong:</p>
  </li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val wrong1 = sorted3_tupled 7 9 11
val wrong2 = sorted3 (7,9,11)

</code></pre></div></div>

<h3 id="syntactic-sugar-part2">Syntactic sugar, part2</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val sorted3_old = fn x =&gt; fn y =&gt; fn z =&gt; z &gt;=y andalso y &gt;= x

fun sorted3_nicer x y z = z &gt;= y andalso y &gt;= x

val t4 = sorted3_nicer 7 9 11

val t5 = (((sorted3_nicer 7) 9 ) 11)

</code></pre></div></div>

<h2 id="2-14-partial-application">2-14: Partial Application</h2>

<h3 id="too-few-arguments">Too Few Arguments</h3>

<ul>
  <li>
    <p>Previously used currying to simulate multiple arguments</p>
  </li>
  <li>
    <p>But if caller provides â€œtoo fewâ€ arguments, we get back a closure â€œwaiting for the remaining argumentsâ€</p>

    <ul>
      <li>
        <p>Called partial application</p>
      </li>
      <li>
        <p>Convenient and useful</p>
      </li>
      <li>
        <p>Can be done with any curried function</p>
      </li>
    </ul>
  </li>
  <li>
    <p>No new semantics here: a pleasant idiom</p>
  </li>
  <li>
    <p>ä¾‹å­:</p>
  </li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
val sum_partial = fold (fn (x,y) =&gt; x+y) 0 

</code></pre></div></div>

<p>ä¸Šé¢è¿™ä¸ªä¾‹å­ï¼š<code class="highlighter-rouge">fold</code>åº”è¯¥æœ‰ä¸‰ä¸ªå‚æ•°: ä¸€ä¸ªç®—æ•°è¡¨è¾¾å¼ï¼Œä¸€ä¸ªåˆå§‹å€¼ï¼Œä¸€ä¸ªæ•°ç»„ï¼Œæ˜¾ç„¶ä¸Šé¢çš„<code class="highlighter-rouge">sum</code>ç¼ºä¸€ä¸ªå‚æ•°ï¼Œè¿™ä¹Ÿæˆäº†ä¸€ä¸ªå¥½å¤„ï¼Œç›¸å½“äº<code class="highlighter-rouge">sum</code>åªæ¥å—ä¸€ä¸ªæ•°ç»„å‚æ•°:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val sum_partial = fn : int list -&gt; int

</code></pre></div></div>

<p>ä½¿ç”¨<code class="highlighter-rouge">sum_partial</code>æ›´æ–¹ä¾¿:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val sum_value = sum_partial [1,2,3]

</code></pre></div></div>

<p>å¦ä¸€ä¸ªä¾‹å­:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
fun exist f xs = 
	case xs of 
		[] =&gt; false
		| x::xs =&gt; f x orelse exist f xs

</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val no = exist (fn x =&gt; x=7) [4,11,23]

val hasZero = exist (fn x =&gt; x=0 )

</code></pre></div></div>

<h2 id="2-15--currying-wrapup">2-15 : Currying Wrapup</h2>

<h3 id="more-combining-functions">More combining functions</h3>

<ul>
  <li>
    <p>What if you want to curry a tupled function or vice-versa</p>
  </li>
  <li>
    <p>What if a functionâ€™s arguments are in the wrong order for the partial application you want?</p>
  </li>
</ul>

<p>Naturally, it is easy to write higher order wrapper functions</p>

<ul>
  <li>And their types are neat logical formulas</li>
</ul>

<p>å°†çš„æ—¶å¯¹äºä¸€äº›å‚æ•°ä¸æ»¡è¶³è¦æ±‚çš„å‡½æ•°ï¼Œå¦‚ä½•ä½¿ç”¨curryä½¿å…¶æ»¡è¶³æ¡ä»¶:</p>

<ul>
  <li>ä¾‹å­ï¼š</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun range (i,j) = if i&gt;j then [] else i :: range(i+1,j)

</code></pre></div></div>

<p>å¦‚æœè¿™ä¹ˆè°ƒç”¨:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
val countup = range 1 

</code></pre></div></div>
<p>è‚¯å®šæ˜¯ä¸æ»¡è¶³æ¡ä»¶çš„ï¼Œå…¥å‚ä¸æ˜¯tupleï¼Œè¿™ç§æƒ…å†µæˆ‘ä»¬å¯ä»¥ä½¿ç”¨curry functionï¼š</p>

<p>å…ˆå®šä¹‰ä¸ªcurry å‡½æ•°:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun curry f = fn x =&gt; fn y =&gt; f (x,y)

</code></pre></div></div>

<p>æ ¹æ®è¯­æ³•ç³–ï¼Œå±•å¼€ä¸º:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun curry f x y  = f (x,y)

</code></pre></div></div>

<p>è¿™æ—¶å°†<code class="highlighter-rouge">countup</code>å‡½æ•°æ”¹å†™ä¸º:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val countup = curry range 1 

val xs = countup 7 (* [1,2,3,4,5,6,7] * )

</code></pre></div></div>

<p>åŒæ ·æˆ‘ä»¬å¯ä»¥å®šä¹‰<code class="highlighter-rouge">uncurry</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun uncurry f (x,y) = f x y

</code></pre></div></div>

<h3 id="efficiency">Efficiency</h3>

<p>So which is faster: tupling or currying multiple-arguments?</p>

<ul>
  <li>
    <p>They are both constant-time operations, so it doesnâ€™t matter in most of your code</p>
  </li>
  <li>
    <p>For the small part where efficiency matters:</p>

    <ul>
      <li>
        <p>It turns out SML/NJ compiles tuples more efficiently</p>
      </li>
      <li>
        <p>But many other FP implementation do better with currying(OCaml, F#, Haskell)</p>

        <ul>
          <li>So currying is the â€œnormal thingâ€ and programmers read <code class="highlighter-rouge">t1-&gt;t2-&gt;t3-&gt;t4</code> as a 3-argument function that also allows partial applications.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="2-16--mutation">2-16 : Mutation</h2>

<h3 id="ml-hasseparate-mutation">ML has(separate) mutation</h3>

<ul>
  <li>
    <p>Mutable data sturcture are okay in some situations</p>

    <ul>
      <li>
        <p>When â€œupdate to the state of worldâ€ is appropriate moel</p>
      </li>
      <li>
        <p>But want most language constructs truly immutable</p>
      </li>
    </ul>
  </li>
  <li>
    <p>ML does this with a separate construct: references</p>
  </li>
</ul>

<h3 id="references">References</h3>

<ul>
  <li>
    <p>New types: <code class="highlighter-rouge">t ref</code> where <code class="highlighter-rouge">t</code> is a type</p>
  </li>
  <li>
    <p>New expressions:</p>

    <ul>
      <li>
        <p><code class="highlighter-rouge">ref e</code> to create a reference with initial contents <code class="highlighter-rouge">e</code> æŒ‡é’ˆ</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">e1 := e2</code> to update contents èµ‹å€¼</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">!e</code> to retrieve contents å–å€¼</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="reference-example">Reference example</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val x = ref 42
val y = ref 42
val z = x
val _ = x := 43
val w = (!y) + (!z) ï¼ˆ* 85 * ï¼‰

</code></pre></div></div>

<ul>
  <li>
    <p>x binds to ä¸€ä¸ªæŒ‡å‘42çš„æŒ‡é’ˆï¼Œå› æ­¤ï¼Œx+1ä¼šæŠ¥é”™ï¼Œå› ä¸ºxçš„ç±»å‹æ˜¯ <code class="highlighter-rouge">int ref</code>å³intå‹æŒ‡é’ˆ</p>
  </li>
  <li>
    <p>x è‡ªèº«çš„å€¼æ˜¯ä¸å¯ä»¥æ”¹å˜çš„</p>
  </li>
</ul>

<h2 id="2-17--callbacks">2-17 : Callbacks</h2>

<h3 id="callbacks">Callbacks</h3>

<p>A common idiom: Library takes functions to apply later, when an event occurs - examplesï¼š</p>

<ul>
  <li>
    <p>When a key is pressed, mouse moves, data arrivesâ€¦</p>
  </li>
  <li>
    <p>When the program enters some state</p>
  </li>
</ul>

<p>A library may accept multiple callbacks</p>

<ul>
  <li>
    <p>Different callbacks may need different private data with different types</p>
  </li>
  <li>
    <p>Fortunately, a functionâ€™s type does not include the types of bindings in its environment</p>
  </li>
  <li>
    <p>(In OOP,objects and private fields are used similiaryly, e.g, Java Swingâ€™s event-listeners)</p>
  </li>
</ul>

<h3 id="mutable-state">Mutable State</h3>

<p>We really do want the â€œcallbacks registeredâ€ to change when a function to register a callback is called</p>

<h3 id="example-call-back-library">Example call-back library</h3>

<p>Library maintains mutable state for â€œWhat callbacks are thereâ€ and provides a function for accpting new ones</p>

<ul>
  <li>
    <p>A real library would all support removing them,etc.</p>
  </li>
  <li>
    <p>In example, callbacks have type <code class="highlighter-rouge">int -&gt; unit</code></p>
  </li>
</ul>

<p>So the entire public library interface would be the function for registering new callbacks:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val onKeyEvent : (int -&gt; unit) -&gt; unit

</code></pre></div></div>

<p>unit æ˜¯æ— ç”¨çš„è¿”å›å€¼</p>

<p>Because callbacks are executed for side-effect, they may also need mutable state</p>

<h3 id="library-implementation">Library implementation</h3>

<p>å…³äºcallbackçš„å®ç°</p>

<h2 id="2-18--standard-library-doc">2-18 : Standard-Library Doc</h2>

<p>ML, like many languages, has a standard library</p>

<ul>
  <li>
    <p>For things you could not implement on your own</p>

    <ul>
      <li>Examples: Opening a file, setting a timer</li>
    </ul>
  </li>
  <li>
    <p>For things so common, a standard definition is appropriate</p>

    <ul>
      <li>Examples: <code class="highlighter-rouge">List.map</code>, string concatentation</li>
    </ul>
  </li>
  <li>
    <p>Where to look: http://www.standardml.org/Basis/manpages.html</p>
  </li>
</ul>

<h2 id="2-19--implementing-adt-using-closure">2-19 : Implementing ADT using closure</h2>

<p>ç•¥</p>

<h2 id="2-20--closure-idioms-without-closures">2-20 : Closure idioms without Closures</h2>

<h3 id="higher-order-programming">Higher order programming</h3>

<ul>
  <li>
    <p>HOF e.g: with <code class="highlighter-rouge">map</code> and <code class="highlighter-rouge">filter</code> , is great</p>
  </li>
  <li>
    <p>Without closures, we can still do it more manually</p>

    <ul>
      <li>
        <p>In OOP (e.g., Java) with one-method interfaces</p>
      </li>
      <li>
        <p>In procedural(e.g., C)with explicit environment arguments</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Working through this:</p>

    <ul>
      <li>
        <p>Shows connections between languages and features</p>
      </li>
      <li>
        <p>Can help you understand closures and objects</p>
      </li>
    </ul>
  </li>
</ul>

<p>å¦‚ä½•åœ¨Java/Cä¸­å®ç°closure</p>

<h3 id="outline">Outline</h3>

<ul>
  <li>
    <p>This segment:</p>

    <ul>
      <li>
        <p>Just the code we will â€œportâ€ to Java or C</p>
      </li>
      <li>
        <p>Not using statndard library</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Next segments:</p>

    <ul>
      <li>
        <p>The code in Java and C</p>
      </li>
      <li>
        <p>What works well and what is painful</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="2-21--closure-in-java">2-21 : Closure in Java</h2>

<h3 id="java">Java</h3>

<ul>
  <li>
    <p>Java 8 scheduled to have closures(like C#, Scala, Ruby)</p>

    <ul>
      <li>
        <p>Write like <code class="highlighter-rouge">xs.map((x) =&gt; x.age).filter((x) =&gt; x&gt;21).length()</code></p>
      </li>
      <li>
        <p>Make parallelism and collections much easier</p>
      </li>
      <li>
        <p>Encourage less mutation</p>
      </li>
    </ul>
  </li>
  <li>
    <p>But how could we program in an ML style without help</p>

    <ul>
      <li>
        <p>Will not look like the code above</p>
      </li>
      <li>
        <p>Was even more painful before Java had generics</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="one-method-interfaces">One-method interfaces</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface Func&lt;B,A&gt; { B m(A x); }

interface Pred&lt;A&gt; { boolean m(A x); }

</code></pre></div></div>

<ul>
  <li>
    <p>An interface is a named type</p>
  </li>
  <li>
    <p>An object with one method can serve as a closure</p>

    <ul>
      <li>Different instances can have different fields (possibly different types) like different closures can have different environments(possibly different types)</li>
    </ul>
  </li>
  <li>
    <p>So an interface with one method can serve as a function type</p>
  </li>
</ul>

<h2 id="2-22--closure-in-c">2-22 : Closure in C</h2>

<p>ç•¥</p>

<h1 id="chap3">Chap3</h1>

<h2 id="3-0-course-motivation">3-0 Course Motivation</h2>

<ul>
  <li>
    <p>Why learn the fundamental concepts that appear in all languages?</p>
  </li>
  <li>
    <p>Why use languages quite different from C, C++, Java, Python?</p>
  </li>
  <li>
    <p>Why focus on functional programming?</p>
  </li>
  <li>
    <p>Why use ML, Racket, and Ruby in particular?</p>
  </li>
</ul>

<h3 id="caveats">Caveats</h3>

<p>Will give some of my reasons in terms of this course</p>

<ul>
  <li>
    <p>My reasons: more personal opinion than normal lectures</p>

    <ul>
      <li>Other may have equally valid reasons</li>
    </ul>
  </li>
  <li>
    <p>Partial list: surely other good reasons</p>
  </li>
  <li>
    <p>In term of course: Keep discussion informal</p>

    <ul>
      <li>Not rigorous proof that all reasons are correct</li>
    </ul>
  </li>
  <li>
    <p>Will not say one language is â€œbetterâ€ than other</p>
  </li>
</ul>

<h3 id="summary">Summary</h3>

<ul>
  <li>
    <p>No such thing as a â€œbestâ€ PL</p>
  </li>
  <li>
    <p>Fundamental concepts easier to teach in some PLs</p>
  </li>
  <li>
    <p>A good PL is a relevant, elegant interface for writing software</p>

    <ul>
      <li>There is no substitute for precise understanding of PL semantics</li>
    </ul>
  </li>
  <li>
    <p>Functional languages have been on the leading edge for decades</p>

    <ul>
      <li>
        <p>Ideas have been absorbed by the mainstream, but very slowly</p>
      </li>
      <li>
        <p>First-class functions and avoiding mutation increasingly essential</p>
      </li>
      <li>
        <p>Meanwhile, use the ideas to be a better C/Java/PHP hacker</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Many great alternatives to ML, Racket, and Ruby, but each was chosen for a reason and for how they complement each other.</p>
  </li>
</ul>

<h2 id="3-1-why-study-general-pl-concepts">3-1 Why Study General PL Concepts</h2>

<ul>
  <li>
    <p>Semantics:</p>

    <ul>
      <li>
        <p>Correct reasoning about programs, interfaces, and compilers requires a precise knowledge of semantics</p>

        <ul>
          <li>Not â€œI feelâ€¦.â€</li>
          <li>Not â€œI like curly braces more than parenthsesâ€</li>
          <li>Much of software development is designing precise interfaces;</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Idioms make you a better programmer</p>

    <ul>
      <li>
        <p>Best to see in multiple settings, including where they shine</p>
      </li>
      <li>
        <p>See Java in a clearer light even if I never show you Java</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="3-2-are-all-pls-the-same">3-2 Are All PLs the Same?</h2>

<ul>
  <li>
    <p>Yes</p>

    <ul>
      <li>
        <p>Any input-output behavior implementable in language X is implementable in language Y [Church-Turing thesis]</p>
      </li>
      <li>
        <p>Java, ML, and a language with one loop and three infinitely-large integers are the same</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Yes:</p>

    <ul>
      <li>Same fundamentals reappear: variables, abstraction, one-of types, recursive definitionsâ€¦</li>
    </ul>
  </li>
  <li>
    <p>No:</p>

    <ul>
      <li>
        <p>The human condition vs. different cultures(trave to learn more)</p>
      </li>
      <li>
        <p>The default in one language is awkward in another</p>
      </li>
      <li>
        <p>Beware â€œthe Turing tarpitâ€</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="why-fp">Why FP?</h2>

<p>Why spend 60%-80% of course using FP:</p>

<ul>
  <li>
    <p>mutation is dicouraged</p>
  </li>
  <li>
    <p>HOF are very convenient</p>
  </li>
  <li>
    <p>One of types via constructs like datatypes</p>
  </li>
</ul>

<p>Because:</p>

<ul>
  <li>
    <p>These features are invaluable for correct, elegant, efficient</p>
  </li>
  <li>
    <p>Functional languages have always been ahead of their time</p>
  </li>
  <li>
    <p>Functional languages well-suited to where computing is going</p>
  </li>
</ul>

<h3 id="ahead-of-their-time">Ahead of their time</h3>

<p>All these were dismissid as â€œbeautiful, worthless, slow things PL professors make you learnâ€</p>

<ul>
  <li>
    <p>Garbage collection(Java didnâ€™t exist in 1995, PL courses did)</p>
  </li>
  <li>
    <p>Generics(<code class="highlighter-rouge">List&lt;T&gt;</code> in Java, <code class="highlighter-rouge">C#</code>), much more like SML than C++</p>
  </li>
  <li>
    <p>XML for universal data representation(like Racket/Scheme/LISP/â€¦)</p>
  </li>
  <li>
    <p>HOF(Ruby,Javascript,C#â€¦)</p>
  </li>
  <li>
    <p>Type inference(C#,Scalaâ€¦)</p>
  </li>
  <li>
    <p>Recursion(a big fight in 1960 about this - Iâ€™m told)</p>
  </li>
  <li>
    <p>â€¦</p>
  </li>
</ul>

<h3 id="the-future-may-resemble-the-past">The future may resemble the past</h3>

<p>Somehow nobody notices we are right â€¦ 20 years later</p>

<ul>
  <li>
    <p>â€œTo conquerâ€ vs. â€œto assimilateâ€</p>
  </li>
  <li>
    <p>Societal progress takes time and muddles â€œtake creditâ€</p>
  </li>
  <li>
    <p>Maybe pattern-matching, currying, hygienic macros, etc. will be next</p>
  </li>
</ul>

<h3 id="recent-surge-part1">Recent Surge part1</h3>

<ul>
  <li>
    <p>Clojure</p>
  </li>
  <li>
    <p>Erlang</p>
  </li>
  <li>
    <p>F#</p>
  </li>
  <li>
    <p>Haskell</p>
  </li>
  <li>
    <p>OCaml</p>
  </li>
  <li>
    <p>Scala</p>
  </li>
</ul>

<p>In general , see http://cufp.org</p>

<h3 id="recent-surge-part2">Recent Surge part2</h3>

<p>Popular adoption of concepts:</p>

<ul>
  <li>
    <p>C#, LINQ (closures, type inference,â€¦)</p>
  </li>
  <li>
    <p>Java 8 (closures)</p>
  </li>
  <li>
    <p>MapReduce / Hadoop</p>

    <ul>
      <li>Avoiding side-effects essential for fault-tolerance here</li>
    </ul>
  </li>
  <li>
    <p>..</p>
  </li>
</ul>

<h3 id="why-a-surge">Why a surge?</h3>

<p>My best guesses:</p>

<ul>
  <li>
    <p>Concise, elegant, productive programming</p>
  </li>
  <li>
    <p>Javascript, Python, Ruby helped break the Java/C/C++ hegemony</p>
  </li>
  <li>
    <p>Avoiding mutation is the easiset way to make concurrent and parallel programming easier</p>

    <ul>
      <li>In general, to handle sharing in complex systems</li>
    </ul>
  </li>
  <li>
    <p>Sure, functional programming is still a small niche, but there is so much software in the world today even niches have room</p>
  </li>
</ul>

<h2 id="why-mlracketruby">Why ML,Racket,Ruby?</h2>

<h3 id="the-languages-together">The languages together</h3>

<p>SML, Racket, and Ruby are a useful combination for us</p>

<table>
  <thead>
    <tr>
      <th>Â </th>
      <th>dynamically typed</th>
      <th>statically typed</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>functional</td>
      <td>Racket</td>
      <td>SML</td>
    </tr>
    <tr>
      <td>object-oriented</td>
      <td>Ruby</td>
      <td>Java/C#/Scala</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>ML: polymorphic types, pattern-matching, abstract types &amp; modules</p>
  </li>
  <li>
    <p>Racket : dynamic typing, â€œgoodâ€ macros, minimalist syntax, eval</p>
  </li>
  <li>
    <p>Ruby: classes but not types, very OOP, mixins</p>
  </li>
  <li>
    <p>â€¦</p>
  </li>
</ul>

<p>Really wish we had more time:</p>

<ul>
  <li>
    <p>Haskell: laziness, purity, type classes, monads</p>
  </li>
  <li>
    <p>Prolog: unification and backtracking</p>
  </li>
  <li>
    <p>â€¦</p>
  </li>
</ul>

<h3 id="but-why-not">But why notâ€¦</h3>

<p>Instead of SML, could use similar languages easy to learn after:</p>

<ul>
  <li>
    <p>OCaml: yes indeed but would have to port all my materials</p>

    <ul>
      <li>And a few small thingsâ€¦</li>
    </ul>
  </li>
  <li>
    <p>F#: yes and very cool, but needs a .Net platform</p>

    <ul>
      <li>And a few more small thingsâ€¦</li>
    </ul>
  </li>
  <li>
    <p>Haskell: more popular, cooler types, but lazy semantics and type classes from day 1</p>
  </li>
</ul>

<p>Admittedly, SML and its implementations are showing their age, but it still makes for a shine foundation in statically typed , eager functional programming</p>

<p>Instead of Racket, could use similar languages easy to learn after:</p>

<ul>
  <li>Scheme, List, Clojure,â€¦</li>
</ul>

<p>Racket has a combination of</p>

<ul>
  <li>
    <p>A modern feel and active evolution</p>
  </li>
  <li>
    <p>â€œBetterâ€ macros, modules, structs, constracts,â€¦</p>
  </li>
  <li>
    <p>A large user base and community(not just for education)</p>
  </li>
  <li>
    <p>An IDE tailored to education</p>
  </li>
</ul>

<p>Could easily define our own language in the Racket system</p>

<ul>
  <li>Would rather use a good and vetted design</li>
</ul>

<p>Instead of Ruby, could use another language:</p>

<ul>
  <li>
    <p>Python,Perl, Javascript are also dynamically typed, but are not as â€œfullyâ€ OOP, which is what I want to focus on</p>

    <ul>
      <li>
        <p>Python also does not have closures</p>
      </li>
      <li>
        <p>Javascript also does not have classes but is OOP</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Smalltalk serves my OOP needs</p>

    <ul>
      <li>
        <p>But implementation merge language / environment</p>
      </li>
      <li>
        <p>Less modern syntax, user base, etc</p>
      </li>
    </ul>
  </li>
</ul>

<p>###Is this real programming?</p>

<ul>
  <li>
    <p>The way we use ML/Racket/Ruby can make them seem almost â€œsillyâ€ precisely because lecture and homework focus on insteresting langaguge constructs</p>
  </li>
  <li>
    <p>â€œRealâ€ programming needs IO, string operations, floating-point, graphics, project managers, testing framework, threads, build systemsâ€¦</p>

    <ul>
      <li>
        <p>Many elegant languages have all that and more</p>

        <ul>
          <li>Including Racket and Ruby</li>
        </ul>
      </li>
      <li>
        <p>If we used Java the same way, Java would seem â€œsillyâ€ too</p>
      </li>
    </ul>
  </li>
</ul>

<h1 id="chap4">Chap4</h1>

<h2 id="4-0-remaining-ml-topics">4-0: Remaining ML Topics</h2>

<h3 id="remaining-topics">Remaining Topics:</h3>

<ul>
  <li>
    <p>Type Inference</p>
  </li>
  <li>
    <p>Mutual Recursion</p>
  </li>
  <li>
    <p>Module System</p>
  </li>
  <li>
    <p>Equivalence</p>
  </li>
</ul>

<h2 id="4-1-type-inference">4-1: Type Inference</h2>

<h3 id="type-checking">Type-checking</h3>

<ul>
  <li>
    <p>(Static)type-checking can reject a program before it runs to prevent the possibility of some errors</p>

    <ul>
      <li>A feature of statically typed languages</li>
    </ul>
  </li>
  <li>
    <p>Dynamically typed languages do little such checking</p>

    <ul>
      <li>So might try to treat a number as a function at run-time</li>
    </ul>
  </li>
  <li>
    <p>Will study relative advantages after some Racket</p>

    <ul>
      <li>Racket, Ruby (Python, Javascriptâ€¦) dynamically typed</li>
    </ul>
  </li>
  <li>
    <p>ML(and Java,C#,Scala,C,C++)is statically typed</p>

    <ul>
      <li>Every binding has one type, determined â€œat complie-timeâ€</li>
    </ul>
  </li>
</ul>

<h3 id="impicitly-typed">Impicitly typed</h3>

<ul>
  <li>
    <p>ML is statically typed</p>
  </li>
  <li>
    <p>ML is implicitly typed: rarely need to write down types</p>
  </li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun f x =  (* infer val f : int -&gt; int *)
	
	if x &gt; 3
	then 42
	else x * 2

</code></pre></div></div>

<ul>
  <li>Statically typed: Much more like Java than Javascript</li>
</ul>

<h3 id="type-infernce">Type infernce</h3>

<ul>
  <li>
    <p>Type inference problem: Give every binding/expression a type such that type-checking succeeds</p>

    <ul>
      <li>Fail if and only if no solution exists</li>
    </ul>
  </li>
  <li>
    <p>In principle, could be a pass before the type-checker</p>

    <ul>
      <li>But often implemented together</li>
    </ul>
  </li>
  <li>
    <p>Type inference can be easy, difficult or impossible</p>

    <ul>
      <li>
        <p>Easy: Accept all programs</p>
      </li>
      <li>
        <p>Easy: Reject all programs</p>
      </li>
      <li>
        <p>Subtle, elegant, and not magic: ML</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="4-1-ml-type-inference">4-1 ML Type Inference</h2>

<p>#Chap 5: Summary of SML</p>

:ET