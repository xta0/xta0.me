I"6B<h2 id="stl容器概述">STL容器概述</h2>

<ul>
  <li>容器：可容纳各种类型的通用数据结构，是<mark>类模板</mark>。STL容器按照存放的数据结构类型，可分为三种，分别为顺序容器，关联容器，和容器适配器。</li>
  <li>迭代器：可以用于依次存取容器中的元素，类似指针</li>
  <li>算法：用来操作容器中的元素的函数模板
    <ul>
      <li><code class="highlighter-rouge">sort()</code>来对一个vector中的数据进行排序</li>
      <li><code class="highlighter-rouge">find()</code>来搜索一个list中的对象</li>
    </ul>
  </li>
</ul>

<p>算法本身与他们操作的数据类型无关，因此可以用在简单的数组到高级的数据结构中使用。</p>

<h3 id="迭代器">迭代器</h3>

<p>STL算法以及STL容器中的操作大部分需要使用迭代器来完成，以访问容器中的元素为例，少数顺序容器重载了<code class="highlighter-rouge">[]</code>可支持元素的随机访问，其余容器需要先找到该元素的迭代器，再通过迭代器来访问元素内容。这个设计和其它编程语言有些不同，因此对于初学C++的人或者从别的动态语言转过来的开发者来说，需要先适应并熟悉迭代器。对于迭代器，下面几点需要重点理解。</p>

<ul>
  <li>迭代器范围
    <ul>
      <li><code class="highlighter-rouge">[begin, end)</code>，<code class="highlighter-rouge">end</code>指向容器最后一个元素的下一个位置</li>
    </ul>
  </li>
  <li>容器头尾迭代器
    <ul>
      <li><code class="highlighter-rouge">begin/end</code>: 返回指向容器中第一个/最后一个元素的迭代器</li>
      <li><code class="highlighter-rouge">rbegin/rend</code>:返回指向容器中最后一个/第一个元素的迭代器</li>
      <li><code class="highlighter-rouge">cbegin/rend</code> 返回一个const类型的迭代器</li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it5</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="c1">//显式指定类型</span>
<span class="n">list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it6</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="c1">//是普通迭代器还是const迭代器依赖a的类型</span>
<span class="k">auto</span> <span class="n">it7</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="c1">//根据a的类型来返回是否是const迭代器</span>
<span class="k">auto</span> <span class="n">it8</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span> <span class="c1">//不管a的类型，一定返回一个const迭代器</span>
</code></pre></div></div>
<p>对于非集合类的静态数组，也可以使用迭代器</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="o">!=</span><span class="n">end</span><span class="p">){</span>
	<span class="c1">//found</span>
<span class="p">}</span> 
</code></pre></div></div>
<p>对于动态数组，则不能使用<code class="highlighter-rouge">std::begin</code>和<code class="highlighter-rouge">std::end</code></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">4</span><span class="p">]{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="o">!=</span><span class="n">end</span><span class="p">){</span>
	<span class="c1">//found</span>
<span class="p">}</span> 
</code></pre></div></div>

<h2 id="顺序容器">顺序容器</h2>

<h3 id="几种顺序容器概述">几种顺序容器概述</h3>

<ul>
  <li>元素是非排序的，元素的插入位置与元素的值无关。</li>
  <li><code class="highlighter-rouge">vector</code>
    <ul>
      <li>头文件<code class="highlighter-rouge">&lt;vector&gt;</code></li>
      <li>动态数组。元素在内存中连续存放。</li>
      <li>支持随机访问随机存取任何元素都能在常数时间完成。</li>
      <li>在尾端增删元素具有较佳的性能（大部分情况下是常数时间）</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">array</code>
    <ul>
      <li>头文件<code class="highlighter-rouge">&lt;array&gt;</code>，<mark>C++ 11</mark>新增</li>
      <li>支持随机访问</li>
      <li>固定大小数组，不能添加或者删除元素</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">deque</code>
    <ul>
      <li>头文件<code class="highlighter-rouge">&lt;deque&gt;</code></li>
      <li>双向队列，元素在内存内连续存放</li>
      <li>支持随机访问你，随机存取任何元素都能在常数时间完成（但次于vector）。</li>
      <li>在两端增删元素具有较佳的性能</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">list</code>
    <ul>
      <li>头文件<code class="highlighter-rouge">&lt;list&gt;</code></li>
      <li>双向链表，元素在内存中不连续存放。</li>
      <li>在任何位置增删元素都能在常数时间完成</li>
      <li>不支持下标随机存取，支持双向顺序访问</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">forward_list</code>
    <ul>
      <li>头文件<code class="highlighter-rouge">&lt;list&gt;</code>，<mark>C++ 11</mark>新增</li>
      <li>单向链表，元素在内存中不连续存放。</li>
      <li>在任何位置增删元素都能在常数时间完成</li>
      <li>不支持下标随机存取，支持单向顺序访问</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">string</code>
    <ul>
      <li>同<code class="highlighter-rouge">vector</code>，字符容器</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">stack</code>
    <ul>
      <li>头文件<code class="highlighter-rouge">&lt;stack&gt;</code></li>
      <li>栈，是项的有限序列，并满足序列中被删除</li>
      <li>检索和修改的项只能是最近插入序列的项（栈顶的项）</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">queue</code>
    <ul>
      <li>头文件<code class="highlighter-rouge">&lt;queue&gt;</code></li>
      <li>队列，插入只可以在尾部进行，删除</li>
      <li>检索和修改只允许从头部进行，先进先出</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">priority_queue</code>
    <ul>
      <li>头文件<code class="highlighter-rouge">&lt;queue&gt;</code></li>
      <li>优先级队列</li>
    </ul>
  </li>
</ul>

<h3 id="顺序容器api">顺序容器API</h3>

<ul>
  <li>顺序容器的<strong>初始化</strong>方式</li>
</ul>

<table>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">C c</code></td>
      <td>默认构造函数，如果<code class="highlighter-rouge">C</code>是一个<code class="highlighter-rouge">array</code>，则<code class="highlighter-rouge">c</code>中元素按默认方式初始化；否则<code class="highlighter-rouge">c</code>为空</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">C c1(c2)</code> or <code class="highlighter-rouge">C c1=c2</code></td>
      <td>拷贝构造，<code class="highlighter-rouge">c1</code>初始化为<code class="highlighter-rouge">c2</code>的拷贝</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">C c{a,b,c..}</code> or <code class="highlighter-rouge">C c={a,b,c...}</code></td>
      <td>使用初始化列表，<code class="highlighter-rouge">c</code>初始化为initialize list中元素的<mark>拷贝</mark>。初始化列表中元素的个数必须小于等于<code class="highlighter-rouge">array</code>的大小，遗漏的元素进行默认初始化</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">C c(start, end)</code></td>
      <td>使用迭代器初始化，<code class="highlighter-rouge">c</code>初始化为迭代器<code class="highlighter-rouge">start</code>和<code class="highlighter-rouge">end</code>指定范围中的元素的拷贝</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">C c(n)</code></td>
      <td><code class="highlighter-rouge">c</code>包含<code class="highlighter-rouge">n</code>个元素，这些元素进行了值初始化（默认值），string不适用</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">C c(n,t)</code></td>
      <td><code class="highlighter-rouge">c</code>包含<code class="highlighter-rouge">n</code>个值为<code class="highlighter-rouge">t</code>的元素</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>顺序容器的<strong>赋值</strong>操作</li>
</ul>

<table>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">c1=c2</code></td>
      <td>c1的元素替换为c2元素的拷贝, c1和c2类型相同</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c={a,b,c,...}</code></td>
      <td>c元素替换为初始化列表中元素的拷贝</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">swap(c1,c2)</code></td>
      <td>交换c1和c2中的元素，swap操作不对任何元素进行拷贝，删除或者插入操作，因此可以在常数时间完成，<mark>swap通常比从c2拷贝到c1快的多</mark></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">seq.assign(b,e)</code></td>
      <td>将<code class="highlighter-rouge">seq</code>中的元素替换为迭代器<code class="highlighter-rouge">b</code>和<code class="highlighter-rouge">e</code>中间的元素，迭代器不能指向<code class="highlighter-rouge">seq</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">seq.assign(il)</code></td>
      <td>将<code class="highlighter-rouge">seq</code>中的元素替换为初始化列表中的元素</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">seq.assign(n,t)</code></td>
      <td>将<code class="highlighter-rouge">n</code>个值为<code class="highlighter-rouge">t</code>的元素</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>顺序<strong>容器的大小</strong></li>
</ul>

<table>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">size()</code></td>
      <td>容器中元素数目，<code class="highlighter-rouge">forward_list</code>不支持该操作</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">empty()</code></td>
      <td>如果容器中元素个数为0返回<code class="highlighter-rouge">true</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">max_size</code></td>
      <td>返回一个大于或等于该类容器所能容纳的最大元素数值</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>顺序容器<strong>比较</strong></li>
</ul>

<ol>
  <li>如果两个容器大小相等，元素值相等，则这两个容器相等</li>
  <li>如果两个容器大小不同，但较小的容器中的每个元素都等于较大元素中的每个元素，则较小容器小于较大容器</li>
  <li>如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span> <span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v3</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span> <span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v4</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span>

<span class="n">v1</span> <span class="o">&lt;</span> <span class="n">v2</span> <span class="c1">// true; </span>
<span class="n">v1</span> <span class="o">&lt;</span> <span class="n">v3</span> <span class="c1">// false; </span>
<span class="n">v1</span> <span class="o">==</span> <span class="n">v4</span> <span class="c1">// true; </span>
<span class="n">v1</span> <span class="o">==</span> <span class="n">v2</span> <span class="c1">// false; </span>
</code></pre></div></div>

<ul>
  <li><strong>添加元素</strong></li>
</ul>

<ol>
  <li>添加元素会导致容器元素个数增加，因此<code class="highlighter-rouge">array</code>不支持该操作</li>
  <li><code class="highlighter-rouge">forward_list</code>不支持<code class="highlighter-rouge">push_back</code></li>
  <li><code class="highlighter-rouge">vector</code>和<code class="highlighter-rouge">string</code>不支持<code class="highlighter-rouge">push_front</code>和<code class="highlighter-rouge">emplace_front</code></li>
</ol>

<blockquote>
  <p>这里忽略了对<code class="highlighter-rouge">emplace</code>操作的讨论，个人认为用处不大</p>
</blockquote>

<table>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">c.push_back(t)</code></td>
      <td>在<code class="highlighter-rouge">c</code>尾部追加元素</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.push_front(t)</code></td>
      <td>在<code class="highlighter-rouge">c</code>头部追加元素</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.insert(p,t)</code></td>
      <td>在迭代器<code class="highlighter-rouge">p</code>的<mark>位置之前</mark>插入元素<code class="highlighter-rouge">t</code>,返回<code class="highlighter-rouge">p+1</code>的位置</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.insert(p,n,t)</code></td>
      <td>在迭代器<code class="highlighter-rouge">p</code>的<mark>位置之前</mark>插入<code class="highlighter-rouge">n</code>个元素<code class="highlighter-rouge">t</code>,返回<code class="highlighter-rouge">p+1</code>的位置</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.insert(p,b,e)</code></td>
      <td>在迭代器<code class="highlighter-rouge">b</code>和<code class="highlighter-rouge">e</code>中的元素插入到<code class="highlighter-rouge">p</code>的<mark>位置之前</mark>,返回<code class="highlighter-rouge">p+1</code>的位置</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.insert(p,il)</code></td>
      <td><code class="highlighter-rouge">il</code>是一组花括号包围的元素值列表，将这些值插入到迭代器<code class="highlighter-rouge">p</code>的<mark>位置之前</mark>,返回<code class="highlighter-rouge">p+1</code>的位置</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><strong>访问</strong></li>
</ul>

<table>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">c.back()</code></td>
      <td>返回尾部元素的<mark>引用</mark></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.front()</code></td>
      <td>返回头部元素的引用</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c[n]</code></td>
      <td>返回<code class="highlighter-rouge">n</code>下标对应元素的引用</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.at(n)</code></td>
      <td>返回<code class="highlighter-rouge">n</code>下标对应元素的引用</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><strong>删除</strong></li>
</ul>

<table>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">c.pop_back()</code></td>
      <td>删除尾部元素</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.pop_front()</code></td>
      <td>删除头部元素</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.erase(p)</code></td>
      <td>删除迭代器<code class="highlighter-rouge">p</code>指向的元素，返回<code class="highlighter-rouge">p+1</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.erase(b,e)</code></td>
      <td>删除<code class="highlighter-rouge">b</code>和<code class="highlighter-rouge">e</code>中的元素，返回<code class="highlighter-rouge">e+1</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.clear()</code></td>
      <td>删除全部元素</td>
    </tr>
  </tbody>
</table>

<h3 id="array">Array</h3>

<p><mark>C++ 11</mark>新增的<mark>静态数组</mark>类<code class="highlighter-rouge">array</code>,构造时必须要同时指定传入类型和size。 和C的静态数组不同的是，<code class="highlighter-rouge">array</code>可以拷贝和赋值</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//类型为42个int型数组</span>
<span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">10</span><span class="o">&gt;</span> <span class="n">ia1</span><span class="p">;</span> <span class="c1">//初始化10个默认值的int数组</span>
<span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">10</span><span class="o">&gt;</span> <span class="n">ia2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
<span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">10</span><span class="o">&gt;</span> <span class="n">ia3</span> <span class="o">=</span> <span class="p">{</span><span class="mi">42</span><span class="p">};</span> <span class="c1">//ia3[0]为42，其余为0</span>
<span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">10</span><span class="o">&gt;</span> <span class="n">ia4</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="c1">//所有元素均为0</span>
<span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">10</span><span class="o">&gt;</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">ia3</span><span class="p">;</span> <span class="c1">//正确，类型匹配即合法</span>
</code></pre></div></div>

<h3 id="list">List</h3>

<p><mark>List是双向链表，不支持完全随机访问, 不能用标准库中的`sort`函数排序</mark>，排序需要使用自己的<code class="highlighter-rouge">sort</code>成员函数<code class="highlighter-rouge">void sort()</code>，默认将<code class="highlighter-rouge">list</code>中的元素按照<code class="highlighter-rouge">&lt;</code>排列，</p>

<ul>
  <li>
    <p>实现比较函数</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Compare</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="nf">sort</span><span class="p">(</span><span class="n">Compare</span> <span class="n">op</span><span class="p">);</span> <span class="c1">//list中的排序规则由op(x,y)的返回值指定</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">Comp</span><span class="p">{</span>
      <span class="nl">public:</span>
          <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">c1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">c2</span><span class="p">){</span>
              <span class="k">return</span> <span class="n">c1</span><span class="o">&lt;</span><span class="n">c2</span><span class="p">;</span>
          <span class="p">}</span>
  <span class="p">};</span>

  <span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">lst</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="n">lst</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">Comp</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>只能使用双向迭代器</p>
    <ul>
      <li>迭代器不支持大于/小于的比较运算符，不支持<code class="highlighter-rouge">[]</code>运算符和随机移动</li>
    </ul>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span><span class="p">;</span>
  <span class="n">numbers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">numbers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">numbers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="n">numbers</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">itor</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="n">itor</span><span class="o">++</span><span class="p">;</span>
  <span class="n">itor</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">itor</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span> <span class="c1">//在第二个位置插入100, 返回第三个位置的迭代器</span>
  <span class="n">itor</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">itor</span><span class="p">);</span> <span class="c1">//删除第三个元素，返回第四个位置的迭代器</span>
  <span class="c1">//遍历</span>
  <span class="k">for</span><span class="p">(;</span><span class="n">itor</span><span class="o">!=</span><span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="o">++</span><span class="n">itor</span><span class="p">){</span>
      <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">itor</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
      <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">itor</span> <span class="o">==</span> <span class="mi">2</span><span class="p">){</span>
          <span class="n">numbers</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">itor</span><span class="p">,</span><span class="mi">1234</span><span class="p">);</span><span class="c1">//在2之前插入1234</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="deque">deque</h3>

<ul>
  <li>双向队列：double ended queue</li>
  <li>包含头文件<code class="highlighter-rouge">#include&lt;deque&gt;</code></li>
  <li><code class="highlighter-rouge">deque</code>可以<code class="highlighter-rouge">push_front</code>和<code class="highlighter-rouge">pop_front</code></li>
</ul>

<h2 id="关联容器">关联容器</h2>

<p>标准库提供8个关联容器，这个8个容器的不同点体现在下面3个维度上：</p>

<ol>
  <li>或者是一个<code class="highlighter-rouge">set</code>或者是一个<code class="highlighter-rouge">map</code></li>
  <li>是否允许集合内存在重复元素</li>
  <li>元素在集合内是否按顺序存储。无序的容器以<code class="highlighter-rouge">unordered</code>开头</li>
</ol>

<ul>
  <li>有序容器
    <ul>
      <li><code class="highlighter-rouge">set</code></li>
      <li><code class="highlighter-rouge">multiset</code></li>
      <li><code class="highlighter-rouge">map</code></li>
      <li><code class="highlighter-rouge">multimap</code></li>
    </ul>
  </li>
  <li>无序容器
    <ul>
      <li><code class="highlighter-rouge">unordered_map</code></li>
      <li><code class="highlighter-rouge">unorderd_multimap</code></li>
      <li><code class="highlighter-rouge">unordered_set</code></li>
      <li><code class="highlighter-rouge">unordered_multiset</code></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>对于关联容器，通常不使用泛型算法，而是使用其自带的算法API，其原因有两点：1.是关联容器的key都是const的，对于需要修改容器内容的泛型算法不适合。 2.对于只读的泛型算法，比如find，只能对容器进行顺序检索，而如果使用关联容器自带的find算法则会进行hash查找，效率要高很多。</p>
</blockquote>

<h3 id="关联容器的迭代器">关联容器的迭代器</h3>

<ul>
  <li>对于map中的每个pair，key是const的，不能修改</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">m</span> <span class="p">{</span> <span class="p">{</span><span class="s">"abc"</span><span class="p">,</span><span class="mi">100</span><span class="p">}</span> <span class="p">};</span>
<span class="k">auto</span> <span class="n">itor</span> <span class="o">=</span> <span class="n">map</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="n">itor</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="s">"def"</span><span class="p">;</span> <span class="c1">//wrong! key是const</span>
</code></pre></div></div>

<ul>
  <li>对于set中的每个元素是const的，不能修改</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">itor</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="o">*</span><span class="n">itor</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">//wrong, set中的key是const</span>
</code></pre></div></div>

<ul>
  <li>集合的遍历</li>
</ul>

<p>对于关联容器，可以使用迭代器进行遍历，对于map，集合中的每个元素是pair对象</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">m</span> <span class="p">{</span> <span class="p">{</span><span class="s">"abc"</span><span class="p">,</span><span class="mi">100</span><span class="p">},{</span><span class="s">"def"</span><span class="p">,</span><span class="mi">101</span><span class="p">}</span> <span class="p">};</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">itor</span><span class="o">=</span><span class="n">m</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">itor</span><span class="o">!=</span><span class="n">m</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">itor</span><span class="o">++</span><span class="p">){</span>
	<span class="c1">//itor是指向pair的指针，用-&gt;访问</span>
	<span class="n">string</span> <span class="n">key</span> <span class="o">=</span> <span class="n">itor</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">value</span> <span class="o">=</span> <span class="n">itor</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//range loop</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">p</span> <span class="o">:</span> <span class="n">m</span><span class="p">){</span>
	<span class="c1">//此时p是pair对象，不是itor，访问元素用.</span>
	<span class="n">string</span> <span class="n">key</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">value</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="关联容器api">关联容器API</h3>

<ul>
  <li><strong>添加元素</strong></li>
</ul>

<table>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">c.insert(v)</code></td>
      <td>v是value_type对象</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.insert(b,e)</code></td>
      <td>向c中插入迭代器b，e中的元素，返回void</td>
    </tr>
  </tbody>
</table>

<p>对于map，如果集合中已经有相同key的元素，则插入无效，并返回一个pair，类型为<code class="highlighter-rouge">pair&lt;map&lt;string,size_t&gt;::iterator, bool&gt;</code>，其中pair的first指向插入元素的itor，pair的second表示插入是否成功。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">word_count</span><span class="p">;</span>
<span class="n">string</span> <span class="n">word</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">word</span><span class="p">){</span>
	<span class="k">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">word_count</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">word</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span> 
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">.</span><span class="n">second</span><span class="p">){</span> <span class="c1">//word已经在集合中</span>
		<span class="o">++</span><span class="n">ret</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span> <span class="c1">//更新已有元素的数量</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>对于multimap，insert没有限制。实际中，用到multimap的场景不多，multimap适用于一对多的结构，例如我们可能想建立作者到他的著作之间的映射，一个作者可能有多份著作，这时我们需要用multimap</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">multimap</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">authors</span><span class="p">;</span>
<span class="n">authors</span><span class="p">.</span><span class="n">insert</span><span class="p">{</span> <span class="p">{</span><span class="s">"John Smith"</span><span class="p">,</span><span class="s">"Book#1"</span><span class="p">}</span> <span class="p">};</span>
<span class="n">authors</span><span class="p">.</span><span class="n">insert</span><span class="p">{</span> <span class="p">{</span><span class="s">"John Smith"</span><span class="p">,</span><span class="s">"Book#2"</span><span class="p">}</span> <span class="p">};</span>
</code></pre></div></div>
<p>此时可以无需关心insert的返回值。</p>

<ul>
  <li><strong>删除元素</strong></li>
</ul>

<p>关联容器提供了三种删除元素的API</p>

<table>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">c.erase(k)</code></td>
      <td>删除key为k的元素，返回删除元素数量，类型为<code class="highlighter-rouge">size_type</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.erase(p)</code></td>
      <td>从c中删除迭代器p指定的元素。p不能为<code class="highlighter-rouge">c.end()</code>，返回值为p后面的迭代器</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.erase(b,e)</code></td>
      <td>删除<code class="highlighter-rouge">b</code>和<code class="highlighter-rouge">e</code>中的元素，返回<code class="highlighter-rouge">e</code></td>
    </tr>
  </tbody>
</table>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//map</span>
<span class="kt">size_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">word_count</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="s">"kate"</span><span class="p">));</span> <span class="c1">//ret为0或1</span>
<span class="c1">//multimap</span>
<span class="k">auto</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">author</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="s">"John Smith"</span><span class="p">);</span> <span class="c1">//ret&gt;=0</span>
</code></pre></div></div>

<ul>
  <li><strong>下标操作</strong></li>
</ul>

<table>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">c.[k]</code></td>
      <td>返回关key为k的元素，如果k不在c中，则会创建一个key为k的元素，并对其初始化</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.at(k)</code></td>
      <td>访问key为k的元素，带参数检查，如果k不在c中，则抛异常</td>
    </tr>
  </tbody>
</table>

<p>对于下标操作需要注意三点：</p>

<ol>
  <li>
    <p><code class="highlighter-rouge">c[k]</code>返回的类型是<code class="highlighter-rouge">map&lt;k,v&gt;::mapped_type</code>不是<code class="highlighter-rouge">map&lt;k,v&gt;::value_type</code>。而解引用一个map迭代器会返回<code class="highlighter-rouge">value_type</code>类型，也就是<code class="highlighter-rouge">pair</code>类型，因为对<code class="highlighter-rouge">map</code>来说，它的都是<code class="highlighter-rouge">pair</code>对象，因此<code class="highlighter-rouge">value_type</code>类型自然是<code class="highlighter-rouge">pair</code>类型</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">KeyObject</span> <span class="n">k3</span> <span class="o">=</span> <span class="p">{</span><span class="s">"Jason"</span><span class="p">,</span><span class="mi">33</span><span class="p">};</span>
 <span class="n">m</span><span class="p">[</span><span class="n">k3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
 <span class="n">map</span><span class="o">&lt;</span><span class="n">KeyObject</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">mapped_type</span> <span class="n">mt</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">k3</span><span class="p">];</span> <span class="c1">//mt 是int类型</span>
 <span class="n">map</span><span class="o">&lt;</span><span class="n">KeyObject</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">value_type</span> <span class="n">vt</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">k3</span><span class="p">];</span> <span class="c1">//wrong! m[k3]返回的是mapped_type,不是value_type</span>

 <span class="c1">//对迭代器介解引用，得到value_type类型</span>
 <span class="k">auto</span> <span class="n">itor</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
 <span class="n">map</span><span class="o">&lt;</span><span class="n">KeyObject</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">::</span><span class="n">value_type</span> <span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">itor</span><span class="p">;</span> <span class="c1">//p是pair类型</span>
 <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">get_name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li><code class="highlighter-rouge">c[k]</code>返回的是左值引用，可以对value进行修改。</li>
  <li>注意副作用，如果<code class="highlighter-rouge">k</code>不在<code class="highlighter-rouge">c</code>中，<code class="highlighter-rouge">c[k]</code>会创建一个key为k的对象</li>
</ol>

<ul>
  <li><strong>查找操作</strong></li>
</ul>

<table>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">c.find(k)</code></td>
      <td>返回key为k的元素的迭代器，如果不存在，则返回<code class="highlighter-rouge">c.end()</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.count(k)</code></td>
      <td>返回key为k的元素个数</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.lower_bound(k)</code></td>
      <td>返回集合中第一个key大于等于k的元素的迭代器</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.upper_bound(k)</code></td>
      <td>返回集合中第一个key大于k的元素的迭代器</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.equal_range(k)</code></td>
      <td>返回一个迭代器pair，表示key为k的元素范围，如果k不存在，则pair的两个值均为<code class="highlighter-rouge">c.end()</code></td>
    </tr>
  </tbody>
</table>

<p>对于查找的API，如果是map或是set则很好理解，如果是multimap或multiset则需要考虑重复key的问题，例如我们想找出某个key对应的所有value，可以用下面几种方法</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//使用count</span>
<span class="n">string</span> <span class="n">author</span> <span class="o">=</span> <span class="s">"John Smith"</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">entries</span> <span class="o">=</span> <span class="n">authors</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">author</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">itor</span> <span class="o">=</span> <span class="n">authors</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">author</span><span class="p">);</span>
<span class="k">while</span><span class="p">(</span><span class="n">entries</span><span class="p">){</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">itor</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
	<span class="o">++</span><span class="n">itor</span><span class="p">;</span>
	<span class="o">--</span><span class="n">entries</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//使用lower，upper bound</span>
<span class="k">auto</span> <span class="n">itor_lo</span> <span class="o">=</span> <span class="n">authors</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">author</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">itor_hi</span> <span class="o">=</span> <span class="n">authors</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">author</span><span class="p">);</span> 
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">itor</span> <span class="o">=</span><span class="n">lo</span><span class="p">;</span> <span class="n">itor</span><span class="o">!=</span><span class="n">hi</span><span class="p">;</span> <span class="n">itor</span><span class="o">++</span><span class="p">){</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">itor</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//使用equal range</span>
<span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">authors</span><span class="p">.</span><span class="n">equal_range</span><span class="p">(</span><span class="n">author</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">itor</span><span class="o">=</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">;</span> <span class="n">itor</span><span class="o">!=</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">;</span><span class="n">itor</span><span class="o">++</span><span class="p">){</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">itor</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="setmultiset">set/multiset</h3>

<ul>
  <li><code class="highlighter-rouge">set</code>和<code class="highlighter-rouge">multiset</code>表示数学中集合</li>
  <li>集合内的元素均是有序存储的，默认比较器为<code class="highlighter-rouge">std::less&lt;T&gt;</code>值小的元素在前面。</li>
  <li><code class="highlighter-rouge">set</code>不允许集合中的有重复元素。<code class="highlighter-rouge">multiset</code>允许。</li>
  <li><code class="highlighter-rouge">set</code>和<code class="highlighter-rouge">multiset</code>底层实现为BST。</li>
  <li>如果<code class="highlighter-rouge">set/multiset</code>中保存的是自定义元素，则需要显示指定序函数</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Sales_Data</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sale_Data</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
	<span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">isbn</span><span class="p">()</span><span class="o">&lt;</span><span class="n">rhs</span><span class="p">.</span><span class="n">isbn</span><span class="p">();</span>
<span class="p">};</span>
<span class="n">set</span><span class="o">&lt;</span><span class="n">Sales_Data</span><span class="p">,</span><span class="k">decltype</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ss</span><span class="p">(</span><span class="n">comp</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="pair">pair</h3>

<ul>
  <li>定义:</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T2</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">pair</span><span class="p">{</span>
	<span class="k">typedef</span> <span class="n">T1</span> <span class="n">first_type</span><span class="p">;</span>
	<span class="k">typedef</span> <span class="n">T2</span> <span class="n">second_type</span><span class="p">;</span>
	<span class="n">T1</span> <span class="n">first</span><span class="p">;</span>
	<span class="n">T2</span> <span class="n">second</span><span class="p">;</span>
	<span class="n">pair</span><span class="p">()</span><span class="o">:</span><span class="n">first</span><span class="p">(),</span><span class="n">second</span><span class="p">(){}</span>
	<span class="n">pair</span><span class="p">(</span><span class="k">const</span> <span class="n">T1</span><span class="o">&amp;</span> <span class="n">_a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T2</span><span class="o">&amp;</span> <span class="n">_b</span><span class="p">)</span><span class="o">:</span><span class="n">first</span><span class="p">(</span><span class="n">_a</span><span class="p">),</span><span class="n">second</span><span class="p">(</span><span class="n">_b</span><span class="p">)</span>	<span class="p">{}</span>
	<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">U1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U2</span><span class="o">&gt;</span>
	<span class="n">pair</span><span class="p">(</span><span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">_U1</span><span class="p">,</span><span class="n">_U2</span><span class="o">&gt;&amp;</span> <span class="n">_p</span><span class="p">)</span><span class="o">:</span><span class="n">first</span><span class="p">(</span><span class="n">_p</span><span class="p">.</span><span class="n">first</span><span class="p">),</span><span class="n">second</span><span class="o">:</span><span class="p">(</span><span class="n">_p</span><span class="p">.</span><span class="n">second</span><span class="p">){</span>
	
	<span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">map</code>,<code class="highlighter-rouge">multimap</code>容器里存放着的都是pair模板类对象，且first从小到大排序，第三个构造函数用法实例：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//创建pair</span>
<span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">5.5</span><span class="p">,</span><span class="mf">4.6</span><span class="p">))</span>
<span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">p</span><span class="p">.</span><span class="n">second</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">process</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
		<span class="k">return</span> <span class="p">{</span><span class="n">v</span><span class="p">.</span><span class="n">back</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">size</span><span class="p">()};</span>
		<span class="c1">//或者使用make_pair</span>
		<span class="k">return</span> <span class="n">make_pair</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">back</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">size</span><span class="p">())</span>
	<span class="p">}</span><span class="k">else</span><span class="p">{</span>
		<span class="k">return</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">//隐式构造</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="mapmultimap">map/multimap</h3>

<ul>
  <li><strong>有序的</strong>k-v集合，元素按照<code class="highlighter-rouge">key</code><strong>从小到大</strong>排列，缺省情况下用<code class="highlighter-rouge">less&lt;key&gt;</code>即<code class="highlighter-rouge">&lt;</code>定义</li>
  <li>map中元素类型为<code class="highlighter-rouge">pair</code>模板。<code class="highlighter-rouge">first</code>返回key，<code class="highlighter-rouge">second</code>返回value，<mark>注意，返回类型为引用</mark></li>
  <li><code class="highlighter-rouge">map</code>支持下标访问<code class="highlighter-rouge">[]</code>成员函数，支持k-v赋值</li>
  <li><code class="highlighter-rouge">multimap</code>由于支持重复元素的存放，因此不支持基于<code class="highlighter-rouge">[]</code>的下标访问，插入元素只能使用<code class="highlighter-rouge">insert</code>方法</li>
  <li><mark>若没有关键字key的元素，则会往pairs里插入一个关键字为key的元素，其值用无参构造函数初始化，并返回其值的引用</mark></li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ages</span><span class="p">{</span> <span class="p">{</span><span class="s">"Joyce"</span><span class="p">,</span><span class="mi">12</span><span class="p">},</span> <span class="p">{</span><span class="s">"Austen"</span><span class="p">,</span><span class="mi">23</span><span class="p">}</span> <span class="p">};</span>
<span class="n">ages</span><span class="p">[</span><span class="s">"mike"</span><span class="p">]</span><span class="o">=</span><span class="mi">40</span><span class="p">;</span>
<span class="n">ages</span><span class="p">[</span><span class="s">"kay"</span><span class="p">]</span><span class="o">=</span><span class="mi">20</span><span class="p">;</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">map</span><span class="p">[</span><span class="s">"kay"</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="c1">//add</span>
<span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">peter</span><span class="p">(</span><span class="s">"peter"</span><span class="p">,</span><span class="mi">44</span><span class="p">);</span>
<span class="n">ages</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">perter</span><span class="p">);</span>
<span class="c1">//find</span>
<span class="k">if</span><span class="p">(</span><span class="n">ages</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"Vickey"</span><span class="p">)</span><span class="o">!=</span><span class="n">ages</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span> <span class="c1">//find返回一个迭代器</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Found"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">itor</span><span class="o">=</span><span class="n">ages</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">itor</span><span class="o">!=</span><span class="n">ages</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">itor</span><span class="o">++</span><span class="p">){</span>
	<span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">itor</span><span class="p">;</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>使用自定义对象作为<code class="highlighter-rouge">key</code>，需要重载<code class="highlighter-rouge">operator&lt;(...)</code></li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span><span class="p">{</span>
<span class="nl">private:</span>
	<span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
	<span class="n">string</span> <span class="n">name</span><span class="p">;</span>
<span class="nl">public:</span>
	<span class="n">Person</span><span class="p">()</span><span class="o">:</span><span class="n">name</span><span class="p">(</span><span class="s">""</span><span class="p">),</span><span class="n">age</span><span class="p">(</span><span class="mi">0</span><span class="p">){}</span>
	<span class="n">Person</span><span class="p">(</span><span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">){</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
		<span class="n">age</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">age</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">Person</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span><span class="p">)</span><span class="o">:</span><span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span><span class="n">age</span><span class="p">(</span><span class="n">age</span><span class="p">){}</span>
	<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>  <span class="c1">//重载&lt;做比较运算,声明成const，不会改变内部状态</span>
		<span class="k">return</span> <span class="n">age</span><span class="o">&lt;</span><span class="n">p</span><span class="p">.</span><span class="n">age</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="n">map</span><span class="o">&lt;</span><span class="n">Person</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">people</span><span class="p">;</span>
	<span class="n">people</span><span class="p">[</span><span class="n">Person</span><span class="p">(</span><span class="s">"mike"</span><span class="p">,</span><span class="mi">44</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>
	<span class="n">people</span><span class="p">[</span><span class="n">Person</span><span class="p">(</span><span class="s">"kay"</span><span class="p">,</span><span class="mi">22</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>使用自定义比较函数</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//注意比较的是两个key，不是两个pari</span>
<span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">p2</span><span class="p">){</span>
	<span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">//map只支持key的比较，不支持基于value的比较函数</span>
<span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dict</span><span class="p">(</span><span class="n">comp</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="无序容器">无序容器</h3>

<p><mark>C++ 11</mark>标准库提供了4个无序容器，这些容器不使用比较运算符类组织元素，而是使用哈希函数和key类型的<code class="highlighter-rouge">==</code>运算符。在key类型没有顺序要求的情况下，使用无序的容器更轻量和简单。</p>

<p>无序容器在存储上的组织为一组桶，每个桶保存0个或多个元素，元素通过一个哈希函数映射到某个桶中，映射过程中可能会出现哈希碰撞，导致不同的元素映射到同一个桶中，此时需要遍历桶中的元素来找到待查元素。无序容器提供了一组管理桶的函数，这些函数可以让我们查询每个桶的状态。</p>

<table>
  <tbody>
    <tr>
      <td>桶接口</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.bucket_count()</code></td>
      <td>正在使用桶的数目</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.max_bucket_count()</code></td>
      <td>容器能容纳的最多的桶的数量</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.bucket_size(n)</code></td>
      <td>第n个桶中有多少元素</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.bucket(k)</code></td>
      <td>key为k的元素在哪个桶中</td>
    </tr>
    <tr>
      <td>桶迭代</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">local_iterator</code></td>
      <td>可以用来访问桶中元素的迭代器类型</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">const_local_iterator</code></td>
      <td>桶迭代器的const版本</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.begin(),c.end()</code></td>
      <td>返回桶n内元素的首尾迭代器</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.cbegin(),c.cend()</code></td>
      <td>返回桶n内元素的首尾const类型迭代器</td>
    </tr>
    <tr>
      <td>哈希策略</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.load_factor</code></td>
      <td>返回已使用桶数量和全部桶数量的比值</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.max_load_factor</code></td>
      <td>load_factor的最大比值，超过这个值，容器将rehash，使load_factor&lt;max_load_factor</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.rehash(n)</code></td>
      <td>重新存储，使<code class="highlighter-rouge">bucket_count&gt;n</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">c.reserve(n)</code></td>
      <td>重新存储，使c可以保存n个元素而不必rehash</td>
    </tr>
  </tbody>
</table>

<p>无序容器需要key实现<code class="highlighter-rouge">==</code>运算符和一个哈希函数来生成哈希值。因此对于一个自定义类型的key，要自己实现这两个函数。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Sale</span><span class="p">{</span>
    <span class="n">string</span> <span class="n">data</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
    <span class="n">Sale</span><span class="p">(</span><span class="n">string</span> <span class="n">_data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_num</span><span class="p">)</span><span class="o">:</span><span class="n">data</span><span class="p">(</span><span class="n">_data</span><span class="p">),</span><span class="n">num</span><span class="p">(</span><span class="n">_num</span><span class="p">){}</span>
	<span class="c1">//实现==</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Sale</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">num</span> <span class="o">==</span> <span class="n">s</span><span class="p">.</span><span class="n">num</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">//指定hash函数</span>
<span class="k">namespace</span> <span class="n">std</span><span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">Sale</span><span class="o">&gt;</span><span class="p">{</span>
        <span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Sale</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
            <span class="k">return</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Sale</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">(</span>
	<span class="p">{</span> <span class="p">{</span><span class="s">"Jason"</span><span class="p">,</span><span class="mi">22</span><span class="p">},</span><span class="mi">100</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">{</span><span class="s">"Jacob"</span><span class="p">,</span><span class="mi">23</span><span class="p">},</span><span class="mi">101</span> <span class="p">}</span>
<span class="p">);</span>
</code></pre></div></div>
<p>另一个常见的例子是使用<code class="highlighter-rouge">unordered_map</code>存放<code class="highlighter-rouge">pair&lt;T1,T2&gt;</code>类型的数据，此时由于<code class="highlighter-rouge">T1,T2</code>的类型未知，因此<code class="highlighter-rouge">pair</code>并不知道如何计算自己的哈希值，因此需要使用者提供哈希函数:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">pair_hash</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T2</span><span class="o">&gt;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="n">T2</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">h1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">h2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>

        <span class="c1">// Mainly for demonstration purposes, i.e. works but is overly simple</span>
        <span class="k">return</span> <span class="n">h1</span> <span class="o">^</span> <span class="n">h2</span><span class="p">;</span>  
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">using</span> <span class="n">memo</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">unordered_map</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">memo</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">pair_hash</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">unordered_map</span> <span class="n">um</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="容器适配器">容器适配器</h2>

<p><mark>适配器</mark>是标准库中的一个通用概念，容器，迭代器和函数都有适配器，本质上，一个适配器是一种机制，能够使某种事物物的行为看起来像另一种事务。一个容器适配器接受一个已有的容器，通过某种操作，使其具有另外的一些行为。如果<code class="highlighter-rouge">stack</code>适配器可以用<code class="highlighter-rouge">vector</code>或者<code class="highlighter-rouge">list</code>实现，使其具有<code class="highlighter-rouge">stack</code>的性质。</p>

<ul>
  <li>可以用某种顺序容器实现
    <ul>
      <li><code class="highlighter-rouge">stack</code> : LIFO</li>
      <li><code class="highlighter-rouge">queue</code>: FIFO</li>
      <li><code class="highlighter-rouge">priority_queue</code>: 优先级队列，最高优先级元素第一个出列</li>
    </ul>
  </li>
  <li>通用API
    <ul>
      <li><code class="highlighter-rouge">push/pop</code>：添加，删除一个元素</li>
      <li><code class="highlighter-rouge">top</code>: 返回容器头部元素的引用</li>
    </ul>
  </li>
  <li><mark>容器适配器上**没有迭代器**</mark>
    <ul>
      <li>STL中各种排序，查找，变序等算法不适合容器适配器</li>
    </ul>
  </li>
</ul>

<h3 id="stack">stack</h3>

<p>LIFO数据结构，只能插入，删除，访问栈顶元素。可用<code class="highlighter-rouge">vector</code>,<code class="highlighter-rouge">list</code>,<code class="highlighter-rouge">deque</code>来实现，<mark>默认情况下用`deque`实现</mark>，<code class="highlighter-rouge">vector</code>和<code class="highlighter-rouge">deque</code>实现性能优于<code class="highlighter-rouge">list</code>实现</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Cont</span><span class="o">=</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">stack</span><span class="p">{};</span>
</code></pre></div></div>

<h3 id="queue">queue</h3>

<p>FIFO数据结构，和<code class="highlighter-rouge">stack</code> 基本类似, 可以用 <code class="highlighter-rouge">list</code>和<code class="highlighter-rouge">deque</code>实现，缺省情况下用deque实现</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Cont</span> <span class="o">=</span> <span class="n">deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">queue</span> <span class="p">{};</span>
</code></pre></div></div>

<h3 id="priority_queue">priority_queue</h3>

<ol>
  <li>优先级队列，默认是最大堆，最大元素在队头，可以用<code class="highlighter-rouge">vector</code>和<code class="highlighter-rouge">deque</code>实现，缺省情况下用<code class="highlighter-rouge">vector</code>实现</li>
  <li><code class="highlighter-rouge">priority_queue</code> 通常用<strong>堆排序</strong>实现, 保证最大的元素总是在最前面(<mark>最大堆</mark>),默认的元素比较器是 <code class="highlighter-rouge">less&lt;T&gt;</code></li>
  <li>执行pop操作时, 删除的是最大的元素</li>
  <li>执行top操作时, 返回的是最大元素的引用</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;queue&gt;
#include &lt;iostream&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="n">priority_queue</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">priorities</span><span class="p">;</span>
<span class="n">priorities</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mf">3.2</span><span class="p">);</span>
<span class="n">priorities</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mf">9.8</span><span class="p">);</span>
<span class="n">priorities</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mf">5.4</span><span class="p">);</span>
<span class="k">while</span><span class="p">(</span> <span class="o">!</span><span class="n">priorities</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">priorities</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>	
	<span class="n">priorities</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="c1">//输出结果: 9.8 5.4 3.2</span>
<span class="p">}</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></div></div>
<p>除了使用STL提供的比较函数之外，我们还可以自定义比较函数</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//使用lambda表达式自定义比较函数</span>
<span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">*</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">*</span> <span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="p">,</span><span class="n">ListNode</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">pq</span><span class="p">([](</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">l1</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">*</span> <span class="n">l2</span> <span class="p">){</span>
	<span class="k">return</span> <span class="n">l1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">l2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">//也可以换种写法</span>
<span class="k">auto</span> <span class="n">compare</span> <span class="o">=</span> <span class="p">[](</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">l1</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">*</span> <span class="n">l2</span><span class="p">){</span>
	<span class="k">return</span> <span class="n">l1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">l2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">*</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">*</span> <span class="o">&gt;</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">compare</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">pq</span><span class="p">(</span><span class="n">compare</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="http://www.charleshouserjr.com/Cplus2.pdf">C++ Primer</a></li>
</ul>
:ET