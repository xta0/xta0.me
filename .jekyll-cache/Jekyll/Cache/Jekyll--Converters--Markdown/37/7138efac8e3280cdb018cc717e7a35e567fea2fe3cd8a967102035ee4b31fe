I"4<h3>Renderer</h3>

<p>openGL渲染图像，使用的是自己的context和layer：CAEAGLLayer和EAGLContext，context指向一块内存缓冲区。openGL需要用到两个缓冲区：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
	帧缓冲区:渲染单独一帧需要保存的各种数据
	渲染缓冲区：渲染这一帧所在的位置,渲染之后会变成CAEAGLayer的缓冲区
*/</span>
    <span class="n">GLuint</span> <span class="n">viewFramebuffer</span><span class="p">,</span><span class="n">viewRenderbuffer</span><span class="p">;</span>
</code></pre></div></div>

<p>此外，还有一个深度缓冲区，在渲染3d场景时，物体间有深度关系，假设有两个物体A，B。A在B的前面，那么我们如果先渲染A，再渲染B，那就会导致B显示在A的前面，因此需要一个深度缓冲区，引擎会通过深度缓冲区对物体进行深度排序，但这样会损耗性能，好的办法是，按照深度顺序来渲染object。如果是2d图像，则不需要使用深度缓冲区。</p>

<p>当renderer创建的时候，我们需要通知openGL，我们的缓冲区在哪里：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glGenFramebuffersOES</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">viewFramebuffer</span><span class="p">);</span>
<span class="n">glGenRenderbuffersOES</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">viewRenderbuffer</span><span class="p">);</span>

<span class="n">glBindFramebufferOES</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER_OES</span><span class="p">,</span> <span class="n">viewFramebuffer</span><span class="p">);</span>
<span class="n">glBindRenderbufferOES</span><span class="p">(</span><span class="n">GL_RENDERBUFFER_OES</span><span class="p">,</span> <span class="n">viewRenderbuffer</span><span class="p">);</span>
<span class="n">glFramebufferRenderbufferOES</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER_OES</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0_OES</span><span class="p">,</span> <span class="n">GL_RENDERBUFFER_OES</span><span class="p">,</span> <span class="n">viewRenderbuffer</span><span class="p">);</span>

</code></pre></div></div>
<p>然后，当要渲染layer的时候，根据layer的width和height确定缓冲去的大小：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glBindRenderbufferOES</span><span class="p">(</span><span class="n">GL_RENDERBUFFER_OES</span><span class="p">,</span> <span class="n">viewFramebuffer</span><span class="p">);</span>
<span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">context</span> <span class="n">renderbufferStorage</span><span class="o">:</span><span class="n">GL_RENDERBUFFER_OES</span> <span class="n">fromDrawable</span><span class="o">:</span><span class="n">layer</span><span class="p">];</span>
<span class="n">glGetRenderbufferParameterivOES</span><span class="p">(</span><span class="n">GL_RENDERBUFFER_OES</span><span class="p">,</span> <span class="n">GL_RENDERBUFFER_WIDTH_OES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">backingWidth</span><span class="p">);</span>
<span class="n">glGetRenderbufferParameterivOES</span><span class="p">(</span><span class="n">GL_RENDERBUFFER_OES</span><span class="p">,</span> <span class="n">GL_RENDERBUFFER_HEIGHT_OES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">backingHeight</span><span class="p">);</span>
  
</code></pre></div></div>

<h3>Coordinates</h3>

<ul>
  <li>view port</li>
</ul>

<p>初始化view port一般是这样一句代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">backingWidth</span><span class="p">,</span> <span class="n">backingHeight</span><span class="p">);</span>
</code></pre></div></div>

<p>我理解view port的坐标系和Quartz的坐标系一致，左下角为原点。一般来说，view port的坐标系不重要，覆盖整个openGL绘制的区域即可。</p>

<p>然后，我们来决定是绘制2D还是3D。</p>

<ul>
  <li>projection</li>
</ul>

<p>无论绘制2D还是3D都需要对object进行投影,得到他们在当前layer中的位置：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glMatrixMode</span><span class="p">(</span><span class="n">GL_PROJECTION</span><span class="p">);</span>
<span class="n">glLoadIdentity</span><span class="p">();</span>
</code></pre></div></div>

<p>openGL是基于矩阵运算，是一种有状态api，某一个时刻只能操作一种矩阵，所以在操作矩阵前，需要通过glMatrixMode指定当前操作的是什么矩阵。</p>

<ul>
  <li>orth(正交)</li>
</ul>

<p>如果是绘制2D图像，投影矩阵通常为正交阵:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glOrthof</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">);</span>
</code></pre></div></div>
<p>改怎么理解这个正交阵呢？</p>

<p><img src="/assets/images/2011/11/glorthof.png" alt="Alt text" /></p>

<p>如果是2D图像，那我们眼睛的位置为Z轴正方向，正交投影就是投在x,y平面上的面积。
那数值是什么意思呢？</p>

<p>openGL的空间坐标系是屏幕中心为（0，0），上下左右各位单位向量的正方体，也就是说它的坐标范围在(-1,-1,-1)到(1,1,1)。
假如我们现在有个立方体，它的空间坐标为：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">GLfloat</span> <span class="n">squareVertices</span><span class="p">[]</span> <span class="o">=</span> 
<span class="p">{</span>
        <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">75</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">75</span><span class="n">f</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">.</span><span class="mi">75</span><span class="n">f</span><span class="p">,</span>  <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">75</span><span class="n">f</span><span class="p">,</span>
        <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">75</span><span class="n">f</span><span class="p">,</span>  <span class="mi">0</span><span class="p">.</span><span class="mi">75</span><span class="n">f</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">.</span><span class="mi">75</span><span class="n">f</span><span class="p">,</span>   <span class="mi">0</span><span class="p">.</span><span class="mi">75</span><span class="n">f</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>得到的投影为左图，然后我们修改投影立方体为:glOrthof(-2.0f, 2.0f, -2f, 2f, -1.0f, 1.0f),这个立方体仍然包含openGL单位立方体，得到的图为中间图，最我们再修改投影立方体为:glOrthof(0.0f, 1.0f, 0.0f, 1.5f, -1.0f, 1.0f);这个时候，我们的投影立方体已经不能完全包含openGL的单位立方体，x轴，y轴各少了一半，得到的图为右图：</p>

<div class="md-flex-h">
<div><img src="/assets/images/2011/11/glorth-0.png" /></div>
<div class="md-margin-left-12"><img src="/assets/images/2011/11/glorth-1.png" /></div>
<div class="md-margin-left-12"><img src="/assets/images/2011/11/glorth-3.png" /></div>
</div>

<ul>
  <li>透视视角</li>
</ul>

<p>如果绘制3D图像，通常用视椎体：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glFrustumf</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">5</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">10</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">);</span>

</code></pre></div></div>
<p>是椎体是一种人眼观察物体的透视视角,和正交投影相比有远近的感觉，假如我们把上面的立方体，沿Y轴旋转45度，分别用正交视角和透视角，观察如下：</p>

<div class="md-flex-h">
<div><img src="/assets/images/2011/11/glfrust-2.png" /></div>
<div class="md-margin-left-12"><img src="/assets/images/2011/11/glfrust-1.png" /></div>
</div>

<p>对于正交投影没有远近之分，对于透视投影有远近的感觉</p>

<h3>Drawing Geometry</h3>

<p>在确定了openGL的投影矩阵后，绘制object就很简单了，首先定义好object的顶点位置，和颜色分布，然后调用openGL的api绘制就可以了：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">glClearColor</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">);</span>
 <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>
 <span class="n">glVertexPointer</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">squareVertices</span><span class="p">);</span>
 <span class="n">glEnableClientState</span><span class="p">(</span><span class="n">GL_VERTEX_ARRAY</span><span class="p">);</span>
 <span class="n">glColorPointer</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">squareColors</span><span class="p">);</span>
 <span class="n">glEnableClientState</span><span class="p">(</span><span class="n">GL_COLOR_ARRAY</span><span class="p">);</span> 
 <span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLE_STRIP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
 <span class="n">glBindRenderbufferOES</span><span class="p">(</span><span class="n">GL_RENDERBUFFER_OES</span><span class="p">,</span> <span class="n">viewRenderbuffer</span><span class="p">);</span>
 <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">context</span> <span class="n">presentRenderbuffer</span><span class="o">:</span><span class="n">GL_RENDERBUFFER_OES</span><span class="p">];</span>
</code></pre></div></div>

<p class="md-p-center md-margin-top-24">（全文完）</p>

<h3 id="further-reading">Further Reading：</h3>

<ul>
  <li>Apple关于openGL ES的<a href="https://developer.apple.com/library/ios/samplecode/GLES2Sample/Introduction/Intro.html#//apple_ref/doc/uid/DTS40009188-Intro-DontLinkElementID_2">sample code</a></li>
</ul>
:ET