I";`<p>两个月前Apple放出了这样<a href="https://developer.apple.com/news/?id=10202014a">一条消息</a>。今天Apple<a href="https://developer.apple.com/news/">又来了</a>：</p>

<blockquote>
  <p>As we announced in October, beginning on February 1, 2015 new iOS apps submitted to the App Store must include 64-bit support and be built with the iOS 8 SDK. Beginning June 1, 2015 app updates will also need to follow the same requirements. To enable 64-bit in your project, we recommend using the default Xcode build setting of “Standard architectures” to build a single binary with both 32-bit and 64-bit code.</p>
</blockquote>

<p>意思是大概这么三条:</p>

<ul>
  <li>
    <p>从2015年2月1日起，新提交的App，必须用iOS 8 SDK打包，且必须要包含64bit的版本。</p>
  </li>
  <li>
    <p>从2015年6月1日起，更新的App也必须符合上面你的要求。</p>
  </li>
  <li>
    <p>建议开发者用Standard architecture打包，会build出32bit和64bit两个版本。</p>
  </li>
</ul>

<p>这样的要求带来的结果是:</p>

<ul>
  <li>如果你的App还支持iOS 6以下的版本，那么对于iOS 6及以下的用户，在App Store上下载的app是 32bit的，对于iOS 7以上的用户，下载的是64 bit的版本。当然，还要将设备考虑进去，比如你用的是iPhone4，装了iOS7，那么也只能下载32bit的版本，因为iPhone4不支持64bit。</li>
</ul>

<p>看来Apple这次是铁了心的要推广64bit的app，进而推动它新操作系统的更新（淘汰iOS 7以下的系统）和设备的更新换代（淘汰iPhone 5s以下的设备 ）。</p>

<p>但Apple还没有明确说禁止提交32bit的app，估计是要慢慢过渡。</p>

<p>今天仔细读了一遍<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013501-CH1-SW1">64-Bit Transition Guide for Cocoa Touch</a>。摘录下其中关键的部分:</p>

<h2 id="64bit-at-a-glance">64bit at a Glance</h2>

<h3 id="apple-a7支持两种不同的指令集">Apple A7支持两种不同的指令集:</h3>

<ul>
  <li>32bit ARM : 所有CPU都支持</li>
  <li>64bit ARM : 64bit ARM</li>
</ul>

<h3 id="使用64bit-arm-architecture的优势">使用64bit ARM architecture的优势</h3>

<ul>
  <li>
    <p>CPU寻址空间变大了</p>
  </li>
  <li>
    <p>整型,浮点型的寄存器数量增加了一倍，这意味着有更多register可以被利用，从而性能将会带来极大的提升（访问寄存器的速度要远快于访问内存）。</p>
  </li>
  <li>
    <p>LLVM针对64bit进行了优化，提升了App的性能</p>
  </li>
</ul>

<h3 id="注意的点">注意的点</h3>

<ul>
  <li>
    <p>64bit的pointer意味着消耗更多的内存。</p>
  </li>
  <li>
    <p>64bit的app只能运行在iOS 7.0.3以后的系统上，并且设备是支持64bit的（iPhone 5s以后）。</p>
  </li>
  <li>
    <p>从32bit到64bit需要对基本的数据类型做一些处理,如int,NSInteger,float,CGFloat等。</p>
  </li>
</ul>

<h2 id="major-64-bit-changes">Major 64 bit changes</h2>

<h3 id="64bit-和-32bit的运行时环境主要由两方面区别">64bit 和 32bit的运行时环境，主要由两方面区别：</h3>

<ul>
  <li>
    <p>64bit环境中，基本数据类型均要求严格的内存对齐，这会带来自身size的增加。</p>
  </li>
  <li>
    <p>64bit环境中，对函数原型(<a href="http://en.wikipedia.org/wiki/Function_prototype">function protype</a>)的声明，有这个更严格的要求。</p>
  </li>
</ul>

<p>C或Objective-C是不会去限制原生数据类型的size的，因为这与具体的平台相关，不同平台会针对硬件环境和操作系统来重新定义这些数据类型。从32bit到64bit，这些基本数据类型的大小要重新定义。</p>

<h3 id="ilp32-vs-lp64">ILP32 vs LP64</h3>

<p>32bit的runtime环境使用ILP32的数据模型，integer，long，pointer都是32bit长。64bit的runtime环境使用的是LP64的数据模型，integer是32bit长，long，pointer类型是64bit长。更多数据类型的变化如下图：</p>

<p><img src="/assets/images/2014/12/64bit-data-types.png" alt="alt text" /></p>

<p>关于浮点型的变化如下：</p>

<p><img src="/assets/images/2014/12/64bit-data-type-float.png" alt="alt text" /></p>

<ul>
  <li>
    <p>对于使用可变参数的函数和普通函数的相互cast要格外小心。</p>
  </li>
  <li>
    <p>accessing isa：</p>
  </li>
</ul>

<blockquote>
  <p>If you are writing low-level code that targets the Objective-C runtime directly, you can no longer access an object’s isa pointer directly. Instead, you need to use the runtime functions to access that information.</p>
</blockquote>

<p>直接给出在64bit平台下，访问isa指针的方法：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cp">#ifdef __arm64__
</span>        <span class="c1">// See http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html        </span>
        <span class="k">extern</span> <span class="kt">uint64_t</span> <span class="n">objc_debug_isa_class_mask</span> <span class="n">WEAK_IMPORT_ATTRIBUTE</span><span class="p">;</span>
        <span class="n">clz</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">Class</span><span class="p">)((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">isa</span> <span class="o">&amp;</span> <span class="n">objc_debug_isa_class_mask</span><span class="p">));</span>
 <span class="cp">#else
</span>        <span class="n">clz</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">isa</span><span class="p">;</span>
 <span class="cp">#endif
</span></code></pre></div></div>

<ul>
  <li>64bit的汇编指令集发生了变化，关于32bit的ARM指令集，可以参考<a href="http://akadealloc.github.io/blog/2013/06/15/assembly-on-arm.html">我之前的文章</a>。</li>
</ul>

<h2 id="converting-your-app-to-a-64-bit-binary">Converting Your App to a 64-Bit Binary</h2>

<h3 id="不要将pointer强制转换为int类型">不要将pointer强制转换为int类型。</h3>

<p>考虑下面代码:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">something</span> <span class="n">passed</span> <span class="n">in</span> <span class="n">as</span> <span class="n">an</span> <span class="n">argument</span><span class="p">....</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="n">c</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// Incorrect.</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>               <span class="c1">// Correct!</span>

</code></pre></div></div>
<p>在32bit的系统中，pointer和int大小相同，相互cast没有问题，但是在64bit的系统中，pointer的size大于int，因此这样cast会破坏pointer。如果一定要做转换，要使用<code class="highlighter-rouge">uintptr_t</code>。</p>

<h3 id="保持数据类型一致性">保持数据类型一致性</h3>

<p>例子:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">long</span> <span class="nf">PerformCalculation</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 
<span class="kt">int</span>  <span class="n">x</span> <span class="o">=</span> <span class="n">PerformCalculation</span><span class="p">();</span> <span class="c1">// incorrect</span>
<span class="kt">long</span> <span class="n">y</span> <span class="o">=</span> <span class="n">PerformCalculation</span><span class="p">();</span> <span class="c1">// correct</span>

</code></pre></div></div>
<p>函数返回值类型要保持一致。</p>

<h3 id="cocoatouch的一些基本数据类型发生了变化">CocoaTouch的一些基本数据类型发生了变化</h3>

<p>例子:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// Incorrect.</span>
<span class="n">CGFloat</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">200</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="n">CFNumberCreate</span><span class="p">(</span><span class="n">kCFAllocatorDefault</span><span class="p">,</span> <span class="n">kCFNumberFloatType</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
 
<span class="c1">// Correct!</span>
<span class="n">CGFloat</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">200</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="n">CFNumberCreate</span><span class="p">(</span><span class="n">kCFAllocatorDefault</span><span class="p">,</span> <span class="n">kCFNumberCGFloatType</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>

</code></pre></div></div>
<h3 id="有符号和无符号数据的运算要注意">有符号和无符号数据的运算要注意:</h3>

<ul>
  <li>
    <p>无符号数通过补零来转换为larger type。</p>
  </li>
  <li>
    <p>有符号数通过扩展符号位来转换为larger type（如: <code class="highlighter-rouge">int a=-2</code>，表示为<code class="highlighter-rouge">0xfffffe</code>，<code class="highlighter-rouge">long b = a; </code> 则b表示为 <code class="highlighter-rouge">0xffffff ffffe</code>）。</p>
  </li>
  <li>
    <p>常量（除非明确声明其类型，如: 0x8L）都将使用size最小的数据类型来表示。16进制表示的数字会被编译器解析为<code class="highlighter-rouge">int</code>,<code class="highlighter-rouge">long</code>,<code class="highlighter-rouge">long long</code>类型。</p>
  </li>
  <li>
    <p>当相同位数的有符号数和无符号数相加，结果为无符号数。</p>
  </li>
</ul>

<p>例子：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="n">a</span><span class="o">=-</span><span class="mi">2</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="kt">long</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="n">d</span><span class="o">=</span><span class="n">c</span><span class="p">;</span> <span class="c1">// to get a consistent size for printing.</span>
 
<span class="n">printf</span><span class="p">(</span><span class="s">"%lld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>

</code></pre></div></div>
<p>上面代码在32bit运行时环境的结果为:<code class="highlighter-rouge"> 4294967295 </code>。</p>

<ul>
  <li>原因是:</li>
</ul>

<p>a的16进制值为 <code class="highlighter-rouge">0xfffffe</code>(-2的反码为<code class="highlighter-rouge">0xfffffd</code>,补码=反码+1), b的16进制值为<code class="highlighter-rouge">0x000001</code>,求和后c为<code class="highlighter-rouge">0xffffffff</code>，由于c为long型，根据上面第1条和第4条，高32位补0，结果为:<code class="highlighter-rouge">(0x00000000ffffffff)</code>。</p>

<ul>
  <li>解决办法:</li>
</ul>

<p>一种巧妙的解决办法是将 b 声明为long型。这样b就变为 <code class="highlighter-rouge">0x0000000000000001</code>。由于a的位数小于b，因此a要补齐，根据上面第2条，a变为<code class="highlighter-rouge">0xfffffffffffffffe</code>。这样相加后，结果变为<code class="highlighter-rouge">0xffffffffffffffff</code>为<code class="highlighter-rouge">-1</code>。得到了正确的结果:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="o">=-</span><span class="mi">2</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="kt">long</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="n">d</span><span class="o">=</span><span class="n">c</span><span class="p">;</span> <span class="c1">// to get a consistent size for printing.</span>
 
<span class="n">printf</span><span class="p">(</span><span class="s">"%lld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>

</code></pre></div></div>

<h3 id="使用一些不会根据平台环境变化的数据结构">使用一些不会根据平台环境变化的数据结构：</h3>

<p><img src="/assets/images/2014/12/64bit-data-type-c99.png" alt="alt text" /></p>

<h3 id="要兼顾字节对齐">要兼顾字节对齐：</h3>

<p>定义struct要注意字节对齐:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">bar</span> <span class="p">{</span>
    <span class="kt">int32_t</span> <span class="n">foo0</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">foo1</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">foo2</span><span class="p">;</span>
    <span class="kt">int64_t</span> <span class="n">bar</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>在32bit的环境中，<code class="highlighter-rouge">bar</code>的padding offset是12字节。到了64bit中，<code class="highlighter-rouge">bar</code>的padding offset变成了16字节。因为在64bit的环境中，最小alignment的字节数变为8字节，那么在<code class="highlighter-rouge">foo2</code>后面会额外补充4字节的0。</p>

<p>如果你要定义一个新的结构体，将size最大的数据类型定义在最前面，size最小的数据类型定义在最后面。这种定义方式会尽量减少padding的字节数。如果你要使用原先32bit环境下的struct，可以用<code class="highlighter-rouge">#pragma pack(4)</code>来强行指定字节对齐方式按照32bit来对齐，这种方式当然会损耗一些性能。</p>

<p>如下:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cp">#pragma pack(4)
</span><span class="k">struct</span> <span class="n">bar</span> <span class="p">{</span>
    <span class="kt">int32_t</span> <span class="n">foo0</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">foo1</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">foo2</span><span class="p">;</span>
    <span class="kt">int64_t</span> <span class="n">bar</span><span class="p">;</span>
<span class="p">};</span>
 <span class="cp">#pragma options align=reset
</span></code></pre></div></div>

<h3 id="函数与函数指针">函数与函数指针</h3>

<p>在64bit的环境中，编译器生成的用来处理可变参数的函数的指令顺序和32bit环境有着较大的区别,因此这两者不可以强制相互cast：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="nf">MyFunction</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="p">...);</span>
 
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">action</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span> <span class="n">MyFunction</span><span class="p">;</span>
<span class="n">action</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// Error!</span>

</code></pre></div></div>
<p>在64bit的环境中，尽量使用函数原型，这种通过函数指针调用函数的方式有风险，因为可能会碰到可变参数的函数。</p>

<h3 id="message-dispatch">Message Dispatch</h3>

<p><code class="highlighter-rouge">objc_msgSend</code>的函数原型为:<code class="highlighter-rouge">id objc_msgSend(id self, SEL op, ...)</code>，显然它是一个可变参数的函数。在32bit的环境中，我们可以通过这个方法在运行时调用某个类的某个method，而不用考虑可变参数的问题:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="n">ret1</span> <span class="o">=</span> <span class="n">objc_msgSend</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="err">@</span><span class="n">selector</span><span class="p">(</span><span class="n">method1</span><span class="o">:</span><span class="p">),</span><span class="err">@</span><span class="s">"hello"</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">ret2</span> <span class="o">=</span> <span class="n">objc_msgSend</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="err">@</span><span class="n">selector</span><span class="p">(</span><span class="n">method1</span><span class="o">:</span><span class="p">),</span><span class="err">@</span><span class="s">"hello"</span><span class="p">,</span><span class="n">nil</span><span class="p">);</span>

</code></pre></div></div>
<p>但是在64bit环境中，如果使用<code class="highlighter-rouge">objc_msgSend</code>来调用某个method，需要明确的提供这个method的函数原型:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="o">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">doSomething</span><span class="o">:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">x</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="o">-</span> 
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">doSomethingElse</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">action</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span> <span class="n">SEL</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span> <span class="n">SEL</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span> <span class="n">objc_msgSend</span><span class="p">;</span>
    <span class="n">action</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="err">@</span><span class="n">selector</span><span class="p">(</span><span class="n">doSomething</span><span class="o">:</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="其它">其它</h3>

<ul>
  <li>
    <p>不要自定义原生数据类型，因为它涉及到32bit和64bit两套环境，以及他们之间的相互转换。</p>
  </li>
  <li>
    <p>不要直接访问<code class="highlighter-rouge">isa</code>指针，因为它指向的数据结构发生了变化。使用<code class="highlighter-rouge">object_getclass</code>或<code class="highlighter-rouge">object_setclass</code>。</p>
  </li>
  <li>
    <p>不要Hard Code虚拟内存的page size。关于iOS下的虚拟内存，参考之前的<a href="http://akadealloc.github.io/blog/2012/07/10/Debuging-Memory-Issues-1.html">这篇文章</a>。</p>
  </li>
  <li>
    <p>关于使用内存的优化，这部分不详细列出。</p>
  </li>
</ul>

<hr />

<h2 id="附录--iphone-hardwareos-model">附录 | iPhone Hardware/OS Model</h2>

<table>
  <thead>
    <tr>
      <th>Hardware</th>
      <th>iPhone 3gs</th>
      <th>iPhone 4</th>
      <th>iPhone 4s</th>
      <th>iPhone 5</th>
      <th>iPhone 5s</th>
      <th>iPhone 6</th>
      <th>iPhone 6+</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CPU Model</td>
      <td>ARM Cortex-A8</td>
      <td>ARM Cortex-A8（Apple A4）</td>
      <td>dual-core ARM Cortex-A9(Apple A5)</td>
      <td>dual-core ARMv7s (Apple A6)</td>
      <td>dual-core ARMv8-A (Apple A7)</td>
      <td>dual-core ARMv8-A-64bit(Apple A8)</td>
      <td>dual-core ARMv8-A-64bit(Apple A8</td>
    </tr>
    <tr>
      <td>CPU Frequence</td>
      <td>600 MHZ</td>
      <td>1G HZ</td>
      <td>1G HZ</td>
      <td>1.3G HZ</td>
      <td>1.3G HZ</td>
      <td>1.4G HZ</td>
      <td>1.4G HZ</td>
    </tr>
    <tr>
      <td>Bus Width</td>
      <td>32 bit</td>
      <td>32 bit</td>
      <td>32 bit</td>
      <td>32 bit</td>
      <td>64 bit</td>
      <td>64 bit</td>
      <td>64 bit</td>
    </tr>
    <tr>
      <td>GPU</td>
      <td>PowerVR SGX535 GPU</td>
      <td>PowerVR SGX535 GPU</td>
      <td>dual-core PowerVR SGX535 GPU</td>
      <td>triple-core PowerVR SGX543MP3</td>
      <td>quad-core PowerVR G6430</td>
      <td>quad-core PowerVR GX6450</td>
      <td>quad-core PowerVR GX6450</td>
    </tr>
    <tr>
      <td>GPU Frequence</td>
      <td>160 MHZ</td>
      <td>200 MHZ</td>
      <td>200 MHZ</td>
      <td>266MHZ</td>
      <td>450MHZ</td>
      <td>450MHZ</td>
      <td> </td>
    </tr>
    <tr>
      <td>RAM</td>
      <td>256 MB</td>
      <td>512 MB</td>
      <td>512 MB</td>
      <td>1G</td>
      <td>1G</td>
      <td>1G</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="further-reading">Further Reading</h2>

<ul>
  <li><a href="http://en.wikipedia.org/wiki/List_of_iOS_devices">iPhone Hardware Models</a></li>
  <li><a href="http://en.wikipedia.org/wiki/ARM_Cortex-A8">ARM Cortext-A8</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Apple_A4">Apple A4</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Apple_A5">Apple A5</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Apple_A6">Apple A6</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Apple_A7">Apple A7</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Apple_A8">Apple A8</a></li>
  <li><a href="https://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html">Mike Ash:ARM64</a></li>
  <li><a href="https://developer.apple.com/library/ios/documentation/Xcode/Conceptual/iPhoneOSABIReference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009023">iOS ABI</a></li>
</ul>

:ET