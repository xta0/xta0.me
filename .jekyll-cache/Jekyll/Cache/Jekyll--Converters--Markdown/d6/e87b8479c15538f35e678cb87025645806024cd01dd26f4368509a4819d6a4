I"W<p>如果一个问题各状态之间的转移关系(解空间)可以用一个图来描述, 则可以使用深度搜索的方法对该问题进行求解。所谓深度搜索，就是以深度优先的原则，对所有的可能情况进行暴利枚举，直至找到最终解。所谓回溯(backtracking)是指当某次搜索发现不满足条件时，退回到前一步选择一个新的分之后重新出发，因此回溯往往伴随着状态的重置。</p>

<p>一个典型的深搜场景就是走迷宫，在每个分叉路口都有若干个方向供选择，我们可以沿着某一方向不断试探（深搜），当发现此路不通时，再沿原路退回到最近一个分叉路口（回溯）换另一个方向继续尝试，实际上就是去穷尽解空间中的所有分支，直到找到问题的解。</p>

<p><mark>总的来说，对于深搜，非常重要的一点是，对要求解的问题建立<strong>正确的</strong>解空间树，或者决策树。解空间的结构决定了深搜策略。</mark></p>

<p>深搜+回溯的伪码为：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span><span class="nx">index</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">some_condition</span><span class="p">){</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="nx">index</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">array</span><span class="p">.</span><span class="nx">size</span><span class="p">();</span><span class="o">++</span><span class="nx">i</span><span class="p">){</span>
        <span class="nx">obj</span> <span class="o">=</span> <span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="nx">choose</span><span class="p">();</span>
        <span class="nx">dfs</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span><span class="nx">i</span><span class="p">,</span> <span class="p">...);</span>
        <span class="c1">//backtracking</span>
        <span class="nx">unchoose</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="排列组合问题">排列组合问题</h2>

<h3 id="排列问题permutation">排列问题（Permutation)</h3>

<p>Permutation问题是求解一个集合的全排列问题，例如<code class="highlighter-rouge">[1,2,3]</code>的全排列为<code class="highlighter-rouge">[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]</code>。这个问题的解法有很多，比较常见的是使用DFS进行暴力搜索，搜索所有可能的结果。</p>

<p>前面曾提到，使用DFS进行搜索的一个先决条件是要构建正确的解空间或者决策树，我们以<code class="highlighter-rouge">[1,2,3]</code>为例，其解空间如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     1               2              3
    / \             / \            / \
   2   3           1   3          2   1
  /     \         /     \        /     \
 3       2       3       1      1       2
</code></pre></div></div>

<p>由这个解空间不难看出，我们可以将<code class="highlighter-rouge">1,2,3</code>分别作为根节点来构造一棵树，然后使用DFS对每个节点进行深度搜索，当搜索到叶子结点时便得到一个解，然后进行回溯。以第一棵树为例，我们从<code class="highlighter-rouge">1</code>开始沿着左路搜索到<code class="highlighter-rouge">1,2,3</code>，然后进行回溯，回溯到<code class="highlighter-rouge">2</code>之后，发现没有其它的孩子节点，因此继续回溯到<code class="highlighter-rouge">1</code>，然后继续沿着<code class="highlighter-rouge">1</code>的右边继续下降，得到<code class="highlighter-rouge">1,3,2</code>。依次类推深度遍历其它树，最终得到全部解。</p>

<p>套用前面给出的深搜+回溯的代码模板，我们首先需要构造一个<code class="highlighter-rouge">for</code>循环来遍历各自的孩子节点，其次，我们需要在每次递归前进行choose操作，然后在递归完成后进行unchoose操作，整个过程如下：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//全排列-深搜</span>
<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">chosen</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">results</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">results</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">chosen</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="c1">//set state</span>
        <span class="n">chosen</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">nums</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
        <span class="c1">//dfs</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span><span class="n">chosen</span><span class="p">,</span><span class="n">results</span><span class="p">);</span>
        <span class="c1">//backtracking, unset_state</span>
        <span class="n">chosen</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="n">nums</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">permute</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ret</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span><span class="n">vec</span><span class="p">,</span><span class="n">ret</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>接下来我们来分析下上面算法的时间复杂度，从<code class="highlighter-rouge">dfs</code>函数来看，不难看出，递归函数之间存在下面的关系：</p>

<script type="math/tex; mode=display">T(n) = n*T(n-1) = O(n!)</script>

<p>使用主定理推导或者参考前面算法分析的文章可知，该算法的时间复杂度为<code class="highlighter-rouge">O(n!)</code>，非常高。</p>

<h3 id="组合问题combination">组合问题（Combination）</h3>

<p>组合问题的解法和排列类似，不同之处在于组合不关心元素之间的顺序，比如<code class="highlighter-rouge">[1,2]</code>和<code class="highlighter-rouge">[2,1]</code>算作同一种组合，因此解空间中的分支没有排列那么多，我们还看上面<code class="highlighter-rouge">[1,2,3]</code>的例子：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     1             2            3
    / \             \           
   2   3             3
  /              
 3              
</code></pre></div></div>
<p>对于<code class="highlighter-rouge">[1,2,3]</code>的组合有下面几种情况<code class="highlighter-rouge">[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]</code>，从代码层面看，我们只需要将上述排列代码做如下修改</p>

<ol>
  <li>在进行<code class="highlighter-rouge">for</code>循环遍历时，需要改变每次起始搜索的<code class="highlighter-rouge">index</code>的值，<code class="highlighter-rouge">index</code>值是递增的，例如当我们走完<code class="highlighter-rouge">[1,2,3]</code>后，我们需要回溯到<code class="highlighter-rouge">1</code>，然后接着走到<code class="highlighter-rouge">3</code>，此时对于<code class="highlighter-rouge">3</code>来说，它不能再回头遍历<code class="highlighter-rouge">2</code>，因为<code class="highlighter-rouge">[1,2,3]</code>和<code class="highlighter-rouge">[1,3,2]</code>是相同的组合</li>
  <li>由于<code class="highlighter-rouge">index</code>的递增性使我们在遍历数组的时候无需修改数组，例如第一次搜索我们choose了<code class="highlighter-rouge">1</code>，第二次搜索由于index递增，可以直接上我们选择到<code class="highlighter-rouge">2</code>,无需将<code class="highlighter-rouge">1</code>移除array</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">arr</span><span class="p">,</span><span class="n">index</span><span class="p">,</span><span class="n">choose</span><span class="p">,</span><span class="n">result</span><span class="p">):</span>
    <span class="c1">#不需要递归基
</span>    <span class="c1">#收集结果
</span>    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">choose</span><span class="p">))</span>
    <span class="c1">#for循环从index位置开始
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
        <span class="c1">#choose
</span>        <span class="n">x</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">choose</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1">#dfs
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">choose</span><span class="p">,</span><span class="n">result</span><span class="p">)</span> 
        <span class="c1">#unchoose
</span>        <span class="n">choose</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">combination</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">arr</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="n">choose</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">choose</span><span class="p">,</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p>上面代码可以搜索出<code class="highlighter-rouge">arr</code>的所有组合，在<code class="highlighter-rouge">dfs</code>函数中无需增加递归基，因为由于<code class="highlighter-rouge">index</code>递增，当<code class="highlighter-rouge">for</code>循环执行完后，函数自动返回。组合问题的时间复杂度计算公式如下</p>

<script type="math/tex; mode=display">T(n) = T(n-1) + T(n-2) + ... + T(1) = O(2^n)</script>

<p>使用主定理求解上面公式，其时间复杂度虽然比排列问题要低，但仍然是指数级别的。</p>

<p>关于组合的题目往往有很多变种，比如求解一个数组的所有subsets，本质上还是组合问题，或者求解一个数组中<code class="highlighter-rouge">k</code>个数的组合，此时只需要为<code class="highlighter-rouge">dfs</code>函数增加一个递归基，用来追踪递归深度即可:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">curr</span><span class="p">,</span><span class="n">depth</span><span class="p">,</span><span class="n">arr</span><span class="p">,</span><span class="n">index</span><span class="p">,</span><span class="n">choose</span><span class="p">,</span><span class="n">result</span><span class="p">):</span>
    <span class="c1">#追踪递归深度
</span>    <span class="k">if</span> <span class="n">depth</span> <span class="o">==</span> <span class="n">curr</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">choose</span><span class="p">))</span>
        <span class="k">return</span> 
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
        <span class="c1">#choose
</span>        <span class="n">x</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">choose</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">curr</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1">#dfs
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="n">depth</span><span class="p">,</span><span class="n">arr</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">choose</span><span class="p">,</span><span class="n">result</span><span class="p">)</span>
        <span class="c1">#unchoose
</span>        <span class="n">curr</span><span class="o">-=</span><span class="mi">1</span>
        <span class="n">choose</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="关于排列组合的更多问题">关于排列组合的更多问题</h3>

<ul>
  <li><a href="https://leetcode.com/problems/permutations/description/">46. Permutations</a></li>
  <li><a href="https://leetcode.com/problems/permutations-ii/description/">47. Permutations II</a></li>
  <li><a href="https://leetcode.com/problems/subsets/description/">78. Subsets</a></li>
  <li><a href="https://leetcode.com/problems/combinations/description/">77. Combinations</a></li>
  <li><a href="https://leetcode.com/problems/combination-sum-ii/description/">40. Combination Sum II</a></li>
  <li><a href="https://leetcode.com/problems/combination-sum-iii/description/">216. Combination Sum III</a></li>
</ul>

<h2 id="括号问题">括号问题</h2>

<p>括号问题是另一类比较经典的搜索问题，它包含下面几种类型的题目：</p>

<ol>
  <li>判断括号是否匹配</li>
  <li>生成所有可能的括号组合</li>
  <li>添加或删除括号使所有括号匹配</li>
</ol>

<p>上面三个问题中，掌握第一个问题是解决后面问题的先决条件，它并不需要使用到搜索，简单遍历一遍输入数据即可</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">valid</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">oc</span><span class="p">;</span> <span class="c1">//未闭合的左括号 数量</span>
    <span class="kt">int</span> <span class="n">cc</span><span class="p">;</span> <span class="c1">//未闭合的右括号 数量</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'{'</span><span class="p">){</span>
            <span class="n">oc</span> <span class="o">++</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="c1">//遇到右括号，先看是否有未闭合的左括号</span>
            <span class="k">if</span><span class="p">(</span><span class="n">oc</span><span class="p">){</span>
                <span class="n">oc</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                <span class="c1">//如果左括号都闭合，那么右括号为非闭合</span>
                <span class="n">cc</span> <span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">cc</span><span class="o">+</span><span class="n">oc</span><span class="p">;</span> <span class="c1">//返回未闭合的左右括号数量</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>有了上面函数做基础，我们便可以分析第二个和第三个问题</p>

<h3 id="生成所有括号组合">生成所有括号组合</h3>

<h3 id="添加删除括号">添加删除括号</h3>

<h3 id="更多括号问题">更多括号问题</h3>

<ul>
  <li><a href="https://leetcode.com/problems/generate-parentheses/description/">22. Generate Parentheses</a></li>
</ul>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://www.youtube.com/watch?v=NcZ2cu7gc-A&amp;list=PLnfg8b9vdpLn9exZweTJx44CII1bYczuk">CS106B-Stanford-YouTube</a></li>
  <li><a href="https://www.coursera.org/learn/algorithms-divide-conquer/home/welcome">Algorithms-Stanford-Cousera</a></li>
  <li><a href="https://www.coursera.org/learn/shuju-jiegou-suanfa/home/welcome">算法与数据结构-1-北大-Cousera</a></li>
  <li><a href="https://www.coursera.org/learn/gaoji-shuju-jiegou/home/welcome">算法与数据结构-2-北大-Cousera</a></li>
  <li><a href="https://courses.edx.org/courses/course-v1:TsinghuaX+30240184.1x+3T2017/course/">算法与数据结构-1-清华-EDX</a></li>
  <li><a href="https://courses.edx.org/courses/course-v1:PekingX+04833050X+1T2016/course/">算法与数据结构-2-清华-EDX</a></li>
  <li><a href="https://www.coursera.org/learn/algorithms/home/welcome">算法设计与分析-1-北大-Cousera</a></li>
  <li><a href="https://courses.edx.org/courses/course-v1:PekingX+04833050X+1T2016/course/">算法设计与分析-2-北大-EDX</a></li>
</ul>

:ET