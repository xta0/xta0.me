I"<h3 id="术语">术语</h3>

<ul>
  <li>图的定义</li>
</ul>

<p>数学意义的图包含两个元素 $G=(V,E)$，顶点集合 $n = | V |$，边集合 $ e= | E | $。 假设一个图有三个顶点，彼此连通，则$V=\{v_0,v_1,v_2\}$，$E=\{(v_1,v_2),(v_1,v_3),(v_2,v_3)\}$。</p>

<p><img src="/assets/images/2008/08/graph-0.png" style="margin-left:auto; margin-right:auto;display:block" /></p>

<ul>
  <li>邻接关系/关联关系</li>
</ul>

<p>可以被边相连的两个点成为<strong>邻接关系</strong>(adjacency)，邻接关系是顶点与顶点之间的关系，顶点与某条边之间的关系称为<strong>关联关系</strong>(incidence)</p>

<ul>
  <li>路径</li>
</ul>

<p><strong>路径</strong>为一系列的顶点按照依次邻接的关系组成的序列，*$\pi = &lt;v_0,v_1…,v_k&gt;$，长度$|\pi|=k$。如上图中$V$到$Z$的一条路径为${b,h}$或${V,X,Z}$。路径的<strong>长度</strong>为顶点的个数或者边的个数。如果再一条通路中不含重复节点，我们称之为 <strong>简单路径</strong> ($v_i = v_j$除非$i=j$)。</p>

<ul>
  <li>连通图</li>
</ul>

<p>若图中任意两点都是连通的，那么该图称为<strong>连通图</strong>。对于有向图 $G (V,E)$，如果两个顶点 $v_i,v_j$ 间有一条从$v_i$ 到 $v_j$ 的有向路径，责成同时还有一条从 $v_j$ 到 $v_i$ 的有向路径，则称两个顶点<strong>强连通</strong>,称$G为<strong>强连通图</strong>。强连通图只有一个连通分量，即其自身。</p>

<ul>
  <li>环路</li>
</ul>

<p>当路径的起点和终点重合时，称之为<strong>环路</strong>($v_0=v_k$)。如果再有向图中不包含任何环路，则称之为<strong>有向无环图</strong>(DAG,Directed Acyclic Graph)，树和森林是DAG图的一种特例。 对于只有两个顶点的图，如果是无向图，则不认为是环路；如果是有向图，且两个顶点之间有两条边，则认为是环路，例如$&lt;v_0,v_1&gt;$和$&lt;v_1,v_0&gt;$构成环</p>

<ul>
  <li>无向图/有向图</li>
</ul>

<p>若邻接顶点$u$和$v$的次序无所谓，则$(u,v)$为无向边(undirected edge)，若图中的所有边均为无向边，则这个图称为<strong>无向图</strong>。反之，<strong>有向图</strong>(digraph)中均为有向边(directed edge)，$u,v$分别称作边$(u,v)$的尾，头，表示从$u$出发，到达$v$。</p>

<p><img src="/assets/images/2008/08/graph-5.png" style="margin-left:auto; margin-right:auto;display:block" /></p>

<p>之前介绍的数据结构都可以看成是图的一种表现形式，比如二叉树是一种无权的有向无环图，节点的入度为1，出度最大为2，顶点之间只有一条路径。而单项链表也可以看成是一种无权的DAG，每个节点的入度出度都为1</p>

<h2 id="图的表示">图的表示</h2>

<p>上面我们已经了解了关于图的逻辑模型和基本接口，但是在计算机中该如何表示这个模型呢？方法有很多种，这里我们主要介绍三种，分别是边表(edge list)，邻接矩阵(adjacency matrix)和邻接表(adjacency list)。</p>

<p><img src="/assets/images/2008/08/graph-14.jpg" style="margin-left:auto; margin-right:auto;display:block" /></p>

<h3 id="边表">边表</h3>

<p>边表，顾名思义是使用一个无序链表来表示图，其中链表中的每个节点为一组边的集合。如上图中，我们可以使用如下链表来表示图:</p>

<table>
  <tbody>
    <tr>
      <td>(1,2)</td>
      <td>(1,4)</td>
      <td>(1,7)</td>
      <td>(2,3)</td>
      <td>(2,5)</td>
      <td>(3,6)</td>
      <td>(4,7)</td>
      <td>(5,6)</td>
      <td>(5,7)</td>
      <td>(6,7)</td>
    </tr>
  </tbody>
</table>

<p>对于每个节点的有序对，使用起点和终点来表示方向，值为顶点的内容。因此这种表示方法不会显示的存放顶点，所有顶点信息均包含在边表中。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">edge_list</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span><span class="o">...</span><span class="p">,[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]]</span>
</code></pre></div></div>

<p>显然这种方式对顶点操作不是很友好，如果想要找出<code class="highlighter-rouge">4</code>的邻居节点，则要遍历每个节点，不是很高效。</p>

<h3 id="邻接矩阵关联矩阵">邻接矩阵/关联矩阵</h3>

<p>所谓邻接矩阵就是描述顶点之间链接关系的矩阵。设$G=&lt;V,E&gt;$是一个有$n$个顶点图，则邻接矩阵是一个$n \times n$的方阵，用二维数组<code class="highlighter-rouge">A[n,n]</code>表示，它的定义如下:</p>

<script type="math/tex; mode=display">% <![CDATA[
A[i,j]=
\begin{cases}\
1, \qquad  若(v_i, v_j)∈ E 或<v_i, v_j> ∉ E \\
0, \qquad  若(v_i, v_j)∈ E 或<v_i, v_j> ∉ E \\
\end{cases} %]]></script>

<p>如果顶点$i,j$相连，对于无向图，则$A[i,j]$和$A[j,i]$的值相同；对于有向图，则分别对应各自的$A[i,j]$和$A[j,i]$的值；如果是带权图，则矩阵中元素的值为权值$w$。</p>

<p><img src="/assets/images/2008/08/graph-2.png" style="margin-left:auto; margin-right:auto;display:block" /></p>

<p>可见，对于一个$n$个顶点的图，邻接矩阵是一个对称阵（默认不考虑自环的情况，因此对角线的元素值为0)，空间代价为$O(n^2)$。</p>

<p>基于邻接矩阵的图结构，可以用二维数组来表达：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Graph</span><span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">*</span> <span class="o">&gt;</span> <span class="n">V</span><span class="p">;</span> <span class="c1">//顶点</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&lt;</span><span class="n">Te</span><span class="o">&gt;*&gt;&gt;</span> <span class="n">matrix</span><span class="p">;</span> <span class="c1">//边集合，邻接矩阵</span>
    <span class="c1">//map&lt;Vertex* , vector&lt;Edge* &gt;&gt; matrix; //也可以使用map</span>
    <span class="c1">//map&lt;Vertex* , set&lt;Edge* &gt;&gt; matrix; //也可以使用map</span>
<span class="p">};</span>
</code></pre></div></div>
<p>使用邻接矩阵的优点是：</p>

<ol>
  <li>直观，易于理解和实现</li>
  <li>适用范围广，包括有向图，无向图，带权图，自环图等等，尤其适用于稠密图</li>
  <li>判断两点之间是否存在联边: $O(1)$</li>
  <li>获取顶点的出度入度: $O(1)$
    <ul>
      <li>添加删除边后更新度: $O(1)$</li>
    </ul>
  </li>
  <li>扩展性强</li>
</ol>

<p>缺点为：</p>
<ol>
  <li>空间复杂度为$\Theta(n^2)$，与边数无关</li>
</ol>

<p>以左边无向图的邻接矩阵为例，Python表示如下：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">adjacency_matrix</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1">#v0,v1, v2,  v3
</span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span> <span class="c1">#v0
</span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span> <span class="c1">#v1
</span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span> <span class="c1">#v2
</span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">]</span>  <span class="c1">#v3
</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="邻接表">邻接表</h3>

<p>对于任何一个矩阵，我们以定义它的稀疏因子：在$m \times n$的矩阵中，有$t$个非零单元，则稀疏因子$\delta$为</p>

<script type="math/tex; mode=display">\delta = \frac{t}{m \times n}</script>

<p>若$\delta &lt; 0.05$，可认为是稀疏矩阵。对于稀疏图，边较少，邻接矩阵会出现大量的零元素，耗费大量的存储空间和时间，因此可以采用邻接表存储法。</p>

<p>邻接表(adjacency list)采用的是<strong>链式存储结构</strong>，它为顶点和边各自定义了一个结构，对于顶点包含两部分：</p>

<ol>
  <li>存放该节点$v_i$的数据域</li>
  <li>指向第一条边对象的指针</li>
</ol>

<p>对于边结构包含三部分:</p>

<ol>
  <li>与顶点$v_i$临街的另一顶点的序号</li>
  <li>顶点$v_i$下一条边的指针</li>
  <li>权重值(可选)</li>
</ol>

<p><img src="/assets/images/2008/08/graph-3.png" style="margin-left:auto; margin-right:auto;display:block" /></p>

<p>上图分别为无向图，带权图和有向图的邻接表，对于有向图，有出度和入度两种邻接表，这里只给出了出度的邻接表，对于入度的情况类似。由上图的结构可以看出使用邻接表，对每个节点的相邻节点的访问是非常高效的，另外，邻接表的空间利用率也相对较高。以左边无向图的邻接表为例，Python表示如下：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#使用list
</span><span class="n">adjacency_list</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="c1">#v0
</span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="c1">#v1
</span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="c1">#v2
</span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#v3
</span><span class="p">]</span>
<span class="c1">#也可以使用kev,value对表示
</span><span class="n">adjacency_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
    <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
    <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
    <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>
<p>基于邻接表的无向图的C++代码表示如下:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Graph</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="c1">//顶点个数</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">adj</span><span class="p">;</span> <span class="c1">//邻接表</span>
<span class="nl">public:</span>
    <span class="n">Graph</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
        <span class="k">this</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">addEdge</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">){</span>
        <span class="c1">//无向图一条边存两次</span>
        <span class="n">adj</span><span class="p">[</span><span class="n">s</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
        <span class="n">adj</span><span class="p">[</span><span class="n">t</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="几种图的不同实现方式的性能比较">几种图的不同实现方式的性能比较</h3>

<table>
  <tbody>
    <tr>
      <td> </td>
      <td>边表</td>
      <td>邻接表</td>
      <td>邻接矩阵</td>
    </tr>
    <tr>
      <td>内存消耗</td>
      <td>$V+E$</td>
      <td>$V+E$</td>
      <td>$V^2$</td>
    </tr>
    <tr>
      <td>判断相邻节点</td>
      <td>$E$</td>
      <td>$degree(v)$</td>
      <td>V</td>
    </tr>
    <tr>
      <td>添加顶点</td>
      <td>$1$</td>
      <td>$1$</td>
      <td>$V^2$</td>
    </tr>
    <tr>
      <td>删除顶点</td>
      <td>$E$</td>
      <td>$1$</td>
      <td>$V^2$</td>
    </tr>
    <tr>
      <td>添加边</td>
      <td>$1$</td>
      <td>$1$</td>
      <td>$1$</td>
    </tr>
    <tr>
      <td>删除边</td>
      <td>$E$</td>
      <td>$degree(v)$</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<h2 id="图的搜索与遍历">图的搜索与遍历</h2>

<p>在图中搜索两点间的路径有很多种方式，常用的有DFS，BFS，Dijkstra，A*等，对于图的遍历，和树类似我们也可以使用DFS和BFS两种方式，但是图有两个树没有的问题：</p>

<ol>
  <li>连通的问题，从一个点出发不一定能够到达所有点，比如非连通图</li>
  <li>可能存在回路，因此遍历可能进入死循环</li>
</ol>

<p>解决这两个问题，需要给顶点加一个状态位，标识该节点是否已经被访问过。另外，对图的遍历，可将其按照一定规则转化为对树的遍历</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">graph_traverse</span><span class="p">(){</span>
    <span class="c1">// 对图所有顶点的标志位进行初始化</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">VerticesNum</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">status</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> <span class="n">UNVISITED</span><span class="p">;</span>
        <span class="c1">// do_traverse函数用深度优先或者广度优先</span>
        <span class="n">do_traverse</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
<span class="err">}</span>
</code></pre></div></div>

<h3 id="dfs">DFS</h3>

<p>图的DFS遍历过程和之前介绍的树的DFS遍历过程类似，都是从一个节点开始，不断的递归+回溯，最终走完全部路径。其基本步骤为</p>

<ol>
  <li>选取一个未访问的点$v_0$作为源点,访问顶点$v_0$</li>
  <li>若$v_0$有未被访问的邻居，任选其中一个顶点$u_0$，进行递归地深搜遍历；否则，返回</li>
  <li>顶点$u_0$，重复上述过程</li>
  <li>不断递归+回溯，直至所有节点都被访问</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//dfs遍历伪码</span>
<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">Vertex</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 深度优先搜索的递归实现</span>
    <span class="n">status</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="n">VISITED</span><span class="p">;</span>  <span class="c1">// 把标记位设置为 VISITED</span>
    <span class="n">Visit</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// 访问顶点v</span>
    <span class="c1">//访问所有UNVISITED状态的节点</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">u</span> <span class="o">:</span> <span class="n">getNbrs</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="n">UNVISITED</span><span class="p">){</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> 
<span class="err">}</span>
</code></pre></div></div>

<p><img src="/assets/images/2008/08/graph-4.png" style="margin-left:auto; margin-right:auto;display:block" /></p>

<p>例如上图DFS的遍历次序为：<code class="highlighter-rouge">a b c f d e g</code>。这里有一点要注意，由于第二步对相邻节的未访问的节点选取规则不唯一（下图例子使用的是字母顺序），因此对全图进行遍历得到结果序列是不唯一的。类似的，如果使用DFS进行搜索，寻找两点间路径，得到的结果不一定是最短路径。dfs的搜索代码如下</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">){</span>
    <span class="kt">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="c1">//记录访问过的顶点</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>
    <span class="c1">//记录前驱节点，创建n个桶</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">prev</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">//调用一个辅助函数</span>
    <span class="n">helper</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">visited</span><span class="p">,</span><span class="n">prev</span><span class="p">,</span><span class="n">found</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">found</span><span class="p">){</span>
        <span class="n">print_path</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span><span class="n">st</span><span class="p">,);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">helper</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">visisted</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">prev</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&amp;</span> <span class="n">found</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">found</span> <span class="o">==</span> <span class="nb">true</span><span class="p">){</span>
        <span class="k">return</span> <span class="p">;</span>
    <span class="p">}</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">t</span><span class="p">){</span>
        <span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">adj</span><span class="p">[</span><span class="n">s</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">adj</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">]){</span>
            <span class="c1">//记录前驱节点</span>
            <span class="n">prev</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
            <span class="n">helper</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">visited</span><span class="p">,</span><span class="n">prev</span><span class="p">,</span><span class="n">found</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//打印路径</span>
<span class="kt">void</span> <span class="nf">print_path</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">prev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">prev</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">s</span><span class="p">){</span>
        <span class="n">print_path</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">prev</span><span class="p">[</span><span class="n">t</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="o">&lt;&lt;</span><span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="bfs">BFS</h3>

<p>图的广度优先遍历过程类似从某个点出发，一圈一圈的向外层顶点扩散的过程</p>

<ol>
  <li>从图中的某个顶点$v_0$出发，访问并标记该节点</li>
  <li>依次访问$v_0$所有尚未访问的邻接顶点</li>
  <li>依次访问这些邻接顶点的邻接顶点，如此反复</li>
  <li>直到所有点都被访问过</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//bfs遍历伪码</span>
<span class="kt">void</span> <span class="nf">BFS</span><span class="p">(</span><span class="n">Vertex</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">status</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="n">VISITED</span><span class="p">;</span> 
    <span class="n">queue</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&gt;</span> <span class="n">Q</span><span class="p">;</span> <span class="c1">// 使用STL中的队列</span>
    <span class="n">Q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// 标记,并入队列</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">Q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// 如果队列非空</span>
        <span class="n">Vertex</span> <span class="n">v</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="n">front</span> <span class="p">();</span> <span class="c1">// 获得队列顶部元素</span>
        <span class="n">Q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> <span class="c1">// 队列顶部元素出队</span>
        <span class="n">Visit</span><span class="p">(</span><span class="n">u</span><span class="p">);</span><span class="c1">//访问节点</span>
        <span class="c1">//遍历v的每一个未被访问的相邻节点</span>
        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">u</span> <span class="o">:</span> <span class="n">getNbrs</span><span class="p">(</span><span class="n">v</span><span class="p">)){</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="n">UNVISITED</span><span class="p">){</span>
                <span class="n">status</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">=</span> <span class="n">VISITED</span><span class="p">;</span> 
                <span class="n">u</span><span class="p">.</span><span class="n">previous</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span><span class="c1">//设置前驱节点</span>
                <span class="n">Q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/2008/08/graph-6.png" style="margin-left:auto; margin-right:auto;display:block" /></p>

<p>以上图为例，假设我们从<code class="highlighter-rouge">s</code>开始遍历：</p>

<ol>
  <li>随机选取一个<code class="highlighter-rouge">s</code>节点，入队</li>
  <li><code class="highlighter-rouge">s</code>出队并做标记,将<code class="highlighter-rouge">s</code>的相邻节点<code class="highlighter-rouge">a,c,d</code>，入队</li>
  <li><code class="highlighter-rouge">a</code>出队并做标记,将<code class="highlighter-rouge">a</code>相邻节点入队，由于<code class="highlighter-rouge">s,c</code>已经是被标记，于是只有<code class="highlighter-rouge">e</code>入队</li>
  <li>同理，<code class="highlighter-rouge">c</code>出队，<code class="highlighter-rouge">b</code>入队，以此类推</li>
  <li>直至节点全部被访问</li>
</ol>

<p>对于无权图来说，BFS相比DFS可以用来寻找两点间（例如上图中的a和b）的最短路径（最少边），但却不容易保存到达b点的路径，解决这个问题，可以给每个节点加一个指向前驱节点的指针，或者使用一个数组存储中间节点，代码如下：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//起点s，终点t，顶点个数n</span>
<span class="kt">void</span> <span class="nf">bfs_search</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">t</span><span class="p">){</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//记录访问过的顶点</span>
    <span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="n">n</span><span class="o">&gt;</span> <span class="n">visited</span> <span class="o">=</span> <span class="p">{</span><span class="nb">false</span><span class="p">};</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="c1">//记录前驱节点，创建n个桶</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">prev</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="c1">//访问x的邻接顶点</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">adj</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">adj</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">y</span><span class="p">]){</span>
                <span class="c1">//记录y的前驱为x</span>
                <span class="n">prev</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
                <span class="c1">//找到目标节点</span>
                <span class="k">if</span><span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">y</span><span class="p">){</span>
                    <span class="n">print_path</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">);</span>
                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>下面我们来分析一下时间复杂度，DFS 和 BFS 每个顶点访问一次，对每一条边处理一次 (无向图的每条边从两个方向处理)</p>

<ol>
  <li>采用邻接表表示时，有向图总代价为 $\Theta(n + e)$，无向图为 $\Theta(n + 2e)$</li>
  <li>采用相邻矩阵表示时，理论上，处理所有的边需要 $\Theta(n^2)$的时间 ，所以总代价为$\Theta(n + n^2) = \Theta(n^2)$。但实际上，在执行<code class="highlighter-rouge">nextNbr(v,u)</code>时，可认为是常数时间，因此它的时间复杂度也可以近似为$\Theta(n + e)$</li>
</ol>

<p>广度优先搜索和深度优先搜索是图上的两种最常用、最基本的搜索算法，比起其他高级的搜索算法，比如 A<em>、IDA</em> 等，要简单粗暴，没有什么优化，所以，也被叫作暴力搜索算法。所以，这两种搜索算法仅适用于状态空间不大，也就是说图不大的搜索。在下一篇文章中，我们会继续介绍几种带权图的搜索方法以及图相关的其它内容</p>

<h3 id="resources">Resources</h3>

<ul>
  <li><a href="https://www.youtube.com/watch?v=NcZ2cu7gc-A&amp;list=PLnfg8b9vdpLn9exZweTJx44CII1bYczuk">CS106B-Stanford-YouTube</a></li>
  <li><a href="https://www.coursera.org/learn/algorithms-divide-conquer/home/welcome">Algorithms-Stanford-Cousera</a></li>
  <li><a href="https://www.coursera.org/learn/shuju-jiegou-suanfa/home/welcome">算法与数据结构-1-北大-Cousera</a></li>
  <li><a href="https://www.coursera.org/learn/gaoji-shuju-jiegou/home/welcome">算法与数据结构-2-北大-Cousera</a></li>
  <li><a href="https://courses.edx.org/courses/course-v1:TsinghuaX+30240184.1x+3T2017/course/">算法与数据结构-1-清华-EDX</a></li>
  <li><a href="https://courses.edx.org/courses/course-v1:PekingX+04833050X+1T2016/course/">算法与数据结构-2-清华-EDX</a></li>
  <li><a href="https://www.coursera.org/learn/algorithms/home/welcome">算法设计与分析-1-北大-Cousera</a></li>
  <li><a href="https://courses.edx.org/courses/course-v1:PekingX+04833050X+1T2016/course/">算法设计与分析-2-北大-EDX</a></li>
</ul>
:ET