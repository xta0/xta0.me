I"·?<h3 id="how-does-c-code-become-assembly">How Does C Code Become Assembly</h3>

<p>The compiler does a lot of stuff to translate C code to assembly</p>

<ul>
  <li>Choose assembly instructions to implement C oeprations</li>
  <li>Implement C conditionals and loops using jumps and branches</li>
  <li>Choose registers and memory locations to store data</li>
  <li>Move data among the registers and memory to satifisy dependecies</li>
  <li>Coordinate function calls</li>
  <li>Try to make the assembly fast.</li>
</ul>

<p>However, the direct mapping from C to assembly is not so obvious</p>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-1.png" /></p>

<h3 id="clangllvm-compilation-pipeline">Clang/LLVM Compilation Pipeline</h3>

<p>To understand this translation process, let us see how the compiler reasons about it.</p>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-2.png" /></p>

<p>You can see what <code class="highlighter-rouge">clang</code> compiler does by looking at the LLVM IR</p>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-3.png" /></p>

<h2 id="outline">outline</h2>

<ul>
  <li>LLVM IR Primer</li>
  <li>C To LLVM IR
    <ul>
      <li>Straigh-line C code to LLVM IR</li>
      <li>C functions to LLVM IR</li>
      <li>C conditions to LLVM IR</li>
      <li>LLVM IR aatributes</li>
    </ul>
  </li>
  <li>LLVM IR to Assembly
    <ul>
      <li>Linux x86-64 calling convention</li>
    </ul>
  </li>
</ul>

<h3 id="components-of-llvm-ir">Components of LLVM IR</h3>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-4.png" /></p>

<p>LLVM IR is similar to assembly</p>
<ul>
  <li>LLVM IR uses a simple instruction format, i.e., <code class="highlighter-rouge">&lt;dst operand&gt; = &lt;op code&gt;&lt;src operands&gt;</code></li>
  <li>LLVM IR code adopts a similar structure to assembly code</li>
  <li>Control flow is implemented using conditional and unconditional branches</li>
</ul>

<p>LLVM IR is simpler than assembly</p>
<ul>
  <li>Smaller instruction set</li>
  <li>Infinite LLVM IR registers, similar to variables in C</li>
  <li>No implicit FLAGS register or condition codes</li>
  <li>No explicit stack pointer or frame pointer</li>
  <li>C-like type system</li>
  <li>C-like functions</li>
</ul>

<h3 id="llvm-ir-registers">LLVM IR Registers</h3>

<p>LLVM IR stores values variables, called registers</p>
<ul>
  <li>Syntax: <code class="highlighter-rouge">%&lt;name&gt;</code></li>
  <li>LLVM register are like C variables: LLVM supports an infinite number of registers, each distinguished by name</li>
  <li>Register names are local to each LLVM IR function</li>
</ul>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-5.png" /></p>

<p>One catch: We shall see that LLVM hijacks its syntax for registers to refer to ‚Äúbasic blocks‚Äù.</p>

<h3 id="llvm-ir-instructions">LLVM IR Instructions</h3>

<p>LLVM-IR code is organized into instructions</p>
<ul>
  <li>Syntax for instructions that produce a value: <code class="highlighter-rouge">%&lt;name&gt; = &lt;opcode&gt; &lt;operand list&gt;</code></li>
  <li>Syntax for other insturctions: <code class="highlighter-rouge">&lt;opcode&gt; &lt;operand list&gt;</code></li>
  <li>Operands are registers, constants, or ‚Äúbasica blocks‚Äù</li>
</ul>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-6.png" /></p>

<h3 id="common-llvm-ir-instructions">Common LLVM IR Instructions</h3>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-7.png" /></p>

<h3 id="llvm-ir-data-types">LLVM IR Data Types</h3>

<ul>
  <li>Integers: <code class="highlighter-rouge">i&lt;number&gt;</code>
    <ul>
      <li>A 64-bit integer: <code class="highlighter-rouge">i64</code></li>
      <li>A 1-bit integer: <code class="highlighter-rouge">i1</code></li>
    </ul>
  </li>
  <li>Floating-point values: <code class="highlighter-rouge">double</code>, <code class="highlighter-rouge">float</code></li>
  <li>Arrays: <code class="highlighter-rouge">[&lt;number&gt; x &lt;type&gt;]</code>
    <ul>
      <li>An array of 5 integer: <code class="highlighter-rouge">[5 x i32]</code></li>
    </ul>
  </li>
  <li>Structs: <code class="highlighter-rouge">{&lt;type&gt;, ...}</code></li>
  <li>Vectors: <code class="highlighter-rouge">&lt; &lt;number&gt; x &lt;type&gt; &gt;</code></li>
  <li>Pointers: <code class="highlighter-rouge">&lt;type&gt;*</code>
    <ul>
      <li>A pointer to an 8-bit integer: <code class="highlighter-rouge">i8*</code></li>
    </ul>
  </li>
  <li>Labels(i.e., basic blocks): <code class="highlighter-rouge">label</code></li>
</ul>

<h3 id="straight-line-c-code-to-llvm-ir">Straight-line C code to LLVM IR</h3>

<p>Straight-line C code (i.e., containing no conditionals or loops) becomes a sequence of LLVM IR instructions</p>
<ul>
  <li>Arguments are evaluated before the C operation</li>
  <li>Intermediate results are stored in registers</li>
</ul>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-8.png" /></p>

<p><strong>Aggregate Types</strong></p>

<p>A variable with an aggregate type (i.e., an array or a struct) is typically stored in memory. Accessing the aggregate type involves computing an address and then reading or writing memory.</p>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-9.png" /></p>

<p>The <code class="highlighter-rouge">getelementptr</code> instruction computes a memory address from a pointer and a list of indices. Example: Compute the address <code class="highlighter-rouge">%2 + 0 + %4</code>.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>%5 <span class="o">=</span> getelementptr inbounds <span class="o">[</span>7 x i32], <span class="o">[</span>7 x i32]<span class="k">*</span> %2, i64 0, i64 %4
</code></pre></div></div>

<h3 id="llvm-ir-functions">LLVM IR Functions</h3>

<p>Functions in LLVM IR resemble functions in C.</p>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-10.png" /></p>

<p>LLVM IR function parameters map directly to their C counterparts.</p>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-11.png" /></p>

<h3 id="baisc-blocks">Baisc Blocks</h3>

<p>The body of a function definition is partitioned into basic blocks: sequence of instructions (i.e., straight-line code) where control only enters through the first instruction and only exists from the last.</p>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-12.png" /></p>

<h3 id="control-flow-graphs">Control-Flow Graphs</h3>

<p>Control-flow instructions (e.g., <code class="highlighter-rouge">br</code> instructions) induce <strong>control-flow edges</strong> between the basic blocks of a function, creating a <strong>control-flow graph(CFG)</strong>.</p>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-13.png" /></p>

<h3 id="c-conditionals">C Conditionals</h3>

<p>A conditional in C is translated into a <strong>conditional branch instruction</strong>, <code class="highlighter-rouge">br</code>, in LLVM IR</p>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-14.png" /></p>

<p>The conditional branch in LLVM IR takes as arugments a <code class="highlighter-rouge">1-bit</code> integer and two <code class="highlighter-rouge">basic-blcok labels</code>.</p>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-15.png" /></p>

<p>A conditional branch terminates its basic block and creates 2 outgoing control-flow edeges in CFG.</p>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-16.png" /></p>

<h3 id="unconditional-branches">Unconditional Branches</h3>

<p>If a <code class="highlighter-rouge">br</code> instructions has just one operand, it is an <strong>unconditional branch</strong></p>

<p>An unconditional branch terminates its basic block and produces <code class="highlighter-rouge">1</code> outgoing control-flow edge.</p>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-17.png" /></p>

<p>In general, a C conditional typically creates a <strong>diamond pattern</strong> in the CFG</p>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-18.png" /></p>

<h3 id="loops">Loops</h3>

<p>The loop control for a C loop consists of a loop induction variable, an initialization, a condition, and an increment. The induction varaible changes registers at the code for the loop increment.</p>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-19.png" /></p>

<p>LLVM IR maintains the <strong>static single assignment(SSA)</strong> invariant: a register is defined by at most one instruction in a function. But what happens to the induction variable which changes as iteration goes or as the loop unfolds ? The answer is <code class="highlighter-rouge">phi</code> instruction.</p>

<p>The <code class="highlighter-rouge">phi</code> instruction speficies, for each predecessor <code class="highlighter-rouge">p</code> of a basic block <code class="highlighter-rouge">B</code>, the value of the destination register if control enters <code class="highlighter-rouge">B</code> via <code class="highlighter-rouge">P</code>.</p>

<div class="md-flex-h md-flex-no-wrap">
<div><img class="md-img-center" src="/assets/images/2021/07/perf-5-20.png" /></div>
<div class="md-margin-left-12"><img class="md-img-center" src="/assets/images/2021/07/perf-5-21.png" /></div>
</div>

<p>In this particular code, the <code class="highlighter-rouge">phi</code> instruction says, if the the code comes from <code class="highlighter-rouge">block6</code> which is the entry point the loop, then the reigster <code class="highlighter-rouge">%9</code> is going to be <code class="highlighter-rouge">0</code>. Otherwise, it is going to adpot the value <code class="highlighter-rouge">%14</code> which holds the incremental operation (<code class="highlighter-rouge">i+=1</code>).</p>

<ul>
  <li>A block with <strong>multiple incoming edges</strong> may have <code class="highlighter-rouge">phi</code> instructions</li>
  <li>The <code class="highlighter-rouge">phi</code> instruction is not a real instruction. It won‚Äôt appear in the assembly, it‚Äôs just a trick for LLVM to represent loops.</li>
</ul>

<h3 id="llvm-ir-attributes">LLVM IR Attributes</h3>

<p>LLVM IR constructs (e.g., instructions, operands, functions, and function parameter) might be decorated with <strong>attributes</strong>. Some attributes are derived from the source code.</p>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-22.png" /></p>

<p>Other attributes are determined by compiler analysis.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>%15 <span class="o">=</span> load double, double<span class="k">*</span> %24, align 8
</code></pre></div></div>

<h3 id="summary-of-llvm-ir">Summary of LLVM IR</h3>

<p>LLVM IR is similar to assembly, but simpler.</p>
<ul>
  <li>All computed values are stored in registers.</li>
  <li>SSA: Each reigster name is written on at most one line of IR</li>
  <li>A function is modeled as a <strong>control-flow graph</strong>, whose nodes are basic blocks(straight line code), and whose edges denote control flow between basic blocks.</li>
  <li>Compared to C, all operators are explict.
    <ul>
      <li>All integer sizes are apparent.</li>
      <li>There are no implicit operations, e.g., type casts.</li>
    </ul>
  </li>
</ul>

<h2 id="llvm-ir-to-assembly">LLVM IR to Assembly</h2>

<p>THe compiler must perform three tasks to translate LLVM IR into x86-64 assembly.</p>

<ul>
  <li>Select assembly instructions to implement LLVM IR instructions.</li>
  <li>Allocate x86-64 general-purpose registers to hold values.</li>
  <li>Coordinate function calls.</li>
</ul>

<p>When a program executes, virutal memory is organized into <strong>segments</strong>.</p>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-23.png" /></p>

<p>Assembly code contains <strong>directives</strong> that refer to and operate on sections of assembly.</p>

<ul>
  <li><strong>Segment directives</strong> organize the contents of an assembly file into segments.</li>
  <li><code class="highlighter-rouge">.text</code>: Identifies the text segment</li>
  <li><code class="highlighter-rouge">.bss</code>: Identifies the bss segment</li>
  <li>
    <p><code class="highlighter-rouge">.data</code>: Identifies the data segment</p>
  </li>
  <li><strong>Storage directives</strong> store content into the current segment
    <ul>
      <li><code class="highlighter-rouge">x: .space 20</code> : Allcoate 20 bytes at location <code class="highlighter-rouge">x</code></li>
      <li><code class="highlighter-rouge">y: .long 172</code> Stores the constant <code class="highlighter-rouge">172L</code> at the location <code class="highlighter-rouge">y</code></li>
      <li><code class="highlighter-rouge">z: .asciz "6.172" : Store the string "6.172\0" at location </code>z`</li>
      <li><code class="highlighter-rouge">.align 8</code>: Align the next content to 8-byte boundary.</li>
    </ul>
  </li>
  <li><strong>Scope and linkage directive</strong> control linking.
    <ul>
      <li>Example <code class="highlighter-rouge">.globl fib</code>: Makes ‚Äúfib‚Äù visiable to other object files.</li>
    </ul>
  </li>
</ul>

<h3 id="stack-segment">Stack Segment</h3>

<p>The stack segment stores data in memory to manage function calls and returns. More specifically, what data is stored on the stack?</p>

<ul>
  <li>The return address of a function call</li>
  <li>Register state, so different functions can use the same registers</li>
  <li>Function arguments and local variables that don‚Äôt fit in the registers.</li>
</ul>

<h3 id="coodinating-function-calls">Coodinating Function Calls</h3>

<p>Hwo do functions in different object files coordinate their use of the stack and of register state?</p>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-24.png" /></p>

<p>Answer: Functions abide by a <strong>calling convention</strong></p>

<h3 id="the-linux-x86-64-calling-convention">The Linux x86-64 calling convention</h3>

<p>The Linux x86-64 calling convention organizes the stack into <strong>frames</strong>, where each function instantiation gets a single frame of its own.</p>

<ul>
  <li>The <code class="highlighter-rouge">%rbp</code> register points to the <strong>top</strong> of the current stack frame</li>
  <li>The <code class="highlighter-rouge">%rsp</code> register points to the <strong>bottom</strong> of the current stack frame</li>
</ul>

<p>The <code class="highlighter-rouge">call</code> and <code class="highlighter-rouge">ret</code> instructions use the stack and the instruction pointer, <code class="highlighter-rouge">%rip</code>, to manage the <strong>return address</strong> of each function call.</p>

<ul>
  <li>A <code class="highlighter-rouge">call</code> instruction pushes <code class="highlighter-rouge">%rip</code> onto the stack and jumps to the operand, which is the address of a function.</li>
  <li>A <code class="highlighter-rouge">ret</code> instrutcion pops <code class="highlighter-rouge">%rip</code> from the stack and returns to the caller.</li>
</ul>

<p>PROBLEM: Say we have two functions, function A wants to call function B. Those functions might want to use the same registers. Who‚Äôs responsible for preserving the register state across a function call and return? e.g., A doesn‚Äôt get corrupted data from reigsters.</p>

<ul>
  <li>The caller might waste work saving register stat that the callee doesn‚Äôt use.</li>
  <li>The callee might waste work saving register state that the caller wasn‚Äôt using.</li>
</ul>

<p>The Linux x86-64 calling convention does a bit both.</p>

<ul>
  <li><strong>Callee-saved</strong> registers: <code class="highlighter-rouge">%rbx, %rbp, %r12-%r15</code></li>
  <li>All other registers are <strong>caller-saved</strong></li>
</ul>

<p><img class="md-img-center" src="/assets/images/2021/07/perf-5-25.png" /></p>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://www.youtube.com/watch?v=wt7a5BOztuM&amp;list=PLUl4u3cNGP63VIBQVWguXxZZi0566y7Wf&amp;index=5">MIT 6.172</a></li>
  <li><a href="https://xta0.me/2015/10/08/Linkers-and-Loaders-LLVM-IR-1.html">LLVM IR</a></li>
</ul>
:ET