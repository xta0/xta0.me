I"85<p><em>  </em></p>

<blockquote>
  <p>From “Programming in Lua”</p>
</blockquote>

<h2 id="24">Chap24: An Overview of the C API</h2>

<p>lua是一种嵌入式语言。这意味着lua不是一个封闭的体系，它可以作为库和其它应用程序一起工作。
也许你会奇怪：如果Lua不是一个封闭的独立的体系，为什么我们整本书都在单独使用Lua？这个问题的答案是Lua interpreter。这个解释器是一个不到四百行的应用程序，它用来处理和用户的交互，接收用户输入的文件和字符串并把它们解释执行。</p>

<p>这种作为库供其它应用程序使用的特性使Lua成为了一种extension Language。同时，我们也可以在Lua中注册一些C函数，和C的模块，这使得Lua同时也成为了一种extensile Language。</p>

<p>这两种特性决定了Lua和C的两种调用关系。第一种Lua作为库提供给C调用，C是应用程序代码。第二种是在Lua的环境中调用C，这时C代码变成了库。</p>

<p>用来和Lua通信的C API包含了对Lua全局变量的读写，对Lua函数的调用以及注册一些函数供Lua以后使用等等。</p>

<p>用C编程时，我们必须要注意类型检查，错误处理，内存的分配和回收和一些其它复杂的内容。你还需要检查函数的参数是否合法，如果你的函数出错，你会收到“segmentation fault”这种段错误，而不是带有描述性的错误信息。此外，C API更强调灵活性和简介，这会带来一些使用成本。要实现一些功能通常会需要多个C API调用，这看起来会很枯燥，但是却可以掌控很多细节。</p>

<p>如标题所述，本章是一篇关于在C中使用Lua的综述。你现在不需要了解这其中的细节。后面我们会详细讨论这里面的用到的知识。此外，不要忘记你可以通过Lua手册来查看函数的细节。此外，Lua的发行版本中就包含了对C API使用的例子，比如lua.c提供了Lua的解释器程序，标准库如lmathlib.c,lstrlib.c等也提供了例子的代码。</p>

<p>从现在开始我们进入C的世界。</p>

<p>Lua和C通信最关键的媒介是virtual stack。几乎所有的C API都在这个stack中执行。所有Lua和C的数据交换也在这个stack中发生，此外你还可以通过这个stack来保存临时变量，等等。这个stack有两个作用：一个是为Lua提供回收C中对象的场所，另一个用来做动态类型和静态类型的转换。</p>

<h3 id="a-first-example">A First Example</h3>

<p>lua.h定义了Lua中的基本函数，包含了创建lua环境，调用Lua函数（比如lua_pcall），读写全局变量，注册新函数等等。所有定义在Lua.h中得方法以lua_开头。</p>

<p>luaxlib.h定义了auxlib库中提供的函数，里面的函数以luaL_开头。它没有权限访问到lua的内部结构，它只是lua.h中API得的封装
lualib.h中定义了访问lib库的函数，luaL_openlibs开启所有lib库</p>

<p>lua的lib中没有全局变量，它把所有的状态都保存到了lua_State中。</p>

<p>luaL_newState用来创建一个lua环境，这个stack中不包含任何信息。</p>

<p>luaL_loadbuffer 用来编译代码，如果没有错误，这个函数返回0，将结果push到stack中</p>

<p>lua_pcall首先将compile后的stack中的代码pop出来，然后执行。如果没有错误返回0，如果有错误，两个函数都会将错误push到stack上</p>

<h3 id="the-stack">The Stack</h3>

<p>在C和Lua的通信中，有两个问题需要解决：</p>

<p>1，动态类型和静态类型的转换
2，内存回收问题</p>

<p>在lua中，类似<code class="highlighter-rouge">a[k] = v</code>的代码很多，a,k,v均可为任意类型，那在C语言中如何实现它？我们可以利用Union定义一个lua_Value，然后定义一个类似这样的函数：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">lua_settable</span><span class="p">(</span><span class="n">lua_Value</span> <span class="n">a</span><span class="p">,</span> <span class="n">lua_Value</span> <span class="n">k</span><span class="p">,</span> <span class="n">lua_Value</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div></div>

<p>这样做有两个弊端：第一个弊端是无法将lua_Value这个结构映射到其他的语言中，比如Java，C#等。第二个弊端是lua无法确定是否该回收这个变量。</p>

<p>因此lua并没有定义lua_Value这种类型，我们用abstract stack来实现。stack中得每个slot都可以存储任意类型的lua数据。</p>

<p>赋值：<code class="highlighter-rouge">a=1</code>
首先lua会把1 push到stack中，然后执行a=1，最后把1 pop出来</p>

<p>访问：<code class="highlighter-rouge">print(a)</code>
首先lua会把a push到stack中，然后执行<code class="highlighter-rouge">print(a)</code>,最后把a pop出来。</p>

<p>向stack中push数据：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">lua_pushnil</span> <span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">lua_pushboolean</span> <span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bool</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">lua_pushnumber</span>  <span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="n">lua_Number</span> <span class="n">n</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">lua_pushinteger</span> <span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="n">lua_Integer</span> <span class="n">n</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">lua_pushlstring</span> <span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">lua_pushstring</span> <span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span>

</code></pre></div></div>

<p><code class="highlighter-rouge">lua_Number</code>默认为double类型
<code class="highlighter-rouge">lua_Integer</code>可存放大数据，被定义为<code class="highlighter-rouge">ptrdiff_t</code>类型</p>

<p>lua中的字符串默认没有’\0’结尾，因此需要手动指定长度, 通过<code class="highlighter-rouge">lua_pushlstring</code>去push到stack中</p>

<p>对于有’\0’结尾的字符串，可以用lua_pushstring，它会调用<code class="highlighter-rouge">strlen</code>来返回字符串长度。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">lua_chackstack</span><span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">)</span>
</code></pre></div></div>

<p>用来查看stack的空间</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">lua_is</span><span class="o">*</span> <span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span><span class="err">`</span>
</code></pre></div></div>

<p>用来检查stack某个index中的value是否是*类型</p>

<p>通常我们不会用这个方法，我们先获取value，然后判断它是否为0或NULL</p>

<p>取值的方法为：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">lua_toboolean</span><span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="n">lua_Number</span> <span class="n">lua_tonumber</span><span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="n">lua_Integer</span> <span class="n">lua_tointeger</span><span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">lua_tolstring</span><span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span><span class="kt">size_t</span><span class="o">*</span> <span class="n">len</span><span class="p">)</span>
<span class="kt">size_t</span> <span class="n">lua_objlen</span><span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>

</code></pre></div></div>

<p>这些值取回后，在使用前，应先判断是否为0或NULL，对于lua_tolstring，返回的字符串是const的，因此不能修改，返回的字符串都是以’\0’结尾的。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="n">l</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span> <span class="o">=</span> <span class="n">lua_tolstring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">&amp;</span><span class="n">l</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">);</span> <span class="c1">//true</span>
<span class="n">assert</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//true</span>
</code></pre></div></div>

<p>其它的关于操作stack的API：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//number of elements in stack:index of the top element</span>
<span class="kt">int</span> <span class="nf">lua_gettop</span> <span class="p">(</span><span class="n">luaState</span><span class="o">*</span> <span class="n">L</span><span class="p">);</span>

<span class="c1">//用来设置top element的index</span>
<span class="kt">void</span> <span class="nf">lua_settop</span><span class="p">(</span><span class="n">luaState</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">);</span>


</code></pre></div></div>

<p>对于<code class="highlighter-rouge">void lua_settop(luaState* L, int index)</code>这个方法，如果index值大于当前stack的top值，则[top index]的部分填充为nil。如果index值小于当前stack的top值，则[index top]这个区间的值被discard掉。</p>

<p>有些情况下使用：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lua_settop</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
	
</code></pre></div></div>
<p>来清空这个stack，也可以通过下面的API，来pop n个elements</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">define</span> <span class="n">lua_pop</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="n">lua_settop</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

</code></pre></div></div>
<h3 id="error-handling-with-c-api">Error Handling with C API</h3>

:ET