I"iU<h3 id="lunching-thread">Lunching Thread</h3>

<p>C++ 11中对线程的管理集中在<code class="highlighter-rouge">std::thread</code>这个类中，创建线程的方式包括：</p>

<ol>
  <li>使用回调函数</li>
  <li>使用函数对象</li>
  <li>使用Lambda表达式</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">funcptr</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">name</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">struct</span> <span class="n">Functor</span><span class="p">{</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">string</span> <span class="n">name</span><span class="p">){</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">name</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">runCode</span><span class="p">(){</span>
	<span class="c1">//使用function pointer</span>
	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">func1</span><span class="p">,</span><span class="s">"abc"</span><span class="p">);</span>
	<span class="n">t1</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>

	<span class="c1">//使用Functor</span>
	<span class="n">Functor</span> <span class="n">f</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="s">"Functor thread is running"</span><span class="p">);</span>
	<span class="n">t2</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>

	<span class="c1">//使用lambda</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">p</span> <span class="o">=</span> <span class="s">"lambda thread is running"</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t3</span><span class="p">([</span><span class="n">p</span><span class="p">]{</span>
		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
	<span class="p">});</span>
	<span class="n">t3</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">std::thread</code>是C++11引入的用来管理多线程的新类，是对UNIX C中<code class="highlighter-rouge">pthread_t</code>结构体的封装，构造时调用<code class="highlighter-rouge">pthread_create</code>传入<code class="highlighter-rouge">pthread_t</code>和回调函数指针</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="n">pthread_t</span> <span class="n">__libcpp_thread_t</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">_LIBCPP_TYPE_VIS</span> <span class="kr">thread</span><span class="p">{</span>
    <span class="n">__libcpp_thread_t</span> <span class="n">__t_</span><span class="p">;</span> <span class="c1">//pthread_t</span>
	<span class="p">...</span>
<span class="p">}</span>
<span class="kr">thread</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">_Fp</span><span class="o">&amp;&amp;</span> <span class="n">__f</span><span class="p">,</span> <span class="n">_Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">__args</span><span class="p">){</span>
	<span class="p">...</span>
	<span class="kt">int</span> <span class="n">__ec</span> <span class="o">=</span> <span class="n">__libcpp_thread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__t_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__thread_proxy</span><span class="o">&lt;</span><span class="n">_Gp</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">__p</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">__ec</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">__p</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
   	 <span class="k">else</span>
        <span class="n">__throw_system_error</span><span class="p">(</span><span class="n">__ec</span><span class="p">,</span> <span class="s">"thread constructor failed"</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">__libcpp_thread_create</span><span class="p">(</span><span class="n">__libcpp_thread_t</span> <span class="o">*</span><span class="n">__t</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">__func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
                           <span class="kt">void</span> <span class="o">*</span><span class="n">__arg</span><span class="p">){</span>
  <span class="k">return</span> <span class="n">pthread_create</span><span class="p">(</span><span class="n">__t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">__func</span><span class="p">,</span> <span class="n">__arg</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">std::thread</code>的构造函数中前两个参数均为右值引用，第二个参数将传入的lambda表达式或者functor通过<code class="highlighter-rouge">__thread_proxy&lt;_Gp&gt;</code>转化成C函数指针（<code class="highlighter-rouge">void *(*__func)(void *)</code>，这个问题可参考<a href="https://xta0.me/2009/08/30/CPP-Basics-3.html">之前对C++11中 <code class="highlighter-rouge">move</code>语义的介绍</a>。<code class="highlighter-rouge">std::thread</code>对象在创建后，如果不做其它操作，线程立刻执行，这里称这个线程为<code class="highlighter-rouge">worker_thread</code>，称发起<code class="highlighter-rouge">worker_thread</code>的线程为<code class="highlighter-rouge">launch_thread</code>。</p>

<p>如果<code class="highlighter-rouge">std::thread</code>对像在被销毁前未执行<code class="highlighter-rouge">join()</code>或<code class="highlighter-rouge">detach()</code>操作，则在其析构函数中会调用<code class="highlighter-rouge">std::terminate</code>造成系统崩溃。因此需要确保所有创建的<code class="highlighter-rouge">std::thread</code>对象都能被正常释放，在《C++ Concurrency in Action》中，提到了一种方法：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">thread_guard</span><span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">;</span>
<span class="nl">public:</span>
	<span class="k">explicit</span> <span class="n">thread_guard</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&amp;</span> <span class="n">t_</span><span class="p">)</span><span class="o">:</span><span class="n">t</span><span class="p">(</span><span class="n">t_</span><span class="p">){}</span>
	<span class="o">~</span><span class="n">thread_guard</span><span class="p">(){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">joinable</span><span class="p">()){</span>
			<span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">thread_guard</span><span class="p">(</span><span class="n">thread_guard</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
	<span class="n">thread_guard</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">thread_guard</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">runCode</span><span class="p">(){</span>
	<span class="p">...</span>
	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
	<span class="n">thread_guard</span> <span class="n">g</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="c1">//g在t之前释放，保证join的调用</span>
	<span class="n">do_something_in_current_thread</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<p>由于<code class="highlighter-rouge">thread_guard</code>对象总是在<code class="highlighter-rouge">std::thread</code>对象之前析构，因此可以在<code class="highlighter-rouge">t</code>析构之前调用<code class="highlighter-rouge">join</code>函数，保证<code class="highlighter-rouge">t</code>可以安全释放。</p>

<blockquote>
  <p>这种方式是所谓的<strong>RAII(Resource Acquisition Is  Initialization)</strong>，即通过构造某个对象来获得某个资源的控制，在该对象析构时，释放被控制的资源。也就是将某资源和某对象的生命周期做绑定，在C++中这是一种很常用的设计方式，背后的原因是C++允许栈对象的创建和析构，后面在讨论mutex时还会继续用到这种技术</p>
</blockquote>

<h3 id="join--detach">Join &amp; Detach</h3>

<p><code class="highlighter-rouge">join()</code>是<code class="highlighter-rouge">launch_thread</code>和<code class="highlighter-rouge">worker_thread</code>的一个线程同步点，<code class="highlighter-rouge">launch_thread</code>会在调用<code class="highlighter-rouge">join()</code>后等待<code class="highlighter-rouge">worker_thread</code>执行完成后继续执行</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">p</span> <span class="o">=</span> <span class="s">"lambda"</span><span class="p">;</span>
<span class="c1">//using lambda expression as a callback function</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">td</span><span class="p">([</span><span class="n">p</span><span class="p">]{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="s">" thread is running"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;});</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"lanched thread is running"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="n">td</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"lanched thread is running"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="n">td</span><span class="p">.</span><span class="n">joinable</span><span class="p">();</span> <span class="c1">//return false</span>
</code></pre></div></div>

<ol>
  <li>如果<code class="highlighter-rouge">td</code>在<code class="highlighter-rouge">main thread</code>执行<code class="highlighter-rouge">td.join()</code>之前完成，则<code class="highlighter-rouge">td.join()</code>直接返回，否则<code class="highlighter-rouge">launch_thread</code>会暂停，等待<code class="highlighter-rouge">td</code>执行完成</li>
  <li>如果不调用<code class="highlighter-rouge">td.join()</code>或<code class="highlighter-rouge">td.detach()</code>，在<code class="highlighter-rouge">td</code>对象销毁时，在<code class="highlighter-rouge">std::thread</code>的析构函数中，如果则系统会发出<code class="highlighter-rouge">std::terminate</code>的错误</li>
  <li><code class="highlighter-rouge">td</code>在调用<code class="highlighter-rouge">join</code>后，<code class="highlighter-rouge">joinable</code>转态变为<code class="highlighter-rouge">false</code>，此时<code class="highlighter-rouge">td</code>可被安全释放</li>
  <li>确保<code class="highlighter-rouge">join()</code>只被调用一次</li>
</ol>

<p>如果使用<code class="highlighter-rouge">td.detach()</code>则<code class="highlighter-rouge">workder_thread</code>在创建后立刻和<code class="highlighter-rouge">launch_thread</code>分离，<code class="highlighter-rouge">launch_thread</code>不会等待<code class="highlighter-rouge">workder thread</code>执行完成。即两条线程没有同步点，各自独立执行</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">runCode</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"lanched thread is running"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">p</span> <span class="o">=</span> <span class="s">"lambda"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">td</span><span class="p">([</span><span class="n">p</span><span class="p">]</span> <span class="p">{</span> 
        <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">5000</span><span class="p">));</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="s">" thread is running"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
    <span class="p">});</span>
    <span class="n">td</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"lanched thread is ending"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>上述代码中令<code class="highlighter-rouge">workder thread</code>暂停5s，则<code class="highlighter-rouge">launch_thread</code>继续执行，不会等待<code class="highlighter-rouge">worker_thread</code>执行完，如果将<code class="highlighter-rouge">detach()</code>改为<code class="highlighter-rouge">join()</code>则<code class="highlighter-rouge">launch_thread</code>会阻塞等待</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//detach
lanched thread is running
lanched thread is ending

//join
lanched thread is running
lambda thread is running
lanched thread is ending
</code></pre></div></div>

<h3 id="向线程传递参数">向线程传递参数</h3>

<p>向<code class="highlighter-rouge">std::thread</code>构造函数传递参数的规则为：</p>

<ol>
  <li>第一个参数为函数指针，可以是functor或者lambda表达式，在第一节中已经介绍</li>
  <li>后面参数为该函数指针需要用到的参数</li>
</ol>

<p>观察前面的<code class="highlighter-rouge">std::thread</code>的构造函数可知，传递的参数均是拷贝到线程自己stack中，但是有某些场景，需要修改<code class="highlighter-rouge">lauch_thread</code>所在线程的局部变量，这是需要将该变量的引用传递给<code class="highlighter-rouge">worker_thread</code>。例如下面的例子中需要在<code class="highlighter-rouge">worker_thread</code>中修改<code class="highlighter-rouge">data</code>变量</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">updateData</span><span class="p">(</span><span class="n">widget_data</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">oops</span><span class="p">(){</span>
	<span class="n">widget_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">updateData</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span> <span class="c1">//这里传过去的是data的copy</span>
	<span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
	<span class="n">process_widget_data</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p><a href="">参考之前文章中对<code class="highlighter-rouge">bind</code>函数的介绍</a>，可知这里只需要一个很小的改动，使用<code class="highlighter-rouge">std::ref(x)</code>，即可把<code class="highlighter-rouge">data</code>从传拷贝变成传引用：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">updateData</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</code></pre></div></div>
<blockquote>
  <p>如果传引用或者指针要特别注意变量的生命周期，如果该变量的内存在线程还未结束时被释放则会引<code class="highlighter-rouge">undefined behavior</code></p>
</blockquote>

<p>为了进一步加深对<code class="highlighter-rouge">std::thread</code>构造函数的理解，继续参考<code class="highlighter-rouge">bind</code>函数不难发现，<code class="highlighter-rouge">std::thread</code>的构造函数和<code class="highlighter-rouge">bind</code>的传参机制是相同的，这意味者只要第一个函数时一个函数指针，后面是该函数的参数即可，因此可以不局限于使用第一小节介绍的三种构建线程的方式，比如：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">X</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">do_some_work</span><span class="p">(){</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"do_some_work"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>
<span class="n">X</span> <span class="n">x</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">t</span><span class="p">(</span><span class="o">&amp;</span><span class="n">X</span><span class="o">::</span><span class="n">do_some_work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
<span class="n">t</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
</code></pre></div></div>
<p>上述代码中，<code class="highlighter-rouge">X::do_some_work</code>方法的第一个参数为<code class="highlighter-rouge">this</code>指针，因此可将<code class="highlighter-rouge">x</code>取地址后传入，可达到相同效果。</p>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://www.manning.com/books/c-plus-plus-concurrency-in-action?">《C++ Concurrency in Action》</a></li>
  <li><a href="">《C++ Primer 3rd edition》</a></li>
  <li><a href="https://www.classes.cs.uchicago.edu/archive/2013/spring/12300-1/labs/lab6/">C++ 11 Concurrency</a></li>
  <li><a href="https://www.educative.io">Modern C++ Concurrency in Practice: Get the most out of any machine</a></li>
</ul>
:ET