I"\<p>二分法是实际生活中用到的最多的一种非常高效的算法，使用二分法的前提是待查找的数组是有序，其代码模板为</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">bsearch</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="p">(</span><span class="n">hi</span><span class="o">-</span><span class="n">lo</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">){</span>
			<span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
		<span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">){</span>
			<span class="n">lo</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span><span class="k">else</span><span class="p">{</span>
			<span class="n">hi</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面实现的二分法适用于有序数组中没有重复元素的情况，但实际应用中情况往往比较复杂，数组中可能会存在大片的重复元素或者只有局部有序的情况，因此想写对二分法实际上并不容易。比如下面几种场景：</p>

<ol>
  <li>查找第一个值等于给定值的元素</li>
  <li>查找最后一个值等于给定值的元素</li>
  <li>查找第一个大于等于给定值的元素</li>
  <li>查找最后一个小于等于给定值的元素</li>
</ol>

<h3 id="二分法的变种">二分法的变种</h3>

<p>对于第一个问题，如果数组中存在重复元素，则检索target到的第一个位置可能不是唯一的一个，例如下面数组：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">18</span><span class="p">};</span>

<span class="n">index</span><span class="o">:</span>		  <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span>  <span class="mi">8</span>  <span class="mi">9</span> 
</code></pre></div></div>
<p>我们希望查找到第一个值的等于8的数据，也就是下标为5的元素。如果按照上面标准的二分法查找，则找到的8的位置位于<code class="highlighter-rouge">a[7]</code>，显然不符合我们的要求，因此，针对这种情况我们需要对上面的二分查找做一下修改。显然，一种最直观的解法是当找到8后，一路向左遍历，直到找到第一个不是8的元素，代码如下：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">18</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">bsearch</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>
<span class="k">while</span><span class="p">(</span><span class="n">index</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">8</span><span class="p">){</span>
	<span class="n">index</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这种方式在有很多重复元素的情况下，效率并不高，比如数据为<code class="highlighter-rouge">{1,8,8,8,8,8,8,8,8,9}</code>。另一种方式是对<code class="highlighter-rouge">mid-1</code>的部分继续进行二分查找，直到找到边界点：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">bsearch</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="p">(</span><span class="n">hi</span><span class="o">-</span><span class="n">lo</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">){</span>
			<span class="c1">//增加判断条件</span>
			<span class="k">if</span><span class="p">(</span><span class="n">mid</span><span class="o">==</span><span class="mi">0</span> <span class="o">||</span> <span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">value</span><span class="p">){</span>
				<span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
			<span class="p">}</span><span class="k">else</span><span class="p">{</span>
				<span class="n">hi</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">){</span>
			<span class="n">lo</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span><span class="k">else</span><span class="p">{</span>
			<span class="n">hi</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这种方式的执行效率显然高于逐个元素遍历的方式，类似的，如果想要找最后一个值等于8的元素，也只需要修改当<code class="highlighter-rouge">a[mid]==target</code>时的判断逻辑</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span> <span class="n">mid</span> <span class="o">==</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">target</span><span class="p">){</span>
		<span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
	<span class="p">}</span><span class="k">else</span><span class="p">{</span>
		<span class="n">lo</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>接下来我们再看剩下两个问题，第三个问题是查找第一个大于等于给定值的元素，注意这里的给定值可以不在序列中，比如，数组中存储的这样一个序列：<code class="highlighter-rouge">3，4，6，7，10</code>。如果查找第一个大于等于<code class="highlighter-rouge">5</code>的元素，那就是<code class="highlighter-rouge">6</code>。这时候由于<code class="highlighter-rouge">5</code>不一定在序列中，因此不能使用<code class="highlighter-rouge">a[mid]==5</code>的条件，而需要将<code class="highlighter-rouge">a[mid]==5</code>和<code class="highlighter-rouge">a[mid]&gt;5</code>结合起来</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">target</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">mid</span><span class="o">==</span><span class="mi">0</span> <span class="o">||</span> <span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">target</span><span class="p">){</span>
		<span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
	<span class="p">}</span><span class="k">else</span><span class="p">{</span>
		<span class="n">hi</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span><span class="k">else</span><span class="p">{</span>
	<span class="n">lo</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>现在我们来看最后一个问题，查找最后一个小于等于给定值的元素。比如，数组中存储了这样一组数据：<code class="highlighter-rouge">3，5，6，8，9，10</code>。最后一个小于等于<code class="highlighter-rouge">7</code>的元素就是<code class="highlighter-rouge">6</code>。其思路和上面是一样的，这里就不展开论述了</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">mid</span><span class="o">==</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">){</span>
		<span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
	<span class="p">}</span><span class="k">else</span><span class="p">{</span>
		<span class="n">lo</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span><span class="k">else</span><span class="p">{</span>
	<span class="n">hi</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这几个例子说明，在实际应用中，二分查找更适合用在“近似”查找上，在这类问题上使用二分法相比使用散列表，二叉树等效果更好。</p>

<h3 id="求解一个正数的平方根">求解一个正数的平方根</h3>

<p>接下来我们看一个二分法的实际应用问题，该问题为求解一个正数的平方根，即实现函数<code class="highlighter-rouge">sqrt(x)</code>。这个题目有两个要求，一是我们不能使用已有的库函数，二是输入的正数包含小数。下面我们来分析下这个问题。</p>

<ol>
  <li>对于任何一个正数，如果它大于<code class="highlighter-rouge">1</code>，其平方根的取值范围为 <code class="highlighter-rouge">1&lt; s &lt; n/2 (n&gt;=1)</code>。其中<code class="highlighter-rouge">s</code>表示平方根，<code class="highlighter-rouge">n</code>表示输入的正数。</li>
  <li>如果它小于或者等于<code class="highlighter-rouge">1</code>，其平方根的取值范围为 <code class="highlighter-rouge">0 &lt; n &lt; s &lt;=1</code></li>
</ol>

<p>综合上面两点，我们可以得出，对于任何大于0<code class="highlighter-rouge">的</code>正数<code class="highlighter-rouge">n</code>，其平方根的取值范围为<code class="highlighter-rouge">0&lt;s&lt;1+n/2 (n&gt;0)</code>。 接下来我们便可以使用二分法寻找平方根，其思路为</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span>
<span class="n">mid</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="p">(</span><span class="n">high</span><span class="o">-</span><span class="n">low</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="k">while</span><span class="p">(</span><span class="n">true</span><span class="p">){</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">mid</span><span class="o">*</span><span class="n">mid</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">==</span><span class="n">n</span><span class="p">){</span>
		<span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
	<span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">){</span>
		<span class="n">high</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
	<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
		<span class="n">low</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>上述算法有一个问题，由于<code class="highlighter-rouge">low</code>和<code class="highlighter-rouge">high</code>的类型均为<code class="highlighter-rouge">double</code>，即<code class="highlighter-rouge">s==n</code>的情况几乎不会成立，因此我们需要对上面的二分法的判断条件做一些修改，修改方法是引入一个阈值<code class="highlighter-rouge">EPSILON</code>，这个阈值的作用是用来检查<code class="highlighter-rouge">s</code>和<code class="highlighter-rouge">n</code>的差值，如果差值小于阈值，则找到了解，否则将继续二分</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">double</span> <span class="n">EPSILON</span> <span class="o">=</span> <span class="mf">0.00001</span><span class="p">;</span>
<span class="kt">double</span> <span class="nf">sqrt</span><span class="p">(</span><span class="kt">double</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">r</span> <span class="o">=</span> <span class="n">num</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span> <span class="n">l</span><span class="o">&lt;</span> <span class="n">r</span><span class="p">){</span>
    <span class="kt">double</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">s</span> <span class="o">=</span> <span class="n">mid</span><span class="o">*</span><span class="n">mid</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">num</span><span class="p">);</span>
	<span class="c1">//二分终止条件</span>
    <span class="k">if</span><span class="p">(</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="n">EPSILON</span><span class="p">){</span>
      <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">){</span>
      <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
      <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>  
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>以<code class="highlighter-rouge">num = 9</code>为例，上述代码执行的过程为:</p>

<p><img class="md-img-center" src="/assets/images/2015/08/bs-1.png" width="60%" /></p>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://www.youtube.com/watch?v=NcZ2cu7gc-A&amp;list=PLnfg8b9vdpLn9exZweTJx44CII1bYczuk">CS106B-Stanford-YouTube</a></li>
  <li><a href="https://www.coursera.org/learn/algorithms-divide-conquer/home/welcome">Algorithms-Stanford-Cousera</a></li>
  <li><a href="https://www.coursera.org/learn/suanfa-jichu">算法基础</a></li>
  <li><a href="https://www.coursera.org/learn/shuju-jiegou-suanfa/home/welcome">算法与数据结构-1-北大-Cousera</a></li>
  <li><a href="https://www.coursera.org/learn/gaoji-shuju-jiegou/home/welcome">算法与数据结构-2-北大-Cousera</a></li>
  <li><a href="https://courses.edx.org/courses/course-v1:TsinghuaX+30240184.1x+3T2017/course/">算法与数据结构-1-清华-EDX</a></li>
  <li><a href="https://courses.edx.org/courses/course-v1:PekingX+04833050X+1T2016/course/">算法与数据结构-2-清华-EDX</a></li>
  <li><a href="https://www.coursera.org/learn/algorithms/home/welcome">算法设计与分析-1-北大-Cousera</a></li>
  <li><a href="https://courses.edx.org/courses/course-v1:PekingX+04833050X+1T2016/course/">算法设计与分析-2-北大-EDX</a></li>
</ul>

<h3 id="更多二分法相关问题">更多二分法相关问题</h3>

<ul>
  <li><a href="https://leetcode.com/problems/sqrtx/description/">Sqrt(x)</a></li>
  <li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/description/">Search in Rotated Sorted Array</a></li>
  <li><a href="https://leetcode.com/problems/search-for-a-range/description/">Search for a Range</a></li>
  <li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/description/">Search in Rotated Sorted Array II</a></li>
  <li><a href="https://leetcode.com/problems/first-bad-version/description/">First Bad Version</a></li>
</ul>

:ET