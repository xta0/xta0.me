I"1<h2 id="广度优先搜索">广度优先搜索</h2>

<p>广度搜索相比深度搜索，只需要知道目标节点位于第几层，便可确定到达的路径数目，可以确保找到最优解，因此通常用于求解层次相关问题（步数问题，路径问题）。广搜在遍历的过程中，通常使用队列存储节点，对每一个节点，可以用一个结构定义：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">node</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">layer</span><span class="p">;</span> <span class="c1">//在第几层的位置</span>
    <span class="kt">bool</span> <span class="n">isVisited</span><span class="p">;</span> <span class="c1">//是否被遍历过</span>
    <span class="n">node</span><span class="o">*</span> <span class="n">parent</span><span class="p">;</span> <span class="c1">//便于路径搜索</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">*</span> <span class="o">&gt;</span><span class="n">children</span><span class="p">;</span> <span class="c1">//该节点所能到到的子节点</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="广搜算法">广搜算法</h3>

<ol>
  <li>将初始节点<code class="highlighter-rouge">s0</code>放入Queue中</li>
  <li>如果Queue为空，则问题无解，失败退出</li>
  <li>从Queue中取出第一个节点，记为<code class="highlighter-rouge">n</code>, 将其状态标记为visit</li>
  <li>考察<code class="highlighter-rouge">n</code>是否为目标节点，若是，则退出</li>
  <li>若<code class="highlighter-rouge">n</code>不是目标节点，则看<code class="highlighter-rouge">n</code>是否有子节点，若没有，则转到第2步</li>
  <li>遍历<code class="highlighter-rouge">n</code>的子节点，如果没有被visit·，则放入Queue中，转到第2步</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">bfs</span><span class="p">{</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
    
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">node</span><span class="p">.</span><span class="n">isVisited</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">value</span><span class="o">==</span><span class="n">K</span><span class="p">){</span> <span class="c1">//找到目标</span>
            <span class="k">return</span><span class="err">；</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">child</span> <span class="o">:</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">child</span><span class="p">.</span><span class="n">isVisited</span><span class="p">){</span>
                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>广度搜索的一个重点是要先构造<strong>状态空间</strong>，即如何从一个状态，生成一棵树，树中的每个节点对应状态空间的一个状态。而状态空间的生成是一个逐层扩展的过程，枚举根节点所能到达的状态构成第二层状态，这些状态可以作为根节点的子节点，依次类推展开完整的空间。</p>

<h3 id="广搜与深搜的比较">广搜与深搜的比较</h3>

<ul>
  <li>广搜一般用于状态表示比较简单、求最优策略的问题
    <ul>
      <li>优点：<strong>是一种完备策略</strong>，即只要问题有解，它就一定可以找到解。并且，广度优先搜索找到的解，<strong>还一定是路径最短的解</strong>。</li>
      <li>缺点：盲目性较大，尤其是当目标节点距初始节点较远时，将产生许多无用的节点，因此其搜索效率较低。需要保存所有扩展出的状态，占用的空间大</li>
    </ul>
  </li>
  <li>深搜几乎可以用于任何问题
    <ul>
      <li>只需要保存从起始状态到当前状态路径上的节点</li>
    </ul>
  </li>
</ul>

<h3 id="双向bfs">双向BFS</h3>

<ul>
  <li>DBFS算法是对BFS算法的一种扩展。
    <ul>
      <li>BFS算法从起始节点以广度优先的顺序不断扩展，直到遇到目的节点</li>
      <li>DBFS算法从两个方向以广度优先的顺序同时扩展，一个是从起始节点开始扩展，另一个是从目的节点扩展，直到一个扩展队列中出现另外一个队列中已经扩展的节点，也就相当于两个扩展方向出现了交点，那么可以认为我们找到了一条路径</li>
    </ul>
  </li>
  <li>比较
    <ul>
      <li>DBFS算法相对于BFS算法来说，由于采用了双向扩展的方式，搜索树的宽度得到了明显的减少，时间复度和空间复杂度上都有提高！</li>
      <li>假设1个节点能扩展出n个节点，单向搜索要m层能找到答案，那么扩展出来的节点数目就是:<code class="highlighter-rouge">(1-n^m)/(1-n)</code></li>
      <li>双向广搜，同样是一共扩展m层，假定两边各扩展出<code class="highlighter-rouge">m/2</code>层，则总节点数目 <code class="highlighter-rouge">2 * (1-n^m/2)/(1-n)</code></li>
      <li>每次扩展节点总是选择节点比较少的那边进行扩展，并不是机械
的两边交替。</li>
    </ul>
  </li>
  <li>实现思路</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">dbfs</span><span class="p">()</span>
<span class="p">{</span>
    <span class="mf">1.</span> <span class="err">将起始节点放入队列</span><span class="n">q0</span><span class="p">,</span><span class="err">将目标节点放入队列</span><span class="n">q1</span><span class="err">；</span>
    <span class="mf">2.</span> <span class="err">当两个队列都未空时，作如下循环：</span>
        <span class="mi">1</span><span class="p">)</span> <span class="err">如果队列</span><span class="n">q0</span><span class="err">里的节点比</span><span class="n">q1</span><span class="err">中的少</span><span class="p">,</span><span class="err">则扩展队列</span><span class="n">q0</span><span class="err">；</span>
        <span class="mi">2</span><span class="p">)</span> <span class="err">否则扩展队列</span><span class="n">q1</span>
    <span class="mf">3.</span> <span class="err">如果队列</span><span class="n">q0</span><span class="err">未空，不断扩展</span><span class="n">q0</span><span class="err">直到为空；</span>
    <span class="mf">4.</span> <span class="err">如果队列</span><span class="n">q1</span><span class="err">未空，不断扩展</span><span class="n">q1</span><span class="err">直到为空；</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">expand</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1">//其中i为队列的编号，0或1</span>
<span class="p">{</span>
    <span class="err">取队列</span><span class="n">qi</span><span class="err">的头节点</span><span class="n">H</span><span class="err">；</span>
    <span class="err">对</span><span class="n">H</span><span class="err">的每一个相邻节点</span><span class="n">adj</span><span class="err">：</span>
    <span class="mi">1</span> <span class="err">如果</span><span class="n">adj</span><span class="err">已经在队列</span><span class="n">qi</span><span class="err">之中出现过，则抛弃</span><span class="n">adj</span><span class="err">；</span>
    <span class="mi">2</span> <span class="err">如果</span><span class="n">adj</span><span class="err">在队列</span><span class="n">qi</span><span class="err">中未出现过，则</span><span class="o">:</span>
    <span class="mi">1</span><span class="err">）</span> <span class="err">将</span><span class="n">adj</span><span class="err">放入队列</span><span class="n">qi</span><span class="err">；</span>
    <span class="mi">2</span><span class="p">)</span> <span class="err">如果</span><span class="n">adj</span> <span class="err">曾在队列</span><span class="n">q1</span><span class="o">-</span><span class="n">i</span><span class="err">中出现过</span><span class="p">,</span> <span class="err">则：输出找到的路径</span>
<span class="p">}</span> 
</code></pre></div></div>

<h3 id="bfs的应用">BFS的应用</h3>

<p>接下来我们看几个BFS应用的例子，我们先来看一个比较经典的问题，<a href="https://leetcode.com/problems/word-ladder/description/">LeetCode 127. Word Ladder</a>，这个题目是说，给定一个起始单词<code class="highlighter-rouge">beginWord</code>和一个终止单词<code class="highlighter-rouge">endWord</code>以及一组字典单词，现在希望让<code class="highlighter-rouge">beginWord</code>经过若干步变换，变成<code class="highlighter-rouge">endWord</code>，变换的规则为</p>

<ol>
  <li>每一步变换只能改变<code class="highlighter-rouge">beginWord</code>中的一个字母</li>
  <li>每一步变换后的单词必须在字典中</li>
</ol>

<p>例如下面这个例子，<code class="highlighter-rouge">hit</code>经过一些列变化后可变为<code class="highlighter-rouge">cog</code></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input:
beginWord <span class="o">=</span> <span class="s2">"hit"</span>,
endWord <span class="o">=</span> <span class="s2">"cog"</span>,
wordList <span class="o">=</span> <span class="o">[</span><span class="s2">"hot"</span>,<span class="s2">"dot"</span>,<span class="s2">"dog"</span>,<span class="s2">"lot"</span>,<span class="s2">"log"</span>,<span class="s2">"cog"</span><span class="o">]</span>

Output: 5

Explanation: As one shortest transformation is <span class="s2">"hit"</span> -&gt; <span class="s2">"hot"</span> -&gt; <span class="s2">"dot"</span> -&gt; <span class="s2">"dog"</span> -&gt; <span class="s2">"cog"</span>,
<span class="k">return </span>its length 5.
</code></pre></div></div>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://www.youtube.com/watch?v=NcZ2cu7gc-A&amp;list=PLnfg8b9vdpLn9exZweTJx44CII1bYczuk">CS106B-Stanford-YouTube</a></li>
  <li><a href="https://www.coursera.org/learn/algorithms-divide-conquer/home/welcome">Algorithms-Stanford-Cousera</a></li>
  <li><a href="https://www.coursera.org/learn/shuju-jiegou-suanfa/home/welcome">算法与数据结构-1-北大-Cousera</a></li>
  <li><a href="https://www.coursera.org/learn/gaoji-shuju-jiegou/home/welcome">算法与数据结构-2-北大-Cousera</a></li>
  <li><a href="https://courses.edx.org/courses/course-v1:TsinghuaX+30240184.1x+3T2017/course/">算法与数据结构-1-清华-EDX</a></li>
  <li><a href="https://courses.edx.org/courses/course-v1:PekingX+04833050X+1T2016/course/">算法与数据结构-2-清华-EDX</a></li>
  <li><a href="https://www.coursera.org/learn/algorithms/home/welcome">算法设计与分析-1-北大-Cousera</a></li>
  <li><a href="https://courses.edx.org/courses/course-v1:PekingX+04833050X+1T2016/course/">算法设计与分析-2-北大-EDX</a></li>
</ul>
:ET