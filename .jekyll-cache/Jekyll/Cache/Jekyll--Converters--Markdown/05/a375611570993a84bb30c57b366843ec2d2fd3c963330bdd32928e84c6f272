I"A<blockquote>
  <p>持续更新，补充C++新增feature,目录结构遵循《C++ Primer》</p>
</blockquote>

<h2 id="lambda-表达式">Lambda 表达式</h2>

<p><mark>C++ 11</mark>引入了一种新的类型称为lambda表达式，一个lambda表达式代表一个可调用的代码单元，可以将其理解为一个匿名的内联函数。Lambda表达式的定义为:</p>

<script type="math/tex; mode=display">[capture \thinspace list] \thinspace (parameter \thinspace list) \enspace \rightarrow \enspace return \thinspace type \enspace \{ \enspace function \thinspace body \enspace  \}</script>

<p>其中$capture \thinspace list$(捕获列表)是一个lambda表达式中定义局部变量的列表(通常为空)。参数列表和返回类型可以忽略，捕获列表必须存在。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[]{</span><span class="k">return</span> <span class="mi">42</span><span class="p">;}</span>
</code></pre></div></div>

<h3 id="捕获列表的规则">捕获列表的规则</h3>

<table>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">[]</code></td>
      <td>不适用任何外部变量</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">[=]</code></td>
      <td>隐式捕获，<code class="highlighter-rouge">=</code>必须放在最前面，以传值的形式使用外部所有变量，<mark>值不可以被修改</mark></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">[&amp;]</code></td>
      <td>隐式捕获，<code class="highlighter-rouge">&amp;</code>必须放在最前面，以引用的形式使用所有外部变量，引用可以修改</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">[x,&amp;y]</code></td>
      <td>x以值传递（拷贝）形式引入， y以引用形式引入</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">[=,&amp;x,&amp;y]</code></td>
      <td>x,y以引用形式使用，其余变量以传值形式引入</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">[&amp;,x,y]</code></td>
      <td>x,y以传值形式引入，其余变量以引用形式使用</td>
    </tr>
  </tbody>
</table>

<p>对于捕获列表，只用于捕获所在函数内的局部变量，对于全局符号，或者static变量，则无需出现在捕获列表,里，例如下面代码中的<code class="highlighter-rouge">cout</code>属于全局符号，不需要捕获：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words</span><span class="p">{</span><span class="s">"C++"</span><span class="p">,</span><span class="s">"Java"</span><span class="p">,</span><span class="s">"Ruby"</span><span class="p">};</span>
<span class="n">for_each</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">){</span>
  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">s</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>
<p>当定义了一个lambda对象时，编译器做了这么几件事：</p>

<ol>
  <li>创建了一个与lambda对应的新类型（未命名，它实际上是一个Functor重载了<code class="highlighter-rouge">()</code>运算符，在运算符重载一节还会分析）。当向一个函数传递lambda时，同时定义了一个新类型和该类型的一个对象</li>
  <li>在生成的新类型中，捕获列表作为该类的数据成员在lambda对象被创建时初始化</li>
  <li>如果使用<code class="highlighter-rouge">auto</code>定义lambda变量时，实际上定义了一个从lambda生成的类型的对象</li>
</ol>

<blockquote>
  <p>尽量保持lambda捕获的变量简单化，避免捕捉指针或者引用。如果捕获了引用，应确保在lambda函数体执行时该引用仍有效。</p>
</blockquote>

<h3 id="mutable-lambda">mutable lambda</h3>

<p>如果一个参数以值捕获的方式被lamda所引用，那么它的值是不能被修改的，如果要求改被捕获的值，需要使用<code class="highlighter-rouge">mutable</code>关键字。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">fcn3</span><span class="p">(){</span>
  <span class="kt">size_t</span> <span class="n">v1</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">//局部变量</span>
  <span class="c1">//f可以改变v1</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">v1</span><span class="p">]()</span><span class="k">mutable</span> <span class="p">{</span> <span class="k">return</span> <span class="o">++</span><span class="n">v1</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">v1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">j</span> <span class="o">=</span> <span class="n">f</span><span class="p">();</span> <span class="c1">//j = 43;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果局部变量是以引用的形式被捕获，则不需使用mutable关键字，能否修改被捕获的变量要看引用的类型，是否是<code class="highlighter-rouge">const</code></p>

<h3 id="bind函数">bind函数</h3>

<p>考虑这样一个问题，标准库中的<code class="highlighter-rouge">find_if</code>函数接受三个参数，前两个是迭代器对象用来确定查找返回，第三个参数是接受一个参数的函数指针，我们可以使用lambda表达式来作为第三个参数：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">find_if</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),[</span><span class="n">sz</span><span class="p">](</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">){</span>
  <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">sz</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>
<p>上个面的lambda表达式实际上是接受了2个参数<code class="highlighter-rouge">s</code>和<code class="highlighter-rouge">sz</code>，<code class="highlighter-rouge">s</code>是<code class="highlighter-rouge">find_if</code>传入lambda表达式的，<code class="highlighter-rouge">sz</code>是由lambda捕获的，函数的作用是比较<code class="highlighter-rouge">s.size()</code>和<code class="highlighter-rouge">sz</code>。这个问题也可以使用函数指针，我们可以定义这样一个函数:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">check_size</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sz</span><span class="p">){</span>
  <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">sz</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这里便出现了一个问题，<code class="highlighter-rouge">check_size</code>接受两个参数，显然不满足<code class="highlighter-rouge">find_if</code>的要求，因此便不能将<code class="highlighter-rouge">check_size</code>当做参数传递给<code class="highlighter-rouge">find_if</code>。</p>

<p>这时我们需要使用<code class="highlighter-rouge">bind</code>对<code class="highlighter-rouge">check_size</code>进行一下包装，<mark>C++ 11</mark>中对<code class="highlighter-rouge">bind</code>的定义为：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>auto newCallable = bind(callable, arg_list);
</code></pre></div></div>

<p>其中<code class="highlighter-rouge">newCallable</code>是一个可调用对象，<code class="highlighter-rouge">arg_list</code>是一个<code class="highlighter-rouge">callable</code>接受的以逗号分隔的参数列表，当调用<code class="highlighter-rouge">newCallable</code>时，<code class="highlighter-rouge">newCallable</code>会调用<code class="highlighter-rouge">callable</code>，并传入<code class="highlighter-rouge">arg_list</code>作为参数。</p>

<p><code class="highlighter-rouge">arg_list</code>中的参数可能包含形如<code class="highlighter-rouge">_n</code>的名字，其中<code class="highlighter-rouge">n</code>是一个自然数，代表“占位符”，例如<code class="highlighter-rouge">_1</code>表示<code class="highlighter-rouge">newCallable</code>的第一个参数，<code class="highlighter-rouge">_2</code>表示第二个参数，以此类推。</p>

<p>接下来我们可以用<code class="highlighter-rouge">bind</code>来包装<code class="highlighter-rouge">check_size</code>来生成一个可以调用<code class="highlighter-rouge">check_size</code>的对象，如下:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">check</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">check_size</span><span class="p">,</span><span class="n">_1</span><span class="p">,</span><span class="mi">6</span><span class="p">);</span>
<span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>
<span class="n">check</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c1">//check(s)会调用check_size(s,6);</span>
</code></pre></div></div>
<p>上述<code class="highlighter-rouge">check</code>函数只接受一个参数<code class="highlighter-rouge">_1</code>,该参数对应<code class="highlighter-rouge">check_size</code>的第一个参数，即<code class="highlighter-rouge">const string&amp;</code>类型，这样就可将其应用于<code class="highlighter-rouge">find_if</code>函数：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span>
<span class="nf">find_if</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">bind</span><span class="p">(</span><span class="n">check_size</span><span class="p">,</span><span class="n">_1</span><span class="p">,</span><span class="n">sz</span><span class="p">));</span>
</code></pre></div></div>
<ul>
  <li><strong>使用placeholder</strong></li>
</ul>

<p>占位符<code class="highlighter-rouge">_n</code>定义在<code class="highlighter-rouge">std::placeholders</code>的命名空间中，使用前要进行<code class="highlighter-rouge">using</code>声明。<code class="highlighter-rouge">_n</code>还可以用来调整函数接受参数的顺序，例如</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>auto g = bind(f,a,b,_2,c,_1);
</code></pre></div></div>
<p>即<code class="highlighter-rouge">g</code>的第二参<code class="highlighter-rouge">_2</code>数对应<code class="highlighter-rouge">f</code>的第三个参数，<code class="highlighter-rouge">g</code>的第一个参数<code class="highlighter-rouge">_1</code>对应<code class="highlighter-rouge">f</code>的最后一个参数，例如:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g(X,Y) //会调用 f(a,b,Y,c,X);
</code></pre></div></div>

<ul>
  <li><strong>绑定引用参数</strong></li>
</ul>

<p>对于<code class="highlighter-rouge">bind</code>的另一个问题是如何绑定引用类型的参数，除占位符以外的参数，默认是值传递，有些情况参数无法拷贝，只能取引用，这时需要使用<code class="highlighter-rouge">ref</code>函数（定义在<code class="highlighter-rouge">functional</code>），<code class="highlighter-rouge">ref</code>返回一个对象，包含给定的引用，此对象是可以拷贝的，类似的还有<code class="highlighter-rouge">cref</code>，生成一个保存<code class="highlighter-rouge">const</code>引用类的对象。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">some_func</span><span class="p">{</span>
  <span class="p">...</span>
  <span class="c1">//os是一个局部变量，引用一个输出流</span>
  <span class="c1">//c是一个局部变量，类型为char</span>
  <span class="c1">//使用lambda表达式来捕获引用类型</span>
  <span class="n">for_each</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),[</span><span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="n">c</span><span class="p">](</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">){</span>
      <span class="n">os</span><span class="o">&lt;&lt;</span><span class="n">s</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">}</span> 
</code></pre></div></div>

<p>对上述代码使用函数进行改写后，使用<code class="highlighter-rouge">bind</code>：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">print</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">){</span>
  <span class="k">return</span> <span class="n">os</span><span class="o">&lt;&lt;</span><span class="n">s</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">some_func</span><span class="p">(){</span>
  <span class="p">...</span>
  <span class="c1">//os是一个局部变量，引用一个输出流</span>
  <span class="c1">//c是一个局部变量，类型为char</span>
  <span class="c1">//使用ref来返回一个引用类型的可拷贝对象</span>
  <span class="n">for_each</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">bind</span><span class="p">(</span><span class="n">print</span><span class="p">,</span><span class="n">ref</span><span class="p">(</span><span class="n">os</span><span class="p">),</span><span class="n">_1</span><span class="p">,</span><span class="n">c</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>STL中的bind1st, bind2nd函数已被废弃</p>
</blockquote>
:ET