I"'<h2 id="一维卡尔曼滤波">一维卡尔曼滤波</h2>

<p>如果理解了前面使用直方图进行Localization的原理，也就大概理解了卡尔曼滤波的原理。这一节我们会继续对上一一篇文章中的例子再进行一些完善，将离散概率分布函数变成连续的概率分布，因为在现实世界中，位置往往是时间的函数，而时间是连续的，因此我们需要用一个连续概率函数对上述场景进行模拟。</p>

<blockquote>
  <p>不论概率分布式是离散还是连续的，其定位的原理是不变的，都是sense和move两个过程的交替更迭。</p>
</blockquote>

<h3 id="高斯函数">高斯函数</h3>

<p>回顾前面介绍Localization的步骤，第一步是需要有一个先验概率，一个连续型的概率密度函数，这个函数可以使用高斯函数来表示，</p>

<script type="math/tex; mode=display">f(x) = \frac{1}{\sqrt{2\pi\sigma^2}} exp ^{-\frac{(x-\mu)^2}{\sigma^2}}</script>

<p>对于高斯函数来说，方差越大，概率分布函数越“胖”，样本偏离均值的幅度越大；相反的，方差越小，样本偏离均值的幅度越小，概率分布函数越“瘦”。如果用高斯函数来描述机器人的位置，我们希望方差越小越好，这样均值位置就越接近机器人的真实位置。</p>

<blockquote>
  <p>更多关于高斯函数的特性请自行查阅文档。</p>
</blockquote>

<h3 id="measurement-update">Measurement Update</h3>

<p>回到定位问题上，假设我们有一个先验的高斯概率密度函数为$f(x)$，其均值和方差分别为<code class="highlighter-rouge">(mu=120, sigma=40)</code>，校验因子的概率密度函数为$g(x)$，其均值和方差分别为<code class="highlighter-rouge">(mu=200,sigma=30)</code>，如下图所示</p>

<p><img class="md-img-center" src="/assets/images/2018/07/ad-gs-1.png" width="70%" /></p>

<p>接下来机器人进行了一个次measure，根据贝叶斯公式，后验概率应该等于$f(x)*g(x)$，得到的结果如下图</p>

<p><img class="md-img-center" src="/assets/images/2018/07/ad-gs-2.png" width="70%" /></p>

<p>从这个结果中，我们能观察出几条重要的结论：</p>

<ol>
  <li>计算后的高斯分布的均值位于<code class="highlighter-rouge">120</code>和<code class="highlighter-rouge">200</code>之间</li>
  <li>方差变的更小，峰值为三者最高，说明measure获取了新的信息，提高了位置预测准确率</li>
</ol>

<p>产生这个结果的原因从直观上不太好理解，实际上可以从数学的角度进行证明，当两个高斯函数相乘后，产生的新的均值为</p>

<script type="math/tex; mode=display">\mu = \frac{\sigma^{-2}_1\mu_1 + \sigma^{-2}_2\mu_2}{\sigma^{-2}_1 + \sigma^{-2}_2}</script>

<p>由于$\mu_2 &gt; \mu_1$，很直观的有 $\mu_1&lt;\mu&lt;\mu_2$。相应的，产生的新的方差为</p>

<script type="math/tex; mode=display">\sigma^2 = \frac{\sigma^2_1\sigma^2_2}{\sigma^2_1+\sigma^2_2}</script>

<p>这个看起来没有那么直观，我们不妨代入几个数试试，令$\sigma^2_1 = \sigma^2_2 = 4$，$\sigma=2$的值为2；令$\sigma^2_1 = 8$,$\sigma^2_2 = 2$，$\sigma=1.6$，以此类推。</p>

<p>measure过程的Python代码如下：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">measure</span><span class="p">(</span><span class="n">mean1</span><span class="p">,</span> <span class="n">var1</span><span class="p">,</span> <span class="n">mean2</span><span class="p">,</span> <span class="n">var2</span><span class="p">):</span>
    <span class="n">new_mean</span> <span class="o">=</span> <span class="p">(</span><span class="n">var2</span> <span class="o">*</span> <span class="n">mean1</span> <span class="o">+</span> <span class="n">var1</span> <span class="o">*</span> <span class="n">mean2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">var1</span> <span class="o">+</span> <span class="n">var2</span><span class="p">)</span>
    <span class="n">new_var</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">var1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">var2</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">new_mean</span><span class="p">,</span> <span class="n">new_var</span><span class="p">)</span>
</code></pre></div></div>
<p>为了简化计算，上述代码只返回了均值和方差，如果要计算对于高斯函数，将其带入即可</p>

<h3 id="motion-update">Motion Update</h3>

<p>sense完之后就可以开始move了，move是一个损失信息的过程，为了量化损失的信息，我们引入一个损失概率密度函数，该函数也服从高斯分布，我们用<code class="highlighter-rouge">(u,r)</code>表示，其中<code class="highlighter-rouge">u</code>是均值，<code class="highlighter-rouge">r</code>是方差。为了计算损耗后的概率分布，我们只需要让当前的概率密度函数和损失概率密度函数“求和”即可：</p>

<script type="math/tex; mode=display">\mu' = \mu + u \\
\sigma'^2 = \sigma^2 + r^2\\</script>

<p>因此我们可以写出move的代码:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">mean1</span><span class="p">,</span> <span class="n">var1</span><span class="p">,</span> <span class="n">mean2</span><span class="p">,</span> <span class="n">var2</span><span class="p">):</span>
    <span class="n">new_mean</span> <span class="o">=</span> <span class="n">mean1</span> <span class="o">+</span> <span class="n">mean2</span>
    <span class="n">new_var</span> <span class="o">=</span> <span class="n">var1</span> <span class="o">+</span> <span class="n">var2</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">new_mean</span><span class="p">,</span> <span class="n">new_var</span><span class="p">)</span> 
</code></pre></div></div>

<h3 id="sense--move">sense &amp; move</h3>

<p>将生面的sense和move结合起来，我们就得到了<mark>一维卡尔曼滤波</mark>的完整过程:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">Kalman.predict</span> <span class="kn">import</span> <span class="n">predict</span>
<span class="kn">from</span> <span class="nn">Kalman.measure</span> <span class="kn">import</span> <span class="n">measure</span>

<span class="c1">##先验概率
</span><span class="n">mu</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">sig</span> <span class="o">=</span> <span class="mi">1000</span>

<span class="c1">##矫正因子
</span><span class="n">measurements</span> <span class="o">=</span> <span class="p">[</span><span class="mf">5.0</span><span class="p">,</span><span class="mf">6.0</span><span class="p">,</span><span class="mf">7.0</span><span class="p">,</span><span class="mf">9.0</span><span class="p">,</span><span class="mf">10.0</span><span class="p">]</span>
<span class="n">measurement_sig</span> <span class="o">=</span> <span class="mf">4.0</span>

<span class="c1">##损耗因子
</span><span class="n">motion</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">]</span>
<span class="n">motion_sig</span> <span class="o">=</span> <span class="mf">2.0</span>

<span class="c1">## sense and move
</span><span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">measurements</span><span class="p">)):</span>
    <span class="c1">#sense
</span>    <span class="p">(</span><span class="n">mu</span><span class="p">,</span><span class="n">sig</span><span class="p">)</span> <span class="o">=</span> <span class="n">measure</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span><span class="n">sig</span><span class="p">,</span> <span class="n">measurements</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="n">measurement_sig</span><span class="p">)</span>
    <span class="c1">#move
</span>    <span class="p">(</span><span class="n">mu</span><span class="p">,</span><span class="n">sig</span><span class="p">)</span> <span class="o">=</span> <span class="n">predict</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span><span class="n">sig</span><span class="p">,</span> <span class="n">motion</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="n">motion_sig</span><span class="p">)</span>
</code></pre></div></div>
<p>上述代码逻辑和前面离散demo基本一致，不同的是概率密度函数变成了连续的高斯函数，这里就不再做过多的分析。下图为移动5次后的概率分布结果</p>

<p><img class="md-img-center" src="/assets/images/2018/07/ad-gs-sm-1.png" width="70%" /></p>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://www.udacity.com/course/intro-to-self-driving-cars--nd113">Udacity Intro to Self-Driving Car</a></li>
  <li><a href="https://www.youtube.com/playlist?list=PLX2gX-ftPVXU3oUFNATxGXY90AULiqnWT">The Kalman Filter</a></li>
  <li><a href="https://www.youtube.com/watch?v=mwn8xhgNpFY&amp;list=PLn8PRpmsu08pzi6EMiYnR-076Mh-q3tWr">Understand Kalman Filter</a></li>
</ul>
:ET