I"O!<h2 id="agenda">Agenda</h2>

<ul>
  <li>Data structures
    <ul>
      <li>Packing and encoding</li>
      <li>Augmentation</li>
      <li>Precomputation</li>
      <li>Compile-time initialization</li>
      <li>Caching</li>
      <li>Lazy evaluation</li>
      <li>Sparsity</li>
    </ul>
  </li>
  <li>Loops
    <ul>
      <li>Hoisting</li>
      <li>Sentinels</li>
      <li>Loop unrolling</li>
      <li>Loop fusion</li>
      <li>Eliminating wasted iterations</li>
    </ul>
  </li>
  <li>Logic
    <ul>
      <li>Constant folding and propagation</li>
      <li>Common-subexpression elimination</li>
      <li>Algebraic identities</li>
      <li>Short-circuiting</li>
      <li>Ordering tests</li>
      <li>Creating a fast path</li>
      <li>Combining tests</li>
    </ul>
  </li>
  <li>Functions
    <ul>
      <li>Inlining</li>
      <li>Tail-recursion elimination</li>
      <li>Coarsening recursion</li>
    </ul>
  </li>
</ul>

<h2 id="data-structures">Data Structures</h2>

<h3 id="packing-and-encoding">Packing and Encoding</h3>

<p>The idea of <strong>packing</strong> is to store more than one data value in a machine word. The related idea of <strong>encoding</strong> is to convert data values into a representation requiring fewer bits.</p>

<h3 id="augmentation">Augmentation</h3>

<p>The idea of data-structure augmentation is to add information to a data structure to make common operations do less work.</p>

<p>Example: Appending singly linked lists</p>

<ul>
  <li>Appending one list to another requires walking the length of the first list to set its null pointer to the start of the second.</li>
  <li>AUgmenting the list with a tail pointer allows appending to operate in a constant time.</li>
</ul>

<h3 id="precomputation">Precomputation</h3>

<p>The idea of <strong>precomputation</strong> is to perform calculations in advance so as to avoid doing them at “mission-critical” times.</p>

<h3 id="compile-time-initialization">Compile-time initialization</h3>

<p>The idea of <strong>compile-time initalization</strong> is to store the values of constants during compilation, saving work at execution time.</p>

<p>Idea: Create large static tables by metaprogramming.</p>

<h3 id="sparsity">Sparsity</h3>

<p>THe idea of exploting <strong>sparsity</strong> is to avoid storing and computing on zeros. “The fastest way to compute is not to compute at all”.</p>

<p>// TODO: add examples</p>

<h2 id="logic">Logic</h2>

<h3 id="constant-folding-and-propagation">Constant Folding and Propagation</h3>

<p>The idea of constant folding and propagation is to evaluate constant expressions and substitue the result into further expressions, all during compilation.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">orrery</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">doube</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">double</span> <span class="n">z</span> <span class="o">=</span> <span class="n">M_PI</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>With a sufficiently high optimization level, all the expressions are evaluated at compile-time.</p>

<h3 id="common-subexpression-elimination">Common-Subexpression Elimination</h3>

<p>The idea of <strong>common-subexpression elimination</strong> is to avoid computing the same expression multiple times by evaluating the expression once and storing the result for later use.</p>

<h3 id="algebraic-identities">Algebraic Identities</h3>

<p>The idea of <strong>exploiting algebraic identities</strong> is to preplace expensive algebraic expressions with algebraic equivalents that require less work.</p>

<h3 id="short-circuiting">Short-Circuiting</h3>

<p>WHen performing a series of tests, the idea of <strong>short-circuiting</strong> is to stop evaluating as soon as you know the answer.</p>

<h3 id="ordering-tests">Ordering Tests</h3>

<p>Consider code that executes a sequence of logical tests. The idea of <strong>odering tests</strong> is to perform those that are more often “successful” - a particular alternative is selected by the test - before tests that are rarely sucessful. Similarly, inexpensive tests should precede expensive ones.</p>

<div class="highlight md-flex-h md-margin-bottom-24">
<div>
<pre class="highlight language-javascript md-no-padding-v md-height-full">
<code class="language-c">
#include <stdbool.h>

bool is_whitespace(char c) {
  if (c == '\r' || c == '\t' || c == ' ' || c == '\n') {
    return true;
  }
  return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/div&gt;

<div class="md-margin-left-12">
<pre class="highlight language-python md-no-padding-v md-height-full">
<code class="language-c">
#include <stdbool.h>

bool is_whitespace(char c) {
  if (c == ' ' || c == '\n' || c == '\t' || c == '\r') {
    return true;
  }
  return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;

## Loops

### Hoisting 

The goal of **hoisting** - also called **loop-invariant code motion** - is to avoid recomputing loop-invariant code each time through the body of a loop.


<div class="highlight md-flex-h md-margin-bottom-24">
<div>
<pre class="highlight language-javascript md-no-padding-v md-height-full">
<code class="language-c">
#include <math.h>

void scale(double* X, double* Y, int N) {
  for (int i=0; i&lt;N; i++) {
    Y[i] = X[i] * exp(sqrt(M_PI/2));
  }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;/div&gt;
<div class="md-margin-left-12">
<pre class="highlight language-python md-no-padding-v md-height-full">
<code class="language-c">
#include <math.h>

void scale(double* X, double* Y, int N) {
  double factor = exp(sqrt(M_PI/2));
  for (int i=0; i&lt;N; i++) {
    Y[i] = X[i] * factor;
  }
}

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

### Loop Unrolling

**Loop unrolling** attempts to save work by combining several consecutive iterations of a loop into a single iteration, thereby reducing the total number of iterations of the loop and, consequently, the number of times that the instructions that control the loop must be executed.

- **Full** loop unrolling - All iterations are unrolled.
- **Partial** loop unrolling - Several, but not all, of the iterations are unrolled.

```cpp
int sum = 0;
for(int i=0; i&lt;n; ++i) {
  sum += A[i];
}

// partial loop unrolling
int sum = 0;
int j;
for (j=0; j&lt;n-3; ++j) {
  sum += A[j];
  sum += A[j+1];
  sum += A[j+2];
  sum += A[j+3];
}
for(int i=j; i&lt;n; ++i){
  sum += A[i];
}
```

Benefits of loop unrolling
- Lower number of instructions in loop control code
- Enable more compiler optimizations

Unrolling too much can cause poor use of instruction cache

## Functions

### Inlining

The idea of **inlining** is to avoid the overhead of a function call by replacing a call to the function with the body of the function itself.

```c
double square(doube x) {
    return x*x;
}

double sum_of_squares(double* A, int n) {
    double sum = 0.0f;
    for (int i=0; i&lt;n; ++i){
        sum += square(A[i]);
    }
    return sum;
}
```

We can inline the `square` function to reduce the overhead (stack expend). To do that, we can simply mark fucntion using `static inline` keywords. It turns out for some modern compilers, the functions can be inlined without declaring "static inline".

Inline functions can be just as effcient as macros, and they are better structured.

## Closing Advice

- Avoid premature optimizations. First get correct working code. Then optimize, preserving correctness by regression testing.
- Reducing the work of a program does not necessarily decrease its running time, but it is a good heuristic.
- The compiler automates many low-level optimizations
- To tell if the compiler is acutally performing a particular optimization, look at the assembly code.


## Resources

- [Course Link](https://www.youtube.com/watch?v=H-1-X9bkop8&amp;list=PLUl4u3cNGP63VIBQVWguXxZZi0566y7Wf)
</math.h></code></pre></div></math.h></code></pre></div></div></stdbool.h></code></pre></div></stdbool.h></code></pre></div></div>
:ET