I"ר<h2 id="building-objects">Building Objects</h2>

<h3 id="object-literal">Object Literal</h3>

<p>JS中构造Object的方式有很多种，比如使用Object Literal</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">firstname</span><span class="p">:</span> <span class="dl">"</span><span class="s2">John</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">lastname</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Doe</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">greet</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">firstname</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">lastname</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">greet</span><span class="p">();</span>
</code></pre></div></div>

<p>Object Literal这种方式很直观，也很有表现力，并且它限制了<code class="highlighter-rouge">this</code>的scope。</p>

<h3 id="使用new">使用<code class="highlighter-rouge">new</code></h3>

<p>除了使用这种方式以外，也可以使用所谓的”构造函数”来创建一个对象，通常所说的造函数是指定义在某个类中用于完成对象初始化的函数，由于JavaScript没有类的概念，因此使用了一种特殊的函数来模拟构造函数</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">firstname</span><span class="p">,</span> <span class="nx">lastname</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">firstname</span> <span class="o">=</span> <span class="nx">firstname</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">lastname</span> <span class="o">=</span> <span class="nx">lastname</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">john</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">John</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">Doe</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<p>可以看到，对于<code class="highlighter-rouge">Person</code>和普通函数有几个不同的地方，分别是:</p>

<ol>
  <li>它的第一个字母是大写的，这个规则在JavaScript中表明它是一个”构造函数”</li>
  <li>在它调用语句前面加上了一个关键字<code class="highlighter-rouge">new</code></li>
  <li>函数内部没有<code class="highlighter-rouge">return</code>语句，但是它却有返回值。</li>
</ol>

<p>显然这其中<code class="highlighter-rouge">new</code>起到了关键作用，如果去掉<code class="highlighter-rouge">new</code>，上述代码变为</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">firstname</span><span class="p">,</span> <span class="nx">lastname</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">firstname</span> <span class="o">=</span> <span class="nx">firstname</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">lastname</span> <span class="o">=</span> <span class="nx">lastname</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">john</span> <span class="o">=</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">John</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">Doe</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>
<p>这时，由于<code class="highlighter-rouge">Person</code>没有返回值，因此<code class="highlighter-rouge">john</code>为<code class="highlighter-rouge">undefined</code>，而此时<code class="highlighter-rouge">Person</code>为全局函数，里面的<code class="highlighter-rouge">this</code>指向了<code class="highlighter-rouge">window</code>。因此如果不使用<code class="highlighter-rouge">new</code>，那么<code class="highlighter-rouge">Person</code>就变成了一个普通函数。实际上，编译器在执行<code class="highlighter-rouge">new</code>的时候，改变了<code class="highlighter-rouge">Person</code>函数的执行逻辑，其过程如下：</p>

<ol>
  <li>创建一个空<code class="highlighter-rouge">object</code></li>
  <li>创建<code class="highlighter-rouge">this</code>指向这个空<code class="highlighter-rouge">object</code></li>
  <li>在构造函数最后增加一行<code class="highlighter-rouge">return this</code></li>
  <li>绑定<code class="highlighter-rouge">this.__proto__</code>为<code class="highlighter-rouge">obejct.prototype</code></li>
</ol>

<p>这里要注意的是，对于<code class="highlighter-rouge">Person</code>，它是一个”构造函数”对象，由前一篇文章可知，它拥有一个<code class="highlighter-rouge">prototype</code>成员，对于一个函数来说，只有它是”构造函数“时，这个<code class="highlighter-rouge">prototype</code>对象才有意义。</p>

<h3 id="使用objectcreate">使用<code class="highlighter-rouge">Object.create</code></h3>

<p>另一种创建Object的方法是使用<code class="highlighter-rouge">Object.create(obj)</code>，这种方法是将<code class="highlighter-rouge">obj</code>作为Prototype来构造新的对象</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">firstname</span><span class="p">:</span> <span class="dl">""</span><span class="p">,</span>
    <span class="na">lastname</span><span class="p">:</span> <span class="dl">""</span><span class="p">,</span>
    <span class="na">greet</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">firstname</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">lastname</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">john</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
<span class="nx">john</span><span class="p">.</span><span class="nx">firstname</span><span class="o">=</span><span class="dl">"</span><span class="s2">John</span><span class="dl">"</span>
<span class="nx">john</span><span class="p">.</span><span class="nx">lastname</span><span class="o">=</span><span class="dl">"</span><span class="s2">Doe</span><span class="dl">"</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">john</span><span class="p">.</span><span class="nx">greet</span><span class="p">())</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">john</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">==</span> <span class="nx">person</span><span class="p">)</span> <span class="c1">//true</span>
</code></pre></div></div>

<p>上述例子中<code class="highlighter-rouge">john</code>的Prototype对象为<code class="highlighter-rouge">person</code>，因此它也具有<code class="highlighter-rouge">person</code>的一系列属性。由于<code class="highlighter-rouge">prototype</code>仅仅是个Object，因此<code class="highlighter-rouge">john</code>同样也可以作为Prototype来继续构造其它对象</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">jane</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">john</span><span class="p">);</span>
<span class="nx">jane</span><span class="p">.</span><span class="nx">firstname</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Jane</span><span class="dl">"</span>
<span class="nx">jane</span><span class="p">.</span><span class="nx">lastname</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Doe</span><span class="dl">"</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">jane</span><span class="p">.</span><span class="nx">greet</span><span class="p">());</span> <span class="c1">//Jane Doe</span>
</code></pre></div></div>

<p>使用<code class="highlighter-rouge">Object.create</code>可以避免<code class="highlighter-rouge">new</code>带来的一些问题，实际上使用<code class="highlighter-rouge">new</code>并不是一个很好的方式，如果忘记写<code class="highlighter-rouge">new</code>，那么程序在编译时不会报错，运行时也不会报错，这是极为危险的，不仅会造成隐蔽的bug，还污染了全局变量。</p>

<p>如果浏览器不支持<code class="highlighter-rouge">Object.create</code>这时需要用到一个概念叫做<strong>Pollyfill</strong>，所谓”Pollyfill”是指如果用到的API浏览器不支持，我们需要自己实现这个API</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">){</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">o</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Object.create implementation</span><span class="dl">'</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> only accepts the first parameter. </span><span class="dl">'</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="kd">function</span> <span class="nx">F</span><span class="p">(){}</span>
        <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">o</span><span class="p">;</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">F</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="prototype">Prototype</h3>

<p>有了上面的铺垫，我们接着来理解Prototype，如果想要给上面的<code class="highlighter-rouge">Person</code>函数对象增加一个成员<code class="highlighter-rouge">greet</code>的方法，又不想修改<code class="highlighter-rouge">Person</code>函数，则需要使用Prototype</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">greet</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">firstname</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">lastname</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">john</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">John</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">Doe</span><span class="dl">"</span><span class="p">)</span>
<span class="nx">john</span><span class="p">.</span><span class="nx">greet</span><span class="p">();</span>
</code></pre></div></div>
<p>上面已经知道<code class="highlighter-rouge">prototype</code>的类型是<code class="highlighter-rouge">object</code>，而且每个函数对象数有一个成员叫做<code class="highlighter-rouge">prototype</code>，让人困惑的是这个<code class="highlighter-rouge">prototype</code>对象不仅可以被Person使用，还可以被其它类使用:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Animal</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//set prototype to Animal</span>
<span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Animal</span><span class="p">(</span><span class="dl">"</span><span class="s2">Pluto</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">dog</span><span class="p">.</span><span class="nx">greet</span><span class="p">();</span> <span class="c1">//Hello undefined undefined</span>
</code></pre></div></div>
<p>将<code class="highlighter-rouge">Person</code>的<code class="highlighter-rouge">prototype</code>赋给了<code class="highlighter-rouge">Animal</code>，则<code class="highlighter-rouge">dog</code>可以调用<code class="highlighter-rouge">greet()</code>方法，由于<code class="highlighter-rouge">dog</code>并没有<code class="highlighter-rouge">firstname</code>和<code class="highlighter-rouge">lastname</code>，因此输出<code class="highlighter-rouge">undefined</code>。</p>

<p>Prototype设计的初衷是为了代码复用，通过让多个类共享Prototype来实现对公共API的抽象。对于不同的对象，如果他们share了同一个Prototype中的API，那么可以认为它们有共同的”父类”。但是这种机制看起来更像是<code class="highlighter-rouge">Interface</code>或者<code class="highlighter-rouge">Protocol</code>，而非继承。对于上面<code class="highlighter-rouge">dog</code>和<code class="highlighter-rouge">john</code>的例子，<code class="highlighter-rouge">Person</code>和<code class="highlighter-rouge">Animal</code>的关系是并列的，我们用<code class="highlighter-rouge">Prototype</code>使<code class="highlighter-rouge">dog</code>和<code class="highlighter-rouge">john</code>都具有了<code class="highlighter-rouge">greet</code>方法，因此这种结构更像是<code class="highlighter-rouge">dog</code>和<code class="highlighter-rouge">john</code>共享了某种Interface。</p>

<p><img class="md-img-center" src="/assets/images/2015/10/js-3.png" /></p>

<h3 id="inheritance">Inheritance</h3>

<p>如果要模拟继承，我们可以换一个例子：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">firstname</span><span class="p">,</span> <span class="nx">lastname</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">firstname</span> <span class="o">=</span> <span class="nx">firstname</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">lastname</span> <span class="o">=</span> <span class="nx">lastname</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">greet</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="dl">"</span><span class="s2">Hello </span><span class="dl">"</span>  <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">firstname</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">lastname</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">Policemen</span><span class="p">(</span><span class="nx">number</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">number</span> <span class="o">=</span> <span class="nx">number</span>
<span class="p">}</span>
<span class="nx">Policemen</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">John</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">Doe</span><span class="dl">"</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">john</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Policemen</span><span class="p">(</span><span class="dl">"</span><span class="s2">1234</span><span class="dl">"</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">john</span><span class="p">.</span><span class="nx">number</span><span class="p">)</span> <span class="c1">//1234</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">john</span><span class="p">.</span><span class="nx">greet</span><span class="p">())</span> <span class="c1">//Hello John Doe</span>
</code></pre></div></div>
<p>这种写法和之前其实并无本质区别，都是改变<code class="highlighter-rouge">Person.prototype</code>，但这种写法更像是继承关系，当<code class="highlighter-rouge">join</code>调用<code class="highlighter-rouge">greet</code>之后，会现在<code class="highlighter-rouge">Person</code>中寻找，发现没有，然后在<code class="highlighter-rouge">Person.prototype</code>中寻找。而<code class="highlighter-rouge">Person.prototype</code>指向<code class="highlighter-rouge">Parent</code>，感觉上像是在<code class="highlighter-rouge">Person</code>的”父类“中寻找。因此这种写法相当于通过<code class="highlighter-rouge">prototype</code>对象将两个对象链接起来了，如下图所示</p>

<p><img class="md-img-center" src="/assets/images/2015/10/js-1.png" /></p>

<p>JavaScript称这种方式的调用为<strong>Prototype Chain</strong>。当object调用一个方法，首先在自己的构造函数对象中寻找，找不到则在<code class="highlighter-rouge">__proto__</code>中寻找，这个<code class="highlighter-rouge">__proto__</code>对象也有自己的<code class="highlighter-rouge">__proto__</code>会一直向上找，直到<code class="highlighter-rouge">__proto__</code>对象为空，例如<code class="highlighter-rouge">Array</code>的<code class="highlighter-rouge">hasOwnProperty</code>方法：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">()</span>
<span class="nx">arr</span><span class="p">.</span> <span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">length</span><span class="dl">'</span><span class="p">)</span> <span class="c1">//true</span>
<span class="c1">//hasOwnProperty这个方法定义在 Array.__proto__.__proto__中</span>
</code></pre></div></div>
<p>回到上面的例子，虽然找到了类似”继承”的感觉，但是上代码不够优雅，甚至是有些丑陋，且模式无法复用，我们接下来可以想一些办法让上面代码稍微优雅一点,并且可以让”继承”的模式可以被复用起来，首先我们先写个Module：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//util.js</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">inheritate</span> <span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">Child</span><span class="p">,</span><span class="nx">Parent</span><span class="p">){</span>
        <span class="nx">Child</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">parent</span><span class="p">).</span><span class="nx">prototype</span>
        <span class="nx">Child</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">=</span> <span class="nx">Child</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>显然，这个Module的作用是将”继承”这个动作抽象出来，但是仅有这个函数是不够的，它只能让<code class="highlighter-rouge">Child</code>继承<code class="highlighter-rouge">Parent</code>在<code class="highlighter-rouge">prototype</code>上的API，而定义在<code class="highlighter-rouge">Parent</code>内部的方法或者属性则无法被集成，因此我们还需要将<code class="highlighter-rouge">this</code>指针进行关联：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//app.js</span>
<span class="kd">var</span> <span class="nx">util</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./util</span><span class="dl">'</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">Person</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./Person</span><span class="dl">'</span><span class="p">)</span>

<span class="nx">util</span><span class="p">.</span><span class="nx">inheritate</span><span class="p">(</span><span class="nx">Policemen</span><span class="p">,</span><span class="nx">Person</span><span class="p">);</span> <span class="c1">//Policement是”基类“，Person是”父类“</span>
<span class="kd">function</span> <span class="nx">Policemen</span><span class="p">(</span><span class="nx">firstname</span><span class="p">,</span><span class="nx">lastname</span><span class="p">,</span><span class="nx">number</span><span class="p">){</span> <span class="c1">//需要传入”父类“需要的参数</span>
    <span class="c1">//调用"父类"构造函数</span>
    <span class="nx">Person</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,[</span><span class="nx">firstname</span><span class="p">,</span><span class="nx">lastname</span><span class="p">])</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">number</span> <span class="o">=</span> <span class="nx">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">john</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Policemen</span><span class="p">(</span><span class="dl">"</span><span class="s2">John</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">Doe</span><span class="dl">"</span><span class="p">,</span><span class="mi">1234</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">john</span><span class="p">.</span><span class="nx">number</span><span class="p">)</span> <span class="c1">//1234</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">john</span><span class="p">.</span><span class="nx">greet</span><span class="p">())</span> <span class="c1">//Hello John Doe</span>
</code></pre></div></div>

<p>上述代码在可读性上有了很大的提高，并且<code class="highlighter-rouge">Policemen</code>函数看起来有了点真正的构造函数的味道。但是上面的代码仍不够完美，比如当<code class="highlighter-rouge">Policement</code>的构造参数多了，<code class="highlighter-rouge">Policemen</code>自身也要修改，将这些参数透传给”父类“，这显然不利于程序扩展，因此，可以对上述代码再进行一次修改</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Policemen</span><span class="p">(</span><span class="nx">options</span><span class="p">){</span> <span class="c1">//需要传入”父类“需要的参数</span>
    <span class="c1">//调用"父类"构造函数</span>
    <span class="nx">Person</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="nx">options</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">number</span> <span class="o">=</span> <span class="nx">option</span><span class="p">.</span><span class="nx">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">john</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Policemen</span><span class="p">({</span><span class="na">firstname</span><span class="p">:</span> <span class="dl">"</span><span class="s2">John</span><span class="dl">"</span><span class="p">,</span> <span class="na">lastname</span><span class="p">:</span><span class="dl">"</span><span class="s2">Doe</span><span class="dl">"</span><span class="p">,</span> <span class="na">number</span><span class="p">:</span><span class="mi">1234</span><span class="p">})</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">john</span><span class="p">.</span><span class="nx">number</span><span class="p">)</span> <span class="c1">//1234</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">john</span><span class="p">.</span><span class="nx">greet</span><span class="p">())</span> <span class="c1">//Hello John Doe</span>
</code></pre></div></div>

<h3 id="overload-pitfalls">Overload Pitfalls</h3>

<p>还是上面的例子，我们可以为<code class="highlighter-rouge">Person</code>定义两个参数类型不同的<code class="highlighter-rouge">greet</code>函数，</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">firstname</span><span class="p">,</span> <span class="nx">lastname</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">firstname</span> <span class="o">=</span> <span class="nx">firstname</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">lastname</span> <span class="o">=</span> <span class="nx">lastname</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">greet</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello </span><span class="dl">'</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">firstname</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">lastname</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">greet</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">msg</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">john</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">John</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">Doe</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">john</span><span class="p">.</span><span class="nx">greet</span><span class="p">();</span> <span class="c1">//undefined</span>
<span class="nx">john</span><span class="p">.</span><span class="nx">greet</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello</span><span class="dl">"</span><span class="p">);</span>  <span class="c1">//Hello</span>
</code></pre></div></div>

<p>按照其它语言的经验，两个<code class="highlighter-rouge">greet</code>的函数签名不同，应该会各自调用不同版本的函数，而在JS中，第二个<code class="highlighter-rouge">greet</code>函数则会覆盖第一个函数。这点要格外注意，解决办法是定义不同名称的函数。</p>

<h3 id="reflection">Reflection</h3>

<p>JavaScript的设计如此灵活，自然少不了强大的反射能力，这种动态语言所具备的优良特性对于静态语言来说简直是梦寐以求的神器，但是也会带来一定的安全问题，这里就不展开讨论了。这一节我们来试验一下JavaScript中关于反射相关的API</p>

<p>继续上面的例子，在JS中我们可以很容易反射出<code class="highlighter-rouge">john</code>的所有成员</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">firstname</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Default</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">lastname</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Default</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">getFullName</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="kd">var</span> <span class="nx">fullname</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">firstname</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">lastname</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">fullname</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">john</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">firstname</span><span class="p">:</span> <span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">lastname</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Doe</span><span class="dl">'</span><span class="p">,</span>
<span class="p">}</span>

<span class="nx">john</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">person</span>
<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">john</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="o">+</span><span class="dl">"</span><span class="s2">: </span><span class="dl">"</span><span class="o">+</span><span class="nx">john</span><span class="p">[</span><span class="nx">key</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div></div>
<p>由于<code class="highlighter-rouge">john</code>的<code class="highlighter-rouge">__proto__</code>指向<code class="highlighter-rouge">person</code>，上述代码会打印出<code class="highlighter-rouge">john</code>所有属性，连同其在<code class="highlighter-rouge">__proto__</code>上的方法：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>firstname: John
lastname: Doe
getFullName: function (){
    var fullname = this.firstname + ' ' + this.lastname;
    return fullname;
}
</code></pre></div></div>
<p>如果只想输出自己的属性，需要使用<code class="highlighter-rouge">hasOwnProperty</code></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">john</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">john</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">prop</span><span class="p">)){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="o">+</span><span class="dl">"</span><span class="s2">: </span><span class="dl">"</span><span class="o">+</span><span class="nx">john</span><span class="p">[</span><span class="nx">key</span><span class="p">])</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//firstname: John</span>
<span class="c1">//lastname: Doe</span>
</code></pre></div></div>

<p>同样，可以单独反射其<code class="highlighter-rouge">__proto__</code>的成员</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">john</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">john</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">prop</span><span class="p">)){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="o">+</span><span class="dl">"</span><span class="s2">: </span><span class="dl">"</span><span class="o">+</span><span class="nx">john</span><span class="p">[</span><span class="nx">key</span><span class="p">])</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*
firstname: Default
lastname: Default
getFullName: function (){
    var fullname = this.firstname + ' ' + this.lastname;
    return fullname;
}
*/</span>
</code></pre></div></div>

<p>反射的另一个用处是做运行时的类型检查，在JavaScript中使用<code class="highlighter-rouge">typeof</code>查看对象的类型</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello</span><span class="dl">"</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">a</span><span class="p">)</span> <span class="c1">//string</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">{}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">b</span><span class="p">)</span> <span class="c1">//object</span>
<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="p">[]</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">c</span><span class="p">)</span> <span class="c1">//object</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span> <span class="c1">//[Object Array]</span>
</code></pre></div></div>

<p>最后我们可以用<code class="highlighter-rouge">Object</code>上的一些API来实现“merge”两个Object</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Jason</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">greet</span><span class="p">:</span> <span class="nx">msg</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">msg</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="kd">const</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="p">{};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">obj1</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">name</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span> <span class="c1">//name, greet</span>
  <span class="kd">const</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">obj1</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">obj2</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj2</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="nx">obj2</span><span class="p">.</span><span class="nx">greet</span><span class="p">(</span><span class="dl">'</span><span class="s1">msg</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="resource">Resource</h3>

<ul>
  <li><a href="https://7chan.org/pr/src/OReilly_JavaScript_The_Good_Parts_May_2008.pdf">JavaScripts: The Good Part</a></li>
  <li><a href="ttps://www.udemy.com/understand-javascript">JavaScripts: Understanding the wierd parts</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">Strict Mode Reference</a></li>
</ul>
:ET