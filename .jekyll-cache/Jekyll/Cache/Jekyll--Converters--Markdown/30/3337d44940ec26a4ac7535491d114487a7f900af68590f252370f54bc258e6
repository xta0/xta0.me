I"Ho<h3 id="mutable--immutable">Mutable &amp; Immutable</h3>

<p>Python是一门动态类型语言，变量的类型依赖解释器的类型推导，可以通过关键字<code class="highlighter-rouge">type</code>来查看变量类型</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="o">=</span><span class="mi">10</span>
<span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1">#&lt;class 'int'&gt;
</span></code></pre></div></div>

<p>需要注意的是，<code class="highlighter-rouge">int</code>并不是<code class="highlighter-rouge">a</code>的类型，而是其所指向内存数据的类型，<code class="highlighter-rouge">a</code>本身是没有类型的，或者说它的类型是动态的，它同样可以指向其它类型的内存数据</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="s">"hello"</span>
<span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1">#&lt;class 'str'&gt;
</span></code></pre></div></div>
<p>此时<code class="highlighter-rouge">a</code>的”类型”变成了string，表面上看，上述代码实际上是对<code class="highlighter-rouge">a</code>的重新赋值，因此一个直观的想法是<code class="highlighter-rouge">a</code>所指向的内存数据被修改了，从<code class="highlighter-rouge">10</code>被修改为<code class="highlighter-rouge">hello</code>，也就是所谓的mutation。实际上则不是，重新赋值后的<code class="highlighter-rouge">a</code>指向的是另一块新的内存，其值为<code class="highlighter-rouge">hello</code>，原来<code class="highlighter-rouge">10</code>的那块内存仍然存在，只是没有人引用它的，很快便会被GC回收。</p>

<p>我们可以用代码试验一下上述结论</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span> <span class="c1">#x10c28eb90
</span><span class="n">a</span> <span class="o">=</span> <span class="mi">15</span>
<span class="k">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span> <span class="c1">#0x10851fc30
</span></code></pre></div></div>

<p>可见<code class="highlighter-rouge">a</code>指向的内存地址发生了变化，而并非是修改原来内存地址中的值。这种情况下，我们称<code class="highlighter-rouge">a</code>是Immutable的，Python中有一些数据结构是Immutable的，包括</p>

<table>
  <thead>
    <tr>
      <th>Immutable</th>
      <th>Mutable</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Numbers(int, float, Booleans, etc)</td>
      <td>Lists</td>
    </tr>
    <tr>
      <td>Strings</td>
      <td>Sets</td>
    </tr>
    <tr>
      <td>Tuples</td>
      <td>Dictionaries</td>
    </tr>
    <tr>
      <td>Frozen Sets</td>
      <td>User-Defined Classes</td>
    </tr>
    <tr>
      <td>User-Defined Classes</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>对于Mutbale的数据结构，我们可以修改其内容，然后观察其地址</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#1 list是mutable的
</span><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">my_list</span><span class="p">)))</span> <span class="c1">#0x10ae13f48
</span><span class="n">my_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">my_list</span><span class="p">)))</span> <span class="c1">#0x10ae13f48
#2 string是immutable的
</span><span class="n">my_str</span> <span class="o">=</span> <span class="s">"123"</span>
<span class="k">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">my_str</span><span class="p">)))</span> <span class="c1">#0x10da15030
</span><span class="n">my_str</span> <span class="o">+=</span> <span class="s">"4"</span>
<span class="k">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">my_str</span><span class="p">)))</span> <span class="c1">#0x10da15068
</span></code></pre></div></div>

<p>第一个例子，<code class="highlighter-rouge">append</code>会对<code class="highlighter-rouge">my_list</code>指向内存中的数据进行修改，但是<code class="highlighter-rouge">my_list</code>自己的内存地址并不发生变化，复合预期。第二个例子，<code class="highlighter-rouge">my_str</code>是Immutable的，因此第二个<code class="highlighter-rouge">my_str</code>是一个新的<code class="highlighter-rouge">my_str</code>，<code class="highlighter-rouge">+=</code>操作并未对旧的的<code class="highlighter-rouge">my_str</code>进行修改</p>

<p>综上所述，在使用变量时头脑中要清楚该变量是Immutable的还是mutable的。这个问题在函数传参时尤为明显，如果pass了一个mutbale变量到函数内部，可能存在side effect。</p>

<h3 id="shared-references-and-memory">Shared References and Memory</h3>

<p>回顾前面的例子，Python中的对变量的重新赋值实际上是将变量的指针指向了一块新的内存，但是如果将一个变量的值赋值给另一个变量，会发生什么呢？</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1">#0x10ac99130
</span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="c1">#0x10ac99130
</span></code></pre></div></div>

<p>此时对b的赋值并不会产生对a的拷贝，b也并不会指向新开辟的内存空间，而是和a指向同一片内存空间，相当于b是a的一个别名。这时如果我们改变了<code class="highlighter-rouge">a</code>的值，令<code class="highlighter-rouge">a = 11</code>，此时会影响<code class="highlighter-rouge">b</code>吗？由前面的内容可知，由于<code class="highlighter-rouge">a</code>是Immutable的，<code class="highlighter-rouge">a=11</code>是令<code class="highlighter-rouge">a</code>指向了一片新的内存，对<code class="highlighter-rouge">b</code>没有影响。</p>

<p>因此对于Immutable类型的变量，Python内存管理器会让变量共享内存以节约开销。下面的例子则更能说明这一点：</p>

<div class="md-flex-h md-margin-bottom-24">
<div>
<pre class="highlight language-python md-no-padding-v md-height-full">
<code class="language-python">
#a,b同样指向同一片内存区域
a = 10 #0x10375e130
b = 10 #0x10375e130
</code>
</pre>
</div>
<div class="md-margin-left-12">
<pre class="highlight md-no-padding-v md-height-full">
<code class="language-python">
a=None #0x101031148
b=None #0x101031148
</code>
</pre>
</div>
</div>

<p>Python中的<code class="highlighter-rouge">None</code>对象也是共享内存的，所有被赋值为<code class="highlighter-rouge">None</code>的变量，它们所指向的内存地址相同</p>

<blockquote>
  <p><code class="highlighter-rouge">None</code>表示某个变量的值为”empty”，类似JavaScript中的<code class="highlighter-rouge">Undefined</code>，也可以理解为该变量并没有被赋值。Python中，<code class="highlighter-rouge">None</code>是一个具体的Object，被Memory Manager管理</p>
</blockquote>

<p>如果变量是mutbable的，这么做就有风险，例如下面代码对<code class="highlighter-rouge">a</code>指向内存的修改直接会影响b,因此对于mutbale类型的变量，Python内存管理器则不会让变量共享内存。</p>

<div class="md-flex-h md-margin-bottom-24">
<div>
<pre class="highlight language-python md-no-padding-v md-height-full">
<code class="language-python">
a = [1,2,3]
b = a
a.append(4)
b #[1,2,3,4]
</code>
</pre>
</div>
<div class="md-margin-left-12">
<pre class="highlight md-no-padding-v md-height-full">
<code class="language-python">
a = [1,2,3] #0x103a74348
b = [1,2,3] #0x103a74488
</code>
</pre>
</div>
</div>

<h3 id="variable-equality">Variable Equality</h3>

<p>Python中有两种Equality，一种是内存地址相同（identity），用<code class="highlighter-rouge">is</code>来表示，另一种是使用<code class="highlighter-rouge">==</code>表示两个对象的”值”（内部state）是否相同（equality），与之相对应的不等关系则用<code class="highlighter-rouge">is not</code>和<code class="highlighter-rouge">!=</code>表示。我们看几个例子</p>

<div class="md-flex-h md-margin-bottom-24">
<div>
<pre class="highlight language-python md-no-padding-v md-height-full">
<code class="language-python">
a=10
b=a
a is b #true
a == b #true
</code>
</pre>
</div>
<div class="md-margin-left-12">
<pre class="highlight md-no-padding-v md-height-full">
<code class="language-python">
a = [1,2,3]
b = [1,2,3]
a is b #false
a == b #true
</code>
</pre>
</div>
<div class="md-margin-left-12">
<pre class="highlight md-no-padding-v md-height-full">
<code class="language-python">
a=10
b=10.0
a is b #false
a == b #true
</code>
</pre>
</div>
<div class="md-margin-left-12">
<pre class="highlight md-no-padding-v md-height-full">
<code class="language-python">
a = None
b = None
a is None #true
a == b #true
</code>
</pre>
</div>
</div>

<h3 id="everything-is-object">Everything is Object</h3>

<p>Python中所有的变量有自己的类型，它们的类型都是某种class，就连<code class="highlighter-rouge">class</code>本身也是某个class的实例，因此可以说Python中的所有变量都是Object。</p>

<p>以函数为例，和绝大多数现代编程语言一样，函数在Python中也是first-class的，可以被像变量有自己的类型，可以被做为参数传递，赋值，以及做函数的返回值。当我们定义一个函数时，函数名是Object的名称，它有自己的内存地址</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">**</span><span class="mi">2</span>

<span class="nb">type</span><span class="p">(</span><span class="n">square</span><span class="p">)</span> <span class="c1">#&lt;class 'function'&gt;
</span><span class="k">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">square</span><span class="p">)))</span> <span class="c1">#0x1011b4268
</span><span class="n">f</span> <span class="o">=</span> <span class="n">square</span>
<span class="n">f</span> <span class="ow">is</span> <span class="n">square</span> <span class="c1">#ture
</span></code></pre></div></div>

<p>此外，一些基本的数据类型比如<code class="highlighter-rouge">int</code>,<code class="highlighter-rouge">float</code>等在python中也是以<code class="highlighter-rouge">class</code>形式存在的，在第一小节的第一个例子中，我们看到了<code class="highlighter-rouge">a</code>的类型为<code class="highlighter-rouge">&lt;class 'int'&gt;</code>，<code class="highlighter-rouge">int</code>类的定义如下</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; help(int)
class int(object)
 |  int([x]) -&gt; integer
 |  int(x, base=10) -&gt; integer
 |
 |  Convert a number or string to an integer, or return 0 if no arguments
 |  are given.  If x is a number, return x.__int__().  For floating point
 |  numbers, this truncates towards zero.
 |
 |  If x is not a number or if base is given, then x must be a string,
 |  bytes, or bytearray instance representing an integer literal in the
 |  given base.  The literal can be preceded by '+' or '-' and be surrounded
 |  by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
 |  Base 0 means to interpret the base from the string as an integer literal.
 |  &gt;&gt;&gt; int('0b100', base=0)
 |  4
 ...
</code></pre></div></div>
<p>我们可以像创建对象一样来创建一个<code class="highlighter-rouge">int</code>型变量</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c</span> <span class="o">=</span> <span class="nb">int</span><span class="p">()</span>
<span class="n">c</span> <span class="c1">#0
</span><span class="n">c</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">c</span> <span class="c1">#10
</span><span class="n">c</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="s">'101'</span><span class="p">,</span><span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#二进制数
</span><span class="n">c</span> <span class="c1">#5
</span></code></pre></div></div>

<h2 id="变量的编译器优化">变量的编译器优化</h2>

<p>有了上面的知识做铺垫，我们可以开始研究Python的编译器是如何优化变量的</p>

<h3 id="interning">Interning</h3>

<p>回顾前面的例子，对于两个具有相同值的Immutable对象，它们的内存是共享的，但某些情况下，却有例外，如下面代码所示</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1">#0x10375e130
</span><span class="n">b</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1">#0x10375e130
</span>
<span class="n">a</span><span class="o">=</span><span class="mi">500</span> <span class="c1">#0x1015ed110
</span><span class="n">b</span><span class="o">=</span><span class="mi">500</span> <span class="c1">#0x1015ed030
</span></code></pre></div></div>
<p>为了解释这个问题，需要理解Python的Interning机制，所谓Interning是Python编译器中的一种内存优化技术，它会”按需”的重用对象。不同版本的Python引擎对这个机制的实现不同，以标准的CPython为例，当执行Python代码前，会提前创建一批整型单例(Singletons)对象(范围从<code class="highlighter-rouge">[-5, 256]</code>)，并将他们缓存起来，当程序中需要使用这些数值，直接从缓存中取出而不会重新创建对象，这就是为什么<code class="highlighter-rouge">a,b</code>指向同一块内存地址的原因，对于缓存中没有的数值，则会重新创建一份，这是为什么<code class="highlighter-rouge">a,b</code>的值为<code class="highlighter-rouge">500</code>之后，它们各自指向了不同的地址。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span> <span class="c1">#0x10107af50
</span><span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span> <span class="c1">#0x10107af50
</span>
<span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">6</span> <span class="c1">#0x1015ed110
</span><span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">6</span> <span class="c1">#0x1015ed030
</span></code></pre></div></div>

<p>对于字符串，由前面小节可知，也有类似的Interning，例如:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="s">'some_long_string'</span>
<span class="n">b</span> <span class="o">=</span> <span class="s">'some_long_string'</span>
<span class="n">a</span> <span class="ow">is</span> <span class="n">b</span> <span class="c1"># true
</span></code></pre></div></div>
<p>如果整型数据的预加载是为了减少内存开销，提高程序运行的速度，那么对于字符串，我们可以思考一下这种Interning机制有什么好处呢？</p>

<p>能想到的一个好处是字符串比较，对于两个字符串<code class="highlighter-rouge">a</code>,<code class="highlighter-rouge">b</code>当我们使用<code class="highlighter-rouge">a==b</code>进行比较时，会逐个字符比较(或者用高级一点的KMP之类的算法，但思路还是遍历字符并比较)，但是我们如果知道<code class="highlighter-rouge">a is b</code>即<code class="highlighter-rouge">a,b</code>来指向同一片内存，那么则不用进行比较了，可以直接返回true，这显然是最快的方法。</p>

<p>但和前面介绍的整型一样，不是所有的字符串都可以被interning，一些被编译器判定为<code class="highlighter-rouge">identifier</code>特征的字符串会被interned，例如下面两个字符串则不会被interned</p>

<blockquote>
  <p>identifier是指只包含数字，字母，下划线的字符串</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="s">'hello world'</span>
<span class="n">b</span> <span class="o">=</span> <span class="s">'hello world'</span>
<span class="n">a</span> <span class="ow">is</span> <span class="n">b</span> <span class="c1">#false
</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="c1">#true
</span></code></pre></div></div>
<p>使用<code class="highlighter-rouge">identifier</code>作为判断标准的一个原因是这些字符可能会表示函数名，类名等，在runtime中可能被用到。Python也提供了API可以强行令string被interned:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="nb">intern</span><span class="p">(</span><span class="s">'the quick brown fox'</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="nb">intern</span><span class="p">(</span><span class="s">'the quick brown fox'</span><span class="p">)</span>
<span class="n">a</span> <span class="ow">is</span> <span class="n">b</span> <span class="c1">#true
</span></code></pre></div></div>

<h3 id="peephole">Peephole</h3>

<p>Peephole是Python编译器的另一项优化技术，他可以对一些常量表达式进行提前求值，并将结果缓存，例如</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_func</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">24</span><span class="o">*</span><span class="mi">60</span>  <span class="c1">#1440
</span>    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">5</span> <span class="c1">#(1,3,1,3,1,3,1,3,1,3)
</span>    <span class="n">c</span> <span class="o">=</span> <span class="s">'abc'</span><span class="o">*</span><span class="mi">3</span> <span class="c1">#abcabcabc
</span>    <span class="n">d</span> <span class="o">=</span> <span class="s">'ab'</span><span class="o">*</span><span class="mi">11</span>
    <span class="n">e</span> <span class="o">=</span> <span class="s">'the quick brown fox'</span> <span class="o">*</span> <span class="mi">5</span>
    <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="s">'a'</span><span class="p">,</span><span class="s">'b'</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span>
</code></pre></div></div>

<p>对上述函数，编译器会对函数中的常量表达式进行提前求值，求值结果可以通过<code class="highlighter-rouge">my_func.__code__.co_consts</code>输出</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(None, 
1440, 
(1, 3, 1, 3, 1, 3, 1, 3, 1, 3), 
'abcabcabc', 
'ababababababababababab', 
'the quick brown foxthe quick brown foxthe quick brown foxthe quick brown foxthe quick brown fox', 
'a', 'b', 3
)
</code></pre></div></div>
<p>我们看到上面<code class="highlighter-rouge">f</code>并没有被求值，原因是<code class="highlighter-rouge">['a','b']</code>是mutable数组，并非是常量表达式，因此编译器不会对这条语句进行优化。</p>

<p>除了常量表达式的提前求值，Python编译器还会对某些集合操作进行优化，比如对检查某个成员是否属于某个集合的优化：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]:</span>
</code></pre></div></div>
<p>上述代码中<code class="highlighter-rouge">[1,2,3]</code>是mutable的object，会被编译器将类型替换为Immutable的类型tuple<code class="highlighter-rouge">(1,2,3)</code>。</p>

<p>我们来看一个具体例子</p>

<div class="md-flex-h md-margin-bottom-24">
<div>
<pre class="highlight language-python md-no-padding-v md-height-full">
<code class="language-python">
#using array
def my_func(e):
    for e in [1,2,3]:
        pass
</code>
</pre>
</div>
<div class="md-margin-left-12">
<pre class="highlight md-no-padding-v md-height-full">
<code class="language-python">
#using set
def my_func(e):
    for e in {1,2,3}:
        pass
</code>
</pre>
</div>
</div>

<p>执行<code class="highlighter-rouge">my_func.__code__.co_consts</code>，结果为</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#using tuple
(None, (1, 2, 3))

#using set
(None, frozenset({1, 2, 3}))
</code></pre></div></div>
<p>说明编译器将数组<code class="highlighter-rouge">[1,2,3]</code>转化成了tuple，将set转成了<code class="highlighter-rouge">frozenset</code>。</p>

<p>总的来说，对集合操作的优化是将mutable版本转化为对应的Immutable版本的。编译器做这种优化的目的还是为了提高程序运行的速度，显然array，tuple，set三者里面set的查询速度速度最快<code class="highlighter-rouge">O(1)</code>，我们可以用一个demo来验证</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">string</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="n">letters</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_letters</span>
<span class="n">char_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
<span class="n">char_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
<span class="n">char_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">char_list</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">membership_test</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">container</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="s">'z'</span> <span class="ow">in</span> <span class="n">container</span><span class="p">:</span>
            <span class="k">pass</span>

<span class="c1">#test array
</span><span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
<span class="n">membership_test</span><span class="p">(</span><span class="mi">1000000</span><span class="p">,</span><span class="n">char_list</span><span class="p">)</span> <span class="c1">#一百万次
</span><span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'list:'</span><span class="p">,</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span> <span class="c1">#list: 0.461002645
</span>
<span class="c1">#test tuple
</span><span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
<span class="n">membership_test</span><span class="p">(</span><span class="mi">1000000</span><span class="p">,</span><span class="n">char_tuple</span><span class="p">)</span> 
<span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'tuple:'</span><span class="p">,</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span> <span class="c1">#tuple: 0.44785893200000004
</span>
<span class="c1">#test set
</span><span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
<span class="n">membership_test</span><span class="p">(</span><span class="mi">1000000</span><span class="p">,</span><span class="n">char_set</span><span class="p">)</span>
<span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'set:'</span><span class="p">,</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span> <span class="c1">#set: 0.04525098400000005
</span></code></pre></div></div>

<p class="md-p-center md-margin-top-24">（全文完）</p>

<h3 id="resource">Resource</h3>

<ul>
  <li><a href="https://github.com/python/cpython">CPython</a></li>
  <li><a href="http://guilload.com/python-string-interning/">The internals of Python string interning</a></li>
  <li><a href="https://pdfs.semanticscholar.org/a456/b29641318e078c3780289a9ee688ff09e5d7.pdf">A Peephole Optimizer for Python</a></li>
</ul>
:ET