I"p<h2 id="模板实参的推断和引用">模板实参的推断和引用</h2>

<p>函数模板的形参可以为左值引用或者是右值引用，如果左值引用，又可分为普通的<code class="highlighter-rouge">T&amp;</code>和<code class="highlighter-rouge">const T&amp;</code>，其参数推断规则如下</p>

<h3 id="左值引用参数推断">左值引用参数推断</h3>

<p>当一个函数参数是一个普通的左值引用时<code class="highlighter-rouge">T&amp;</code>，其传递的实参只能是一个变量或者是一个返回引用类型的表达式。实参可以是<code class="highlighter-rouge">const</code>类型也可以不是，如果是<code class="highlighter-rouge">const</code>的，则<code class="highlighter-rouge">T</code>被推断为<code class="highlighter-rouge">const</code>类型</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">op</span><span class="p">);</span> <span class="c1">//实参必须是一个左值</span>
<span class="n">f1</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">//i是一个int；T是int</span>
<span class="n">f1</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span> <span class="c1">//ci是一个const int,则T是const int</span>
<span class="n">f1</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">//错误，5是一个右值</span>
</code></pre></div></div>
<p>如果模板参数是<code class="highlighter-rouge">const T&amp;</code>，则它可以接受任何类型的实参（<code class="highlighter-rouge">const</code>或非<code class="highlighter-rouge">const</code>的对象，临时变量和字面常量）。当实参是<code class="highlighter-rouge">const</code>类型时，<code class="highlighter-rouge">T</code>不会被推断为<code class="highlighter-rouge">const</code>类型，因为<code class="highlighter-rouge">const</code>已经是模板参数类型的一部分了</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">op</span><span class="p">);</span> <span class="c1">//可以接受右值</span>
<span class="c1">//f2的模板参数是const T&amp;, 实参的const是无效的</span>
<span class="c1">//在下面每个调用中，f2的参数都被推断为const int&amp;</span>
<span class="n">f1</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">//i是一个int；T是int</span>
<span class="n">f1</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span> <span class="c1">//ci是一个const int,则T是int</span>
<span class="n">f1</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">//const T&amp;可以绑定右值，T是int</span>
</code></pre></div></div>
<h3 id="右值引用参数推断和引用折叠">右值引用参数推断和引用折叠</h3>

<p>同理当一个模板参数声明为右值引用时，它将接受一个右值作为实参</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">f3</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">);</span>
<span class="n">f3</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">//实参是一个int型右值，T是int</span>
</code></pre></div></div>

<p>C++编译器对<code class="highlighter-rouge">T&amp;&amp;</code>做了一些特殊的设定，具体来说有两点，第一点是如果实参是一个左值，按照上面定义，它是不能直接绑定到右值引用(<code class="highlighter-rouge">T&amp;&amp;</code>)上的，但实际上却可以。假定<code class="highlighter-rouge">i</code>是一个<code class="highlighter-rouge">int</code>对象，当我们调用<code class="highlighter-rouge">f3(i)</code>时，编译器会推断<code class="highlighter-rouge">T</code>的类型为<code class="highlighter-rouge">int&amp;</code>,而非<code class="highlighter-rouge">int</code>，此时<code class="highlighter-rouge">f3</code>接受的参数变成了一个左值引用的右值引用。通常，我们是不能定义一个引用的引用的，但是编译器为我们提供了第二条特殊设定，即如果我们间接创建了一个引用的引用，那么这些引用形成了<strong>折叠</strong>。在所有情况下（除了一个例外），引用会折叠成一个普通的左值引用。在新标准中，折叠也可产生一个右值引用，这种情况只能发生在右值引用的引用。即，对于一个给定类型<code class="highlighter-rouge">X</code>:</p>

<ul>
  <li><code class="highlighter-rouge">X&amp; &amp;</code>, <code class="highlighter-rouge">X&amp; &amp;&amp;</code>和<code class="highlighter-rouge">X&amp;&amp; &amp;</code>都折叠成<code class="highlighter-rouge">X&amp;</code></li>
  <li><code class="highlighter-rouge">X&amp;&amp; &amp;&amp;</code>折叠成<code class="highlighter-rouge">X&amp;&amp;</code></li>
</ul>

<p>这两个规则导致下面几个的结论，对于<code class="highlighter-rouge">template&lt;typename T&gt; void f3(T&amp;&amp;)</code>这样的模板</p>

<ul>
  <li>如果传递的参数是左值，<code class="highlighter-rouge">T</code>推导的结果是左值引用；如果传递过去的参数是右值，<code class="highlighter-rouge">T</code>推导的结果是参数类型本身；如果传递的参数是右值引用，则<code class="highlighter-rouge">T</code>推导的结果是右值引用</li>
  <li>如果<code class="highlighter-rouge">T</code>是左值引用，那么<code class="highlighter-rouge">T&amp;&amp;</code>的结果仍然是左值引用，即<code class="highlighter-rouge">T&amp; &amp;&amp;</code>折叠成了<code class="highlighter-rouge">T&amp;</code></li>
  <li>如果<code class="highlighter-rouge">T</code>是右值引用，那么<code class="highlighter-rouge">T&amp;&amp;</code>的结果仍然是右值引用，即<code class="highlighter-rouge">T&amp;&amp; &amp;&amp;</code>折叠成了<code class="highlighter-rouge">T&amp;&amp;</code></li>
  <li>如果<code class="highlighter-rouge">T</code>是一个右值，那么<code class="highlighter-rouge">T&amp;&amp;</code>的结果就是一右值应用</li>
</ul>

<p>T&amp;&amp; 的作用主要是保持值类别进行转发，它有个名字就叫“转发引用”（forwarding reference）。因为既可以是左值引用，也可以是右值引用，它也曾经被叫做“万能引用”（universal reference）。</p>

<h3 id="理解stdmove">理解<code class="highlighter-rouge">std::move</code></h3>

:ET