I"$z<h2 id="bitwise-operations">Bitwise Operations</h2>

<p>这一节我们研究如何使用位运算，完成加减乘的数学运算。在介绍每种运算之前，先来复习下基本的位运算：</p>

<table>
  <tbody>
    <tr>
      <td>x</td>
      <td>y</td>
      <td>AND<code class="highlighter-rouge">&amp;</code></td>
      <td>OR<code class="highlighter-rouge">|</code></td>
      <td>XNOR(同或)</td>
      <td>XOR(异或)<code class="highlighter-rouge">^</code></td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>异或</li>
</ul>

<p>相同为0，不同为1，可以理解为不进位的加法，其性质如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x^0 = x;
x^1s = ~x //1s 为若干个1
x^(~x) = 1s
x^x = 0 //important!
a^b=c --&gt; a^c=b --&gt; b^c=a //可用于swap操作
</code></pre></div></div>

<ul>
  <li>常用的位运算操作</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x&amp;1 == 1 or 0 //判断奇数偶数(x%2==1)
x = x&amp;(x-1) //清零最低位的1，可用来计算二进制中1的个数
x &amp;-x //得到最低位的1
x &amp; (~0 &lt;&lt; n) //x的最右边n位清零
</code></pre></div></div>
<h2 id="四则运算">四则运算</h2>

<blockquote>
  <p>为了简化场景，和表述方便，令所有的操作数的类型为signed long long类型，对于int类型的边界问题，在本章最后讨论</p>
</blockquote>

<h3 id="加法">加法</h3>

<p>我们先使用真值表分析两个bit相加的几种情况，进而推算出多个bit的加法规则</p>

<table>
  <tbody>
    <tr>
      <td>x</td>
      <td>y</td>
      <td>sum</td>
      <td>carry</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>由上面的真值表可以推到看出:</p>

<ol>
  <li><code class="highlighter-rouge">sum = x XOR y</code></li>
  <li><code class="highlighter-rouge">carry = x AND y</code></li>
</ol>

<p>回想十进制的两位数加法规则，如果个位相加有进位，则十位要累加进位，同样的规则也适用于位运算，我们将上面真值表中加入上一次计算的进位项：</p>

<table>
  <tbody>
    <tr>
      <td>x</td>
      <td>y</td>
      <td>last carry</td>
      <td>sum</td>
      <td>carry</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>由上面真值表不难发现，多个bit的叠加是一个循环的过程，即第0为产生的carry带给第1位，第1位的x，y相加后再加上carry，将产生的carry再带给第2位…，以此类推。想想我们如何用程序实现这个过程，首先最容易想到的是将两个数x，y分别转成二进制数，然后按照真值表的规则，逐位相加。但是将一个数拆成二进制这种做法太麻烦，工作量很大，而且计算速度满。实际上要达到同样的效果，也可以这么做，首先将x,y先进行XOR操作，得到各个位上未累加carry项的结果A，然后再令x,y进行AND操作，得到每第一位的carry结果B，接着可以让A累加上每一位的carry，即AB进行XOR操作，但这个操作又会带来新的carry，于是循环这个而操作，直到carry为0</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="kt">long</span> <span class="nf">add</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">a</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">b</span><span class="p">){</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">do</span><span class="p">{</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="p">;</span>
        <span class="n">carry</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">carry</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">carry</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对于上述代码，<code class="highlighter-rouge">sum</code>循环累加<code class="highlighter-rouge">carry</code>的过程有些不好理解，我们以<code class="highlighter-rouge">3+1</code>为例，看一下这个过程</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    011         011         001  
XOR 001     AND 001     &lt;&lt;    1
-------     --------    ------- 
    010         001         010  
-------------------------------------（1）

    010         011         010  
XOR 010     AND 010     &lt;&lt;    1
-------     --------    ------- 
    000         010         100  
------------------------------------- (2)

    000         000      
XOR 100     AND 100     
-------     --------    
    100         000     
------------------------------------- (3)
</code></pre></div></div>

<ol>
  <li>第(1)步累加之后carry项为<code class="highlighter-rouge">010</code>表示在计算第一位时产生了一个carry，需要将其累加到sum的第二上</li>
  <li>第(2)步将sum的第二项和carry累加得到<code class="highlighter-rouge">000</code>，此时又产生了新的carry<code class="highlighter-rouge">010</code>，因此需要将其加到sum的第三位上</li>
  <li>第(3)步将sum的第三项和carry累加得到<code class="highlighter-rouge">100</code>，此时的carry为0，说明此次相加没有产生新的carry，运算结束</li>
</ol>

<h3 id="减法">减法</h3>

<p>有了加法之后，后面的减法和乘法就要简单很多，先看减法，要计算<code class="highlighter-rouge">a+b</code>可以转化为计算<code class="highlighter-rouge">a+(-b)</code>，那么如何表示<code class="highlighter-rouge">-b</code>呢？这个问题在<a href="">C语言第二部分中曾提到过</a>，在计算机中，有符号数是通过补码进行存储的，补码计算方式为“源码取反+1”, 因此<code class="highlighter-rouge">-b</code>可以表示为:<code class="highlighter-rouge">~b+1</code>，<code class="highlighter-rouge">a+b</code>可以表示为<code class="highlighter-rouge">a+(~b+1)</code>。理解了这个，减法就很容易实现了</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="kt">long</span> <span class="nf">subtract</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">a</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">b</span><span class="p">){</span>
<span class="err">　　</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">subtrahend</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="o">~</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="err">　　</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">sub</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">subtrahend</span><span class="p">);</span>
<span class="err">　　</span><span class="k">return</span> <span class="n">sub</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="乘法">乘法</h3>

<p>乘法计算也可以转化为加法计算，只需要将被乘数循环累加乘数次即可。考虑到乘数或者被乘数中可能有负数，因此还需要想办法解决符号的问题。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="kt">long</span> <span class="nf">multiply</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">a</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">b</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">sign</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">b</span><span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">multiplicand</span> <span class="o">=</span> <span class="n">labs</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">multiplier</span> <span class="o">=</span> <span class="n">labs</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">result</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">multiplier</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">multiplicand</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sign</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">result</span> <span class="o">:</span> <span class="o">-</span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这种方式相对简单，但是效率不高，而且有一个比较严重的问题是当乘数很大时，比如<code class="highlighter-rouge">1x99999</code>，那么上述运算要循环<code class="highlighter-rouge">99999</code>次，这显然是极为低效的，因此还有另一种手动模拟乘法的方式，假如我们要做<code class="highlighter-rouge">2x3</code>和<code class="highlighter-rouge">2x5</code>我们可以像做十进制乘法一样对二进制各位进行乘法运算后求和：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    010             010
*   011         *   101  
-------         -------
    010             101
   0100            0000
 000000           10100
-------         -------
 000110           11001
</code></pre></div></div>

<p>观察上面运算可以发现：</p>

<ol>
  <li>令乘数的每一位与被乘数相乘，每乘一次乘数向右移动一位，直到乘数为0</li>
  <li>如果乘数的第<code class="highlighter-rouge">n</code>位为1，只需要将被乘数左移<code class="highlighter-rouge">n</code>位即可，实际运算中可以让被乘数在每进行完一次乘法后向左移动一位，这样则可以不必单独记录<code class="highlighter-rouge">n</code>的值</li>
  <li>如果乘数的第<code class="highlighter-rouge">n</code>位为0，这次计算可以跳过</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="kt">long</span> <span class="nf">multiply</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">a</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">b</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">sign</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">b</span><span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">multiplicand</span> <span class="o">=</span> <span class="n">labs</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">multiplier</span> <span class="o">=</span> <span class="n">labs</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">result</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">multiplier</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">multiplier</span> <span class="o">&amp;</span><span class="mh">0x01</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">multiplicand</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">multiplicand</span> <span class="o">=</span> <span class="n">multiplicand</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">multiplier</span> <span class="o">=</span> <span class="n">multiplier</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sign</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">result</span> <span class="o">:</span> <span class="o">-</span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="除法">除法</h3>

<p>简单的除法是不断用被除数减去除数，直到被除数小于除数，此时做减法的次数为商，余数为被除数。同样，除法也需要考虑符号问题</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="kt">long</span> <span class="nf">divide</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">a</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">b</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">sign</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">b</span><span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">multiplicand</span> <span class="o">=</span> <span class="n">labs</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">multiplier</span> <span class="o">=</span> <span class="n">labs</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">dividend</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">remainder</span> <span class="o">&gt;=</span> <span class="n">divisor</span><span class="p">){</span>
        <span class="n">remainder</span> <span class="o">=</span> <span class="n">substract</span><span class="p">(</span><span class="n">remainder</span><span class="p">,</span><span class="n">divisor</span><span class="p">);</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sign</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">result</span> <span class="o">:</span> <span class="o">-</span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上述算法也会遇到和简单乘法相同的问题，就是当被除数特别大，除数特别小时，算法会很低效，比如<code class="highlighter-rouge">99999/1</code>要循环<code class="highlighter-rouge">99999</code>次。我们能否找到一种扩大步长的方式来减少循环次数呢？先看上面的运算，步长为除数，商为循环的次数。如果我们以除数的2的n次方倍作为步长，不断逼近被除数，则可以大大加快速度，我们以<code class="highlighter-rouge">19/3</code>为例来看下这种算法</p>

<ol>
  <li>找到小于<code class="highlighter-rouge">19</code>的最大除数，该除数为<code class="highlighter-rouge">3</code>的<code class="highlighter-rouge">(2^i)</code>倍，可知该除数为<code class="highlighter-rouge">3x2x2 =12</code>,此时<code class="highlighter-rouge">i=2</code>,相当于除数左移了两位<code class="highlighter-rouge">3&lt;&lt;2</code></li>
  <li>令<code class="highlighter-rouge">19/12</code>，得到商<code class="highlighter-rouge">q=1</code>，余数<code class="highlighter-rouge">r=7</code>，对于<code class="highlighter-rouge">q</code>的理解是它包含了<code class="highlighter-rouge">2^i</code>个<code class="highlighter-rouge">3</code>，因此，实际的商为<code class="highlighter-rouge">qx2^i = 1x2^2 = 4</code></li>
  <li>对于余数<code class="highlighter-rouge">r=7</code>，显然它并不是最后的余数，还可以继续被分解，于是将他作为新的被除数，重复第一步，找到小于<code class="highlighter-rouge">7</code>的最大除数为<code class="highlighter-rouge">6</code>，此时<code class="highlighter-rouge">i=1</code>，相当于<code class="highlighter-rouge">3&lt;&lt;1</code></li>
  <li>令<code class="highlighter-rouge">7/6</code>的到商<code class="highlighter-rouge">q=1,r=1</code>，此时的q同样是包含了<code class="highlighter-rouge">2^i</code>个<code class="highlighter-rouge">3</code>，因此，即实际的商为<code class="highlighter-rouge">1x2=2</code>，加上第2步得到的商，总的结果为<code class="highlighter-rouge">6</code></li>
  <li>此时<code class="highlighter-rouge">r=1</code>小于<code class="highlighter-rouge">3</code>说明除数已经全部分解完成，得到的余数为真正的余数</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="kt">long</span> <span class="nf">divide</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">a</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">b</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">sign</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">b</span><span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">dividend</span>  <span class="o">=</span> <span class="n">labs</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">divisor</span> <span class="o">=</span> <span class="n">labs</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span>  <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">31</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span>
        <span class="n">tmp</span>  <span class="o">=</span> <span class="n">divisor</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="c1">//divisor不变，tmp不断变小，int类型放置左移溢出</span>
        <span class="k">if</span><span class="p">(</span><span class="n">dividend</span> <span class="o">&gt;=</span> <span class="n">tmp</span><span class="p">){</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="mi">1LL</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">);</span>
            <span class="n">dividend</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">substract</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">dividend</span><span class="p">,(</span><span class="kt">int</span><span class="p">)</span><span class="n">tmp</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sign</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">result</span> <span class="o">:</span> <span class="o">-</span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>关于除法还有另外一种计算方式，这种方式比上面要简单的多，并且不依赖加法与减法，该方式的伪码为：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>quotient = 1
while divisor is less than dividend
    divisor = (left shift divisor)
    quotient = (left shift quotient)
Handle overflow recursively.
</code></pre></div></div>

<p>以除数被除数都为正数为例（忽略int边界问题），上述逻辑实现如下：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>  <span class="nf">divide</span><span class="p">(</span><span class="kt">int</span> <span class="n">dividend</span><span class="p">,</span> <span class="kt">int</span> <span class="n">divisor</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">dividend</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">dividend</span><span class="o">&lt;</span><span class="n">divisor</span><span class="p">){</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">divisor</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">){</span>
        <span class="k">return</span> <span class="n">dividend</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">dividend</span> <span class="o">==</span> <span class="n">divisor</span><span class="p">){</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">divisor</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">dividend</span><span class="p">){</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//余数比除数大的情况，比如11/3 , 商2余5，还需要继续这个过程</span>
    <span class="k">if</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">divisor</span><span class="p">){</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">q</span><span class="o">+</span><span class="n">divide</span><span class="p">(</span><span class="n">dividend</span><span class="o">-</span><span class="n">tmp</span><span class="p">,</span><span class="n">divisor</span><span class="p">);</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="k">return</span> <span class="n">q</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="边界问题">边界问题</h3>

<p>上面的算法均假设所有数据类型为<code class="highlighter-rouge">long long</code>类型，如果需要计算<code class="highlighter-rouge">int</code>类型的四则运算，需要考虑<code class="highlighter-rouge">int</code>的<a href="">边界范围</a>，即<code class="highlighter-rouge">INT_MAX</code>, <code class="highlighter-rouge">INT_MIN</code>。比如，计算除法<code class="highlighter-rouge">divide(-2147483648, -1)</code>,被除数为<code class="highlighter-rouge">INT_MIN</code>，如果使用<code class="highlighter-rouge">abs</code>去符号，则得不到<code class="highlighter-rouge">2147483648</code>(<code class="highlighter-rouge">INT_MAX</code>为<code class="highlighter-rouge">2147483647)，因此可以考虑使用</code>labs<code class="highlighter-rouge">函数，另外，再做商累加时，需要用到移位操作，</code>1«i<code class="highlighter-rouge">，如果</code>i<code class="highlighter-rouge">为</code>INT_MAX<code class="highlighter-rouge">同样会有问题，需要考虑将</code>1<code class="highlighter-rouge">表示为</code>long long<code class="highlighter-rouge">类型的</code>1LL`。</p>

<h2 id="更多为位运算相关问题">更多为位运算相关问题</h2>

<p>位运算除了用于做加减乘除外，还可以有其它的应用</p>

<ul>
  <li><a href="https://leetcode.com/problems/divide-two-integers/submissions/1">29. Divide Two Integers</a></li>
  <li><a href="https://leetcode.com/problems/single-number/description/">136. Single Number</a></li>
</ul>

:ET