I"X<p>堆是<mark>完全二叉树</mark>的一种表现形式。以最小堆为例，它要求的每个父节点的值大于两个子节点的值，两个兄弟节点之间的值的大小关系没有限制。由于完全二叉树可以用数组表示，上述性质也可以表述为：</p>

<ol>
  <li>$K_1&lt;=K_{2i+1}$</li>
  <li>$K_1&lt;=K_{2i+2}$</li>
</ol>

<p>因此使用最小堆可以找出这组节点的最小值。推而广之，对于一组无序的数，可以将他们构建成堆来快速得到最大值或最小值，当有新元素进来时，堆也依然可以保持这种特性</p>

<p><img src="/assets/images/2008/07/tree-7.jpg" style="margin-left:auto; margin-right:auto;display:block" /></p>

<p>堆的核心操作有如下三种</p>

<ol>
  <li>建堆，将一组无序的数组织成堆的形式
    <ul>
      <li>思路1：将n数组成的无序数组进行原地建堆操作</li>
      <li>思路2：将n个无序的数一个一个进行插入操作</li>
    </ul>
  </li>
  <li>新元素入堆后如何调整堆
    <ul>
      <li>将其放到数组最右边的位置</li>
      <li>递归进行<code class="highlighter-rouge">SiftUp</code>调整</li>
    </ul>
  </li>
  <li>堆顶元素出堆后如何调整
    <ul>
      <li>将数组最后一个节点的值付给堆顶元素</li>
      <li>删除最后一个元素</li>
      <li>堆顶节点递归进行<code class="highlighter-rouge">SiftDown</code>调整</li>
    </ul>
  </li>
</ol>

<h3 id="堆的表示">堆的表示</h3>

<p>正如前文所述，由于堆是一种完全二叉树，我们可以用数组表示，如上图中的小顶堆可用数组<code class="highlighter-rouge">[4,16,28,31,44,59]</code>表示。对于数组中的任意元素，下标为<code class="highlighter-rouge">i</code>的节点的左孩子节点的下标为<code class="highlighter-rouge">i*2+1</code>，右孩子节点的下标为<code class="highlighter-rouge">2*i+2</code>，父节点的坐标为<code class="highlighter-rouge">(i-1)/2</code>。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Heap</span><span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">heap</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="c1">//堆大小</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span> <span class="c1">//堆中元素个数</span>

<span class="nl">public:</span>
    <span class="n">Heap</span><span class="p">(</span><span class="kt">int</span> <span class="n">capicity</span><span class="p">){</span>
        <span class="n">heap</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">capacity</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Heap</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">){</span>
        <span class="n">capacity</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>
        <span class="n">heap</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span>
        <span class="n">buildHeap</span><span class="p">(</span><span class="n">heap</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">buildHeap</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">top</span><span class="p">(){</span> <span class="k">return</span> <span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="p">};</span>
    <span class="kt">void</span> <span class="n">pop</span><span class="p">();</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">left_child_index</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">pos</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="o">?-</span><span class="mi">1</span><span class="o">:</span><span class="n">index</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">right_child_index</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">pos</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">index</span><span class="o">?=</span><span class="n">n</span><span class="o">?-</span><span class="mi">1</span><span class="o">:</span><span class="n">index</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">parent_index</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">){</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">sift_up</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">pos</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">sift_down</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="siftdown调整"><code class="highlighter-rouge">SiftDown</code>调整</h3>

<p>所谓SiftDown调整，即将一个不合适的父节点下降到合适的位置。以小顶堆为例，我们需要考虑四种情况：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//递归调整</span>
<span class="kt">void</span> <span class="nf">sift_down</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">heap</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">position</span><span class="p">){</span>
    <span class="c1">//找到左右节点的index</span>
    <span class="kt">size_t</span> <span class="n">l</span> <span class="o">=</span> <span class="n">left_child_index</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">r</span> <span class="o">=</span> <span class="n">right_child_index</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
    
    <span class="c1">//待删除节点为叶子节点</span>
    <span class="k">if</span><span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//待删除节点左子节点为空，说明当前已经是叶子节点</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">){</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//待删除节点的右子节点为空，比较左节点</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">heap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">l</span><span class="p">]){</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">heap</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">heap</span><span class="p">[</span><span class="n">l</span><span class="p">]);</span>
            <span class="n">sift_down</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="c1">//待删除节点的左右子节点都不空，找到最小的</span>
        <span class="kt">size_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">heap</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">?</span> <span class="n">l</span><span class="o">:</span><span class="n">r</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">heap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">index</span><span class="p">]){</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">heap</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">heap</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
            <span class="n">sift_down</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="siftup调整"><code class="highlighter-rouge">SiftUp</code>调整</h3>

<p>和SiftDown类似，SiftUp调整是将一个不合适的子节点上升到合适的位置，例如新元素进入堆之后，该元素要进行SiftUp调整</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">sift_up</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">heap</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pos</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">parent_index</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">heap</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">&lt;</span><span class="n">heap</span><span class="p">[</span><span class="n">p</span><span class="p">]){</span>
        <span class="c1">//交换父子节点</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">heap</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="p">[</span><span class="n">p</span><span class="p">]);</span>
        <span class="c1">//递归调整</span>
        <span class="n">sift_up</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="建堆">建堆</h3>

<p>了解了堆调整的两个算法后，我们可以用上面的方法来建堆。如上文所述，建堆有两种思路，其中第二种思路较为简单，可以退化为入堆操作，第一种思路需要按下面步骤操作：</p>

<ol>
  <li>将<code class="highlighter-rouge">n</code>个关键码放到一维数组中，整体不是最小堆</li>
  <li>由完全二叉树的特性，有一半的节点<code class="highlighter-rouge">⌊n/2⌋</code>是叶子节点，它们不参与建堆的过程
    <ul>
      <li><code class="highlighter-rouge">i≥⌊n/2⌋</code> 时，以关键码<code class="highlighter-rouge">Ki</code>为根的子树已经是堆</li>
    </ul>
  </li>
  <li>从倒数第二层最右边的非叶子节点开始（完全二叉树数组<code class="highlighter-rouge">i=⌊n/2-1⌋</code>的元素），依次向前，进行递归SiftDown调整。</li>
</ol>

<p><img src="/assets/images/2008/07/tree-8.jpg" style="margin-left:auto; margin-right:auto;display:block" /></p>

<p>例如上图中，我们有一组8个数的无序序列<code class="highlighter-rouge">{72,73,71,23,94,16,05,68}</code>，建堆步骤为</p>

<ol>
  <li>按照完全二叉树排布，形成树形结构，如上图</li>
  <li>成树后，可以看到有4个节点(<code class="highlighter-rouge">⌊4/2⌋</code>)已经是叶子节点，它们不需要参与建堆的过程</li>
  <li>从<code class="highlighter-rouge">23</code>开始（数组第<code class="highlighter-rouge">i=⌊4/2-1⌋=3</code>项）依次进行<code class="highlighter-rouge">sift_down</code>调整，顺序依次是:<code class="highlighter-rouge">23</code>,<code class="highlighter-rouge">71</code> ,<code class="highlighter-rouge">73</code> ,<code class="highlighter-rouge">72</code></li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">buildHeap</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">heap</span><span class="p">){</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">count</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
        <span class="n">sift_down</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span> 
<span class="err">}</span>
</code></pre></div></div>
<p>分析一下建堆的效率:</p>

<ol>
  <li>$n$个节点的堆，高度为$d=⌊\log_2^{n}+1⌋$，设根为第$0$层，第$i$层节点数为$2^i$</li>
  <li>考虑一个元素在队中向下移动的距离
    <ul>
      <li>大约一半的节点深度为$d-1$，不移动（叶）。</li>
      <li>四分之一的节点深度为$d-2$，而它们至多能向下移动一层。</li>
      <li>树中每向上一层，节点的数目为前一层的一半，而子树高度加一。</li>
      <li>因此元素移动的最大距离的总数为：</li>
    </ul>

    <script type="math/tex; mode=display">\sum_{i=1}^{\log{n}}(i-1)\frac{n}{2^i}=O(n)</script>
  </li>
</ol>

<h3 id="插入元素">插入元素</h3>

<p>对于插入操作，我们首先将待插入元素放到数组末尾，然后利用前面提到的<code class="highlighter-rouge">sift_up</code>算法，让新插入的节点与父节点对比大小，如果不满足子节点小于等于父节点的大小关系，我们就互换两个节点。一直重复这个过程，直到父子节点之间满足刚说的那种大小关系。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;&gt;</span><span class="kt">int</span> <span class="n">data</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">){</span>
        <span class="k">return</span> <span class="p">;</span> <span class="c1">//堆满了</span>
    <span class="p">}</span>
    <span class="o">++</span><span class="n">count</span><span class="p">;</span>
    <span class="n">heap</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="c1">//递归调整</span>
    <span class="n">sift_up</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="删除元素">删除元素</h3>

<p>对于堆来说，由于不支持随机访问，删除元素指的就是删除堆顶元素。以小顶堆为例，当我们删除堆顶元素之后，就需要把第二小的元素放到堆顶，而第二小元素肯定会出现在左右子节点中，于是我们可以将堆顶元素和第二小的个元素进行交换，然后我们再递归删除交换后的这个节点，以此类推，直到叶子节点被删除。</p>

<p>而实的删除算法并不会按照上面思路执行，而是会用到一个小技巧，即我们先将数组中最后一个元素的值和堆顶互换，然后删除数组中最后一个元素（即删除了堆顶元素）。接下来，对于新的堆顶元素，进行上面提到的<code class="highlighter-rouge">sift_down</code>操作，直到找到合适位置。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">pop</span><span class="p">(){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
        <span class="k">return</span> <span class="p">;</span> <span class="c1">//堆中没有数据</span>
    <span class="p">}</span>
    <span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="p">[</span><span class="n">count</span><span class="p">];</span> <span class="c1">//交换堆顶和末尾元素</span>
    <span class="n">heap</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span> <span class="c1">//删除末尾元素</span>
    <span class="o">--</span><span class="n">count</span> <span class="p">;</span>
    <span class="c1">//堆顶元素sift_down</span>
    <span class="n">sift_down</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="堆操作时间复杂度分析">堆操作时间复杂度分析</h3>

<p>建堆的效率前面已经分析过了为<code class="highlighter-rouge">O(n)</code>，对于插入和删除操作来说，它们的主要操作是<code class="highlighter-rouge">sift_down</code>和<code class="highlighter-rouge">sift_up</code>操作，这两种操作每次均是向上或者向下跨越一层，因此时间复杂度和树的高度成正比，也就是<code class="highlighter-rouge">O(logn)</code>。</p>

<h2 id="堆的其它实现">堆的其它实现</h2>

<p>上面介绍的建堆的方式是最基本的二叉堆（Binary Heap），除了这种方式以外还有很多种其它建堆的方式，比如使用BST，红黑树等。不同的建堆方式其性能也不尽相同，这里附上一张对比图</p>

<p><img src="/assets/images/2010/07/heap-wiki.png" class="md-img-center" /></p>

<h2 id="堆排序">堆排序</h2>

<p>我们可以利用堆顶每次返回最优解这个特性来对数组进行原地排序，也就是所谓的堆排序。假设我们要从小到大排序，这时候我们需要建一个大顶堆，按照大顶堆的特性，堆顶元素为数组最大元素，我们把它跟最后一个元素交换，那最大元素就放到了下标为n的位置。接下来为了保持堆的特性，我们需要对新的堆顶进行sift down操作，这样剩下的<code class="highlighter-rouge">n-1</code>个元素又构成了新的大顶堆。我们再取堆顶的元素放到<code class="highlighter-rouge">n-1</code>的位置，重复这个过程，直到堆中只剩一个元素，排序工作就完成了。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">heap_sort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">){</span>
    <span class="n">buildHeap</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">k</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">){</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
        <span class="o">--</span><span class="n">k</span><span class="p">;</span>
        <span class="n">sift_down</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>上面的堆排序算法包含两个过程，建堆过程和堆调整过程，总的时间复杂度为<code class="highlighter-rouge">O(n) + O(n*log(n)) = O(nlog(n))</code>。由于存在元素交换，因此堆排序不是稳定排序。</p>

<h2 id="堆的相关应用">堆的相关应用</h2>

<ul>
  <li><strong>求一个无序数组中第K大的元素</strong></li>
</ul>

<p>这是一道经典的面试题，如果不熟悉堆这种数据结构，首先想到的应该是排序。将数组排序后，从头开始向后遍历k个元素，得到最终结果。这种方式当数组较大的时候，效率并不高，时间复杂度为<code class="highlighter-rouge">O(Nlog(N)) + O(K)</code>，不是一种线性解法。</p>

<p>另一种思路是，当<code class="highlighter-rouge">K</code>值较小的情况，比如<code class="highlighter-rouge">k=3</code>，此时可以采用遍历<code class="highlighter-rouge">k</code>次数组的方式，第一次找到最大值，第二次找到次大值，依次类推…，这种方式的时间复杂度为<code class="highlighter-rouge">K*O(N)</code>比前面方法要好一些</p>

<p>这道题比较经典的方法是使用堆来解，扫描一遍数组即可。其思路为，建立一个k大小最小堆，如果数组中的元素比堆顶的大，则pop掉堆顶元素，入堆新元素。依次类推，最后堆中存放的是数组中前<code class="highlighter-rouge">k</code>个最大值元素，返回推顶元素即可。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">findKthLargest</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">priority_queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">pq</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">x</span><span class="o">:</span><span class="n">nums</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">pq</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;</span><span class="n">k</span><span class="p">){</span>
                <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;</span><span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">()){</span>
                    <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
                    <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>
<p>上述算法，遍历数组需要<code class="highlighter-rouge">O(n)</code>时间复杂度，一次<code class="highlighter-rouge">push</code>或<code class="highlighter-rouge">pop</code>操作需要 <code class="highlighter-rouge">O(logK)</code> 的时间复杂度，所以最坏情况下，<code class="highlighter-rouge">n</code>个元素都入堆一次，所以时间复杂度就是<code class="highlighter-rouge">O(nlogK)</code>。</p>

<ul>
  <li><strong>无序数组中位数问题</strong></li>
</ul>

<p>这也是一道经典的面试题，常规做法还是对数组排序，然后选出中位数。显然这种方式的时间复杂度和上面的例子相同，为<code class="highlighter-rouge">O(Nlog(N) + O(N/2))</code>。</p>

<p>如果使用堆，我们则无需排序即可找出中位数，如果做到呢？首先，我们需要维护两个堆，一个堆是小顶堆和一个堆是大顶堆，大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。如果数组的大小为偶数，则大小堆的size均为<code class="highlighter-rouge">n/2</code>，中位数为大小堆堆元素中的某一个。如果数组的大小为奇数，则可以令大顶堆的size为<code class="highlighter-rouge">n/2+1</code>，则中位数为大顶堆的堆顶元素。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">findMedium</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">){</span>
    <span class="n">priority_queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">maxHeap</span><span class="p">;</span>
    <span class="n">priority_queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">minHeap</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">x</span> <span class="o">:</span> <span class="n">arr</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">maxHeap</span><span class="p">.</span><span class="n">top</span><span class="p">()){</span>
            <span class="n">maxHeap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="n">minHeap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//adjust size</span>
        <span class="k">if</span><span class="p">(</span><span class="n">minHeap</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">maxHeap</span><span class="p">.</span><span class="n">size</span><span class="p">()){</span>
            <span class="n">maxHeap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">minHeap</span><span class="p">.</span><span class="n">top</span><span class="p">());</span>
            <span class="n">minHeap</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">minHeap</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">){</span>
            <span class="n">minHeap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">.</span><span class="n">top</span><span class="p">());</span>
            <span class="n">maxHeap</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">maxHeap</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://www.youtube.com/watch?v=NcZ2cu7gc-A&amp;list=PLnfg8b9vdpLn9exZweTJx44CII1bYczuk">CS106B-Stanford-YouTube</a></li>
  <li><a href="https://www.coursera.org/learn/algorithms-divide-conquer/home/welcome">Algorithms-Stanford-Cousera</a></li>
  <li><a href="https://www.coursera.org/learn/shuju-jiegou-suanfa/home/welcome">算法与数据结构-1-北大-Cousera</a></li>
  <li><a href="https://www.coursera.org/learn/gaoji-shuju-jiegou/home/welcome">算法与数据结构-2-北大-Cousera</a></li>
  <li><a href="https://courses.edx.org/courses/course-v1:TsinghuaX+30240184.1x+3T2017/course/">算法与数据结构-1-清华-EDX</a></li>
  <li><a href="https://courses.edx.org/courses/course-v1:PekingX+04833050X+1T2016/course/">算法与数据结构-2-清华-EDX</a></li>
  <li><a href="https://www.coursera.org/learn/algorithms/home/welcome">算法设计与分析-1-北大-Cousera</a></li>
  <li><a href="https://courses.edx.org/courses/course-v1:PekingX+04833050X+1T2016/course/">算法设计与分析-2-北大-EDX</a></li>
</ul>

:ET