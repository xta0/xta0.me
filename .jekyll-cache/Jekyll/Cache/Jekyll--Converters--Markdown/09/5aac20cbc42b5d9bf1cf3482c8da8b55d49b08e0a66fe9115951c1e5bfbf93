I"ÉN<h2 id="prgramming-paradigms">Prgramming Paradigms</h2>

<p><strong><em>Paradigm</em></strong>: In science, a <em>paradigm</em> describes distinct concepts or thought patterns in some scientific discipline.Main programming paradigms:</p>
<ul>
  <li>imperative programming</li>
  <li>functional programming</li>
  <li>logic programming</li>
</ul>

<p>Orthogonal to Object-oriented programming</p>

<h3 id="imperative-programming">Imperative Programming</h3>

<p>Imperative programming is about:</p>

<ul>
  <li>modifying mutable varaibles</li>
  <li>using assignments</li>
  <li>and control structure such as if-then-else, loops, break, continue, return.</li>
</ul>

<p>The most common informal way to understand imperative programs is as instruction sequences for a Von Neumann computerï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Processer &lt;---Bus---&gt; Memory
</code></pre></div></div>

<p>Thereâ€™s a strong correspondence between</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mutable variables &lt;-&gt; memory cells
variable dereferences &lt;-&gt; load instruction
variable assignments &lt;-&gt; store instructions
control structures &lt;-&gt; jumps
</code></pre></div></div>

<ul>
  <li><em>Problem</em>
    <ul>
      <li>æ‰©å±•æ€§é—®é¢˜</li>
      <li>Scaling up. How can we avoid conceptualizing programs word by word ?</li>
    </ul>
  </li>
  <li><em>Reference</em>
    <ul>
      <li>John Backus, Can Programming Be Liberated from the von Neumann Style?</li>
      <li>Turing Award Lecture 1978. 1950s å‘æ˜Fortranï¼Œ20å¹´åæ„è¯†åˆ°Fortrançš„å±€é™æ€§ã€‚</li>
    </ul>
  </li>
</ul>

<p>In the end, pure imperative programming is limited by the â€œVon Neumannâ€ bottleneck:</p>

<blockquote>
  <p><em>One tends to concepualize data structures word-by-word.</em></p>
</blockquote>

<p>We need other techniques for defining high-level abstractions such as collections, polynomials, geometric shapes, strings, documents,â€¦
Ideally: Develop <em>thories</em> of collections, shapes, stringsâ€¦</p>

<h3 id="what-is-a-theory">What is a Theory?</h3>

<p>A theory consists of :</p>

<ul>
  <li>one or more data types æ•°æ®ç±»å‹</li>
  <li>operations on these types æ•°æ®æ“ä½œ</li>
  <li>laws that describe the relationships between values and operations å®ƒä»¬ä¹‹é—´çš„å…³ç³»</li>
</ul>

<p><strong>Normally, a theory does not describe mutations!</strong></p>

<h3 id="theories-without-mutation">Theories without Mutation</h3>

<p>For instance the theory of polynomials defines the sum of two polynomials by laws such as:</p>

<p><code class="highlighter-rouge">( a * x +b ) + (c * x +b ) = (a+c)* x + (b+d)</code></p>

<p>But it does not define an operator to change a coefficient while keeping the polynomial the same</p>

<p>ä½†æ˜¯Theoryä¸­å¹¶æ²¡æœ‰å…³äºmutationçš„å®šä¹‰ï¼Œä¸€ä¸ªå¤šé¡¹å¼çš„ç³»æ•°å¦‚æœç”¨ä»£ç è¡¨ç¤º:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Polynomial { double[] coefficient; }
Ploynomial p = ...;
p.coefficient[0] = 42;
</code></pre></div></div>
<p>pçš„ç³»æ•°å¯ä»¥ä»å¤–éƒ¨è¢«ä¿®æ”¹è€Œå˜åŒ–ï¼Œè€Œpå´ä¸å˜ï¼Œè¿™æ˜¾ç„¶è¿èƒŒäº†æ•°å­¦å…¬å¼çš„å”¯ä¸€æ€§ï¼šå½“ç³»æ•°ç¡®å®šæ—¶ï¼Œå¤šé¡¹å¼pæ˜¯å”¯ä¸€çš„ï¼Œå½“ç³»æ•°å˜åŒ–æ—¶ï¼Œäº§ç”Ÿæ–°çš„å¤šé¡¹å¼pã€‚å› æ­¤ï¼Œæ•°å­¦å‡½æ•°æ˜¯æ²¡æœ‰mutationçš„ï¼Œä½†æ˜¯å°†è¿™ä¸ªæ¨¡å‹æ˜ å°„åˆ°ç¨‹åºä¸­ï¼Œå´å¾ˆéš¾åšåˆ°ã€‚</p>

<h3 id="consequences-for-programming">Consequences for Programming</h3>

<p>If we want to implement high-level concepts following their mathematical theories, thereâ€™s no place for mutation.</p>

<p>æ‰¿æ¥ä¸Šé¢çš„é—®é¢˜ï¼Œå¦‚æœæˆ‘ä»¬æƒ³æŠŠæ•°å­¦æ¨¡å‹æ˜ å°„åˆ°ç¨‹åºä¸­ï¼Œæ˜¯ä¸å…è®¸mutationå­˜åœ¨çš„ã€‚</p>

<ul>
  <li>The theories do not admit it.</li>
  <li>Mutation can destroy useful laws in the theories</li>
</ul>

<p>Therefore, letâ€™s :</p>

<ol>
  <li>concentrate on defining theories for operators expressed as functions</li>
  <li>avoid mutations</li>
  <li>have powerful ways to abstract and compose functions.</li>
</ol>

<h3 id="functional-programming">Functional Programming</h3>

<ul>
  <li>
    <p>In a <em>restricted</em> sense, FP means programming without mutable variables, assignments, loops, and other imperative control structures.æ²¡æœ‰å˜é‡ï¼Œèµ‹å€¼ï¼Œå¾ªç¯ï¼Œè¿‡ç¨‹æ€§æ§åˆ¶è¯­å¥</p>
  </li>
  <li>In a <em>wider</em> sense, functional programming means focusing on the functions</li>
  <li>In particular, functions can be values that are produced, consumed, and composed.functions in a FP language are first-class citizens.
    <ul>
      <li>they can be defined anywhere, including inside other functions</li>
      <li>like any other value,they can be passed as parameters to functions and returned as results</li>
      <li>as for other values, there  exists a set of operators to compose functions.</li>
    </ul>
  </li>
</ul>

<h3 id="some-fp-lanugages">Some FP lanugages</h3>

<ul>
  <li>In the restriced sense:
    <ul>
      <li>Pure Lisp, XSLT, XPath, XQuery, FP</li>
      <li>Haskell(without I/O, Monad, or UnsafePerformIO)</li>
    </ul>
  </li>
  <li>In the wider sense:
    <ul>
      <li>Lisp, Scheme, Racket, Clojure</li>
      <li>SML, OCaml, F#</li>
      <li>Haskell(full language)</li>
      <li>Scala</li>
      <li>Smalltalk Ruby(!) æ”¯æŒblockçš„OOP</li>
    </ul>
  </li>
</ul>

<h3 id="history-of-fp-lauguages">History of FP lauguages</h3>

<ul>
  <li>1959 Lisp</li>
  <li>1975-77 ML,FP,Scheme</li>
  <li>1978 Smalltalk</li>
  <li>1986 SML</li>
  <li>1990 Haskell, Erlang</li>
  <li>1999 XSLT</li>
  <li>2000 OCaml</li>
  <li>2003 Scala, XQuery</li>
  <li>2005 F#</li>
  <li>2007 Clojure</li>
</ul>

<h3 id="recommended-book">Recommended Book</h3>

<ul>
  <li>
    <p><strong>SICP</strong>: A classic. Many parts of the course and quizzes are based on it, but we change the language from Scheme to Scala.</p>
  </li>
  <li>
    <p><strong>Programming in Scala</strong>: The standard language introduction and reference</p>
  </li>
</ul>

<h3 id="why-functional-prgramming">Why Functional Prgramming?</h3>

<ul>
  <li>simpler reasoning principles</li>
  <li>better modularity</li>
  <li>good for exploiting parallelism for multicore and cloud computing.</li>
</ul>

<p>To find out more see the video of my 2011 Oscon Java keynote:<a href="https://www.youtube.com/watch?v=3jg1AheF4n0">Working Hard to Keep it Simple</a></p>

<ul>
  <li>Keynote of <Working Hard="" to="" Keep="" it="" Simple="">
</Working>    <ul>
      <li>å¤šæ ¸å¯¹å¹¶è¡Œè®¡ç®—æœ‰è¦æ±‚ï¼Œä½†æ˜¯ç°ä»£çš„ç¼–ç¨‹è¯­è¨€ç¼ºä¹å¯¹è¿™æ–¹é¢çš„æ”¯æŒ</li>
      <li>Parallel Programming vs Concurrent Programming
        <ul>
          <li>å¹¶è¡Œç¼–ç¨‹ä¸»è¦åˆ©ç”¨CPUå¤šæ ¸ç‰¹æ€§ï¼Œä½¿ä»»åŠ¡å¤„ç†å˜çš„å¿«é€Ÿï¼Œä½†æ˜¯ä»»åŠ¡å¤„ç†å¯ä»¥ä½¿æœ‰åºçš„</li>
          <li>å¹¶å‘ç¼–ç¨‹æŒ‡çš„æ˜¯åŒä¸€æ—¶åˆ»éœ€è¦å¤„ç†è®¸å¤šä»»åŠ¡</li>
          <li>Both too hard to get right!</li>
        </ul>
      </li>
      <li>The Root of The Problem
        <ul>
          <li>å¤šçº¿ç¨‹å¼•èµ·çš„ä¸ç¡®å®šæ€§</li>
          <li>ä¸ç¡®å®šæ€§ = å¹³è¡Œè®¡ç®— + mutable state</li>
          <li>å¦‚æœè¦ä¿è¯å¹¶è¡Œè®¡ç®—çš„ç¡®å®šæ€§ï¼Œé¦–å…ˆè¦avoid mutable state</li>
          <li>Avoiding mutable state æ„å‘³ç€ programming functionally</li>
        </ul>
      </li>
      <li>Scala:
        <ul>
          <li>Agile, with lightweight syntax</li>
          <li>OO</li>
          <li>Functional</li>
          <li>Safe and performant, with strong static typing</li>
        </ul>
      </li>
      <li>Different Tools for Different Purposes
        <ul>
          <li>Parallelism:
            <ul>
              <li>Collections : Parallel Collections</li>
              <li>Collections : Distributed Collections</li>
              <li>Parallel DSLs</li>
            </ul>
          </li>
          <li>Concurrency:
            <ul>
              <li>Actors</li>
              <li>Software transactional memory</li>
              <li>Futures</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="elements-of-programming">Elements of Programming</h2>

<p>Every non-trivial programming language provides:</p>
<ul>
  <li>primitive expressions representing the simplest elements</li>
  <li>ways to combine expressions</li>
  <li>ways to abstract expressions, which introduce a name for an expression by which it can then be referred to</li>
</ul>

<h3 id="repl">REPL</h3>

<ul>
  <li>è¿›å…¥scalaå‘½ä»¤è¡Œ:<code class="highlighter-rouge">scala</code> / <code class="highlighter-rouge">sbt console</code></li>
  <li>é€€å‡ºscala:<code class="highlighter-rouge">:quit</code></li>
</ul>

<h3 id="evaluation">Evaluation</h3>

<p>A non-primitive expression is evaluated as follows/</p>

<ol>
  <li>Take the leftmost operator</li>
  <li>Evaluate its operands (left before right)</li>
  <li>Apply the operator to the operands</li>
</ol>

<p>A name is evaluated by replacing it with the right hand side of its definiation
The evaluation process stops once it results in a value</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">def</span> <span class="nf">square</span><span class="o">(</span><span class="nl">x:</span><span class="nc">Double</span><span class="o">)</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
<span class="nl">square:</span> <span class="o">(</span><span class="nl">x:</span> <span class="nc">Double</span><span class="o">)</span><span class="nc">Double</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">def</span> <span class="nf">sumOfSquares</span><span class="o">(</span><span class="nl">x:</span><span class="nc">Double</span><span class="o">,</span><span class="nl">y:</span><span class="nc">Double</span><span class="o">)</span>  <span class="o">=</span> <span class="n">square</span><span class="o">(</span><span class="n">x</span><span class="o">)+</span><span class="n">square</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
<span class="nl">sumOfSquares:</span> <span class="o">(</span><span class="nl">x:</span> <span class="nc">Double</span><span class="o">,</span> <span class="nl">y:</span> <span class="nc">Double</span><span class="o">)</span><span class="nc">Double</span>
</code></pre></div></div>

<h3 id="parameter-and-return-types">Parameter and Return Types</h3>

<p>Function parameters come with their type, which is given after a colon</p>

<pre><code class="language-Scala">def power(x: Double, y:Int) :Double = 
</code></pre>
<p>If a return type is given, it follows the parameter list.Primitive types are as in Java, but are written capitalized</p>

<ol>
  <li><code class="highlighter-rouge">Int</code> : 32-bit integers</li>
  <li><code class="highlighter-rouge">Double</code> : 64-bit floating pointer numbers</li>
  <li><code class="highlighter-rouge">Boolean</code> boolean values <code class="highlighter-rouge">true</code> and <code class="highlighter-rouge">false</code></li>
</ol>

<h3 id="evaluation-of-function-applications">Evaluation of Function Applications</h3>

<ul>
  <li>Evaluate å‡½æ•°å‚æ•°ï¼Œä»å·¦åˆ°å³</li>
  <li>å°†å‡½æ•°æŒ‰ç…§ç­‰å·å³è¾¹å±•å¼€</li>
  <li>å°†å‡½æ•°å†…éƒ¨çš„å‚æ•°æ›¿æ¢æˆä¼ å…¥çš„å‚æ•°</li>
  <li>
    <p>Example:</p>

    <pre><code class="language-Scala">  sumOfSquare(3,2+2)
  sumOfSquare(3,4)
  square(3) + square(4)
  3*3 + square(4)
  9 + 4*4
  9 + 16
  25
</code></pre>
  </li>
</ul>

<h3 id="the-substitution-model">The substitution model</h3>

<ul>
  <li>
    <p>This scheme of expression evaluation is called <em>substitution model</em> ï¼ˆè¿™ç§è§„åˆ™è¢«ç§°ä¸ºæ›¿æ¢æ¨¡å‹ï¼‰</p>
  </li>
  <li>
    <p>the idea underlying this model is that all evaluation does is <em>reduce an expression</em>  to a value. ï¼ˆæ€æƒ³æ˜¯æ‰€æœ‰å¯¹è¡¨è¾¾å¼çš„æ±‚å€¼éƒ½ä¼šreduceå‡ºä¸€ä¸ªvalueï¼Œç±»ä¼¼äºä»£æ•°æ±‚å€¼ï¼Œä¹Ÿå¯ä»¥ç†è§£ä¸ºæ‰€æœ‰è¡¨è¾¾å¼éƒ½ä¼šæœ€ç»ˆæœ‰ä¸€ä¸ªè¾“å‡ºï¼‰</p>
  </li>
  <li>
    <p>It can be applied to all expressions, as long as they have no side effects.ï¼ˆä»–å¯ä»¥è¢«åº”ç”¨åˆ°æ‰€æœ‰çš„è¡¨è¾¾å¼ä¸­ï¼Œä½†æ˜¯è¡¨è¾¾å¼ä¸­ä¸å…è®¸å‡ºç°side-effectï¼šä¸ç¬¦åˆæ›¿æ¢æ¨¡å‹çš„è¡¨è¾¾å¼ï¼Œå¦‚ a++;ï¼‰</p>
  </li>
  <li>
    <p>The substitution model is formalized in the <em>lamda-calculus</em>, which gives a foudation for function programming.ï¼ˆè¿™ç§æ›¿æ¢æ¨¡å‹è¢«æ ‡å‡†åŒ–ä¸ºlamdaè¡¨è¾¾å¼ï¼Œå¥ å®šäº†FPçš„åŸºç¡€ã€‚ï¼‰</p>
  </li>
</ul>

<h3 id="termination">Termination</h3>

<p>Does every expression reduce to a value (in a finite number of steps)?No. Here is a counter-example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">loop</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">loop</span>
<span class="n">loop</span><span class="o">;</span>
</code></pre></div></div>

<h3 id="chaning-the-evaluation-strategy">Chaning the evaluation strategy</h3>

<p>The interpreter reduces function arguments to values before rewriting the function application.</p>

<p>One could alternatively apply the function to unreduced arguments.Example:</p>

<pre><code class="language-Scala">sumOfSquare(3,2+2)
square(3) + square(2+2)
3*3 + square(2+2)
9 + (2+2)(2+2)
9 + 4*4
25
</code></pre>
<p>Scalaçš„è§£é‡Šå™¨åœ¨å¤„ç†å‡½æ•°çš„å‚æ•°æ—¶ï¼Œä¸€ç§æ–¹å¼æ˜¯å°†å‚æ•°å…ˆè¿›è¡Œæ±‚å€¼åä»£å…¥ï¼Œå¦ä¸€ç§æ–¹å¼æ˜¯lazyçš„å½¢å¼ï¼Œå‚æ•°ä¸€ç›´å¸¦å…¥åˆ°æœ€åå†æ±‚å€¼ã€‚</p>

<ol>
  <li>å‰ä¸€ç§ç§°ä¸º <em>call-by-value</em> ï¼Œ å®ƒçš„ä¼˜åŠ¿æ˜¯å¯¹å…¥å‚è¡¨è¾¾å¼åªè¿›è¡Œä¸€æ¬¡æ±‚å€¼</li>
  <li>åä¸€ç§ç§°ä¸º <em>call-by-name</em> ï¼Œ å®ƒçš„ä¼˜åŠ¿æ˜¯å¦‚æœå‚æ•°åœ¨å‡½æ•°ä¸­ä¸ä¼šä½¿ç”¨ï¼Œé‚£ä¹ˆå°±ä¸ä¼šè¿›è¡Œæ±‚å€¼è¿ç®—</li>
</ol>

<h3 id="evaluation-strategies-and-termination">Evaluation Strategies and Termination</h3>

<p>Scalaä¸­é€šå¸¸ä½¿ç”¨CBVï¼Œä½†æ˜¯å¦‚æœå‚æ•°ç”¨<code class="highlighter-rouge">=&gt;</code>ä¿®é¥°åˆ™ä»£è¡¨è¯¥å‚æ•°ç”¨CBNæ±‚å€¼,Example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">constOne</span><span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=</span> <span class="mi">1</span>
</code></pre></div></div>

<h2 id="conditionals-and-value-definiation">Conditionals and Value Definiation</h2>

<h3 id="conditional-expressions">Conditional Expressions</h3>

<p>To express choosing between two alternatives, Scalaä½¿ç”¨æ¡ä»¶è¡¨è¾¾å¼ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if - else
</code></pre></div></div>

<p>å®ƒå’ŒJavaä¸­çš„<code class="highlighter-rouge">if-else</code>å¾ˆåƒï¼Œä½†æ˜¯åœ¨imperative programmingä¸­ï¼Œ<code class="highlighter-rouge">if-else</code>ç§°ä¸ºstatementï¼Œå‡½æ•°å‹è¯­è¨€ä¸­æ²¡æœ‰statementï¼Œåªæœ‰expressionï¼Œ[è€Œæ ¹æ®Dançš„è¯¾ç¨‹], Expressionè¦å…·å¤‡ä¸‰ç‚¹ï¼š</p>

<ol>
  <li>syntax</li>
  <li>type checking rules</li>
  <li>evaluation rules</li>
</ol>

<p>å…·ä½“å¯ä»¥å‚è€ƒMLä¸­å…³äº<code class="highlighter-rouge">if-else</code>çš„æè¿°ï¼ŒExample:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">abs</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">)</span> <span class="n">x</span> <span class="k">else</span> <span class="o">-</span><span class="n">x</span>
</code></pre></div></div>

<h3 id="value-definitions">Value Definitions</h3>

<p>ä¸Šé¢å·²ç»çœ‹åˆ°ï¼Œå‡½æ•°çš„å‚æ•°å¯ä»¥é€šè¿‡CBVå’ŒCBNä¸¤ç§æ–¹å¼æ±‚å€¼ï¼ŒåŒæ ·çš„è§„åˆ™ä¹Ÿé€‚ç”¨äºå®šä¹‰å‡½æ•°ã€‚</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">def</code> æ˜¯CBNï¼Œç­‰å·å³è¾¹åœ¨å‡½æ•°è¢«è°ƒç”¨çš„æ—¶å€™å†è¿›è¡Œæ±‚å€¼</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">val</code> æ˜¯CBVï¼Œç­‰å·å³è¾¹åœ¨å‡½æ•°å®šä¹‰çš„æ—¶å€™è¿›è¡Œæ±‚å€¼</p>
  </li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val x = 2
val y = square(x)

</code></pre></div></div>
<p>Afterwards, the name refers to the value.</p>

<p>For instance, y above refers to 4, not square(2)</p>

<h3 id="value-definitions-and-termination">Value Definitions and Termination</h3>

<p><code class="highlighter-rouge">val</code>å’Œ<code class="highlighter-rouge">def</code>çš„åŒºåˆ«å½“ç­‰å·å³è¾¹çš„è¡¨è¾¾å¼ä¸ºæ­»å¾ªç¯æ—¶ï¼Œä¾¿å¯ä»¥ä½“ç°çš„å¾ˆæ¸…æ¥šï¼š</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">loop</span> <span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">loop</span>
</code></pre></div></div>

<ul>
  <li>A definition:</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def x = loop

</code></pre></div></div>
<p>æ²¡é—®é¢˜ï¼Œç­‰å·å³è¾¹ä¸ä¼šæ±‚å€¼ã€‚</p>

<ul>
  <li>Value:</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val x = loop

</code></pre></div></div>
<p>æ­»å¾ªç¯ï¼Œç­‰å·å³è¾¹å®šä¹‰çš„æ—¶å€™è¿›è¡Œäº†æ±‚å€¼ã€‚</p>

<blockquote>
  <p>å¯¹äºRecursiveçš„å‡½æ•°ï¼Œå‡½æ•°çš„è¿”å›å€¼éœ€è¦æ˜¾å¼å£°æ˜ï¼Œå¦åˆ™è¿”å›å€¼æ˜¯optionalçš„ã€‚</p>
</blockquote>

<h2 id="blocks-and-lexical-scope">Blocks and Lexical Scope</h2>

<h3 id="nested-functions">Nested functions</h3>

<p>ä¸€èˆ¬æ¥è¯´ï¼Œä¸€ä¸ªä»»åŠ¡å¯ä»¥åˆ†è§£ä¸ºå¤šä¸ªå‡½æ•°æ¥å®ç°ï¼Œä½†æœ‰äº›å‡½æ•°åªæ˜¯helperï¼Œå¹¶åªä¼šè¢«è°ƒç”¨ä¸€æ¬¡ï¼Œå®ƒä¸éœ€è¦æš´éœ²å‡ºæ¥ï¼Œè¿™æ—¶å€™éœ€è¦è€ƒè™‘ä½¿ç”¨blockï¼š</p>

<pre><code class="language-Scala">def cal(x:Double) = 
{
	def func1(x:Double):Double = x+1
	def func2(x:Double):Double = x*x
	func1(x) + func2(x)
}
</code></pre>

<h3 id="blocks-in-scala">Blocks in Scala</h3>

<ul>
  <li>blockç”¨{â€¦}è¡¨ç¤º</li>
</ul>

<pre><code class="language-Scala">{
	val x = f(3)
	x*x
}
</code></pre>
<ul>
  <li>å®ƒé‡Œé¢åŒ…å«ä¸€ç³»åˆ—definition æˆ–è€… expression</li>
  <li>The last element of a block is an expression that defines its value(æœ€åä¸€ä¸ªå€¼ä¸ºblockçš„è¿”å›å€¼)</li>
  <li>This return expression can be preceded by auxiliary definitions</li>
  <li>Blocks are themselves expressions; a block may appear everywhere an expression can. (æ„æ€æ˜¯blockæ˜¯first classçš„)</li>
</ul>

<h3 id="blocks-and-visibility">Blocks and Visibility</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val x = 0

def f(y:Int) = y+1

val result = {

	val x = f(3)
	x*x

}
</code></pre></div></div>

<ul>
  <li>The definitions inside a block are only visible from within the block.</li>
  <li>the definitions inside a block <em>shadow</em> definitions of the same names outside the block</li>
</ul>

<h3 id="lexical-scoping">Lexical Scoping</h3>

<p>Definitions of outer blocks are visible inside a block unless they are shadowed.</p>

<p>Therefore, we can simplify <code class="highlighter-rouge">sqrt</code> by eliminating redundant occurrences of the x parameter, which means everywhere the same thing.</p>

<h3 id="semicolons">Semicolons</h3>

<p>Scalaä¸­åˆ†å·æ˜¯optionalçš„ï¼Œä½†æ˜¯å¤šä¸ªè¡¨è¾¾å¼åœ¨ä¸€è¡Œæ—¶ï¼Œåˆ†å·æ˜¯ä¸èƒ½çœçš„:</p>

<pre><code class="language-Scala">val y = x+1; y*y
</code></pre>

<h3 id="summary">Summary</h3>

<ol>
  <li>arithmetic and boolean expressions</li>
  <li>conditional expressions if-else</li>
  <li>functions with recursion</li>
  <li>nesting and lexical scope</li>
  <li>CBN and CBV</li>
</ol>

<h2 id="resource">Resource</h2>

<ul>
  <li><a href="">Programming in Scala</a></li>
</ul>

:ET